/*
 *  TPZMohrCoulomb.h
 *  FEMPZ
 *
 *  Created by Diogo Cecilio on 5/4/10.
 *  Copyright 2010 __MyCompanyName__. All rights reserved.
 *
 */


/* Generated by Together */// $Id: TPZMohrCoulomb.h,v 1.2 2010-06-11 22:12:14 diogo Exp $

#ifndef TPZMOHRCOULOMBNETO_H
#define TPZMOHRCOULOMBNETO_H

#include "pzlog.h"
#include "TPZTensor.h"
#include "pzvec_extras.h"
#include "pzsave.h"

#ifdef LOG4CXX
static LoggerPtr loggerMohrCoulomb(Logger::getLogger("pz.plasticity.mohrcoulombneto"));
#endif



class TPZMohrCoulombNeto
{

    REAL fYoung;
    REAL fPoisson;
    REAL fPhi;
    REAL fPsi;
    REAL coesion;
    
public:
    
    struct TPlasticState
    {
        TPZTensor<REAL> fEpsPlastic;
        REAL fEpsPlasticBar;
    };
    
protected:
    
    TPlasticState fState;
    
public:
    
    TPZMohrCoulombNeto() : fYoung(25000.), fPoisson(0.2), fPhi(M_PI/9.),fPsi(M_PI/9.), coesion(9.35)
    {
        
    }
    REAL Lambda()
    {
        return fPoisson*fYoung/(1.+fPoisson)*(1.-2.*fPoisson);
    }
    REAL Mu()
    {
        return fYoung/(2.*(1.+fPoisson));
    }
    REAL G()
    {
        return fYoung/(2.*(1+fYoung));
    }
    REAL K()
    {
        return fYoung/(3.*(1.-2.*fPoisson));
    }
    
    template<class T>
    void PlasticityFunction(T epsp, T &sigmay, T &H) const
    {
        sigmay = T(15.)+(T(2571.43)-T(2.95238e6)*epsp)*(T(-0.0035)+epsp);
        H = T(12904.8)-T(5.90476e6)*epsp;
//        sigmay = T(15.)+(T(2571.43))*(T(-0.0035)) + T(12904.8)*epsp;
//        H = T(12904.8);
    }
    
    template<class T>
    TPZTensor<T> SigmaElast(const TPZTensor<T> &deform)
    {
        T trdeform = deform.I1();
        TPZTensor<T> result;
        result.Identity();
        result *= (Lambda()*trdeform);
        result.Add(deform,2.*Mu());
        return result;
    }
    
    template<class T>
    typename TPZTensor<T>::TPZDecomposed SigmaTrial(const TPZTensor<T> &epstotal)
    {
        TPZTensor<T> epslocal(epstotal);
        epslocal -= fState.fEpsPlastic;
        TPZTensor<T> sigma;
        sigma = SigmaElast(epslocal);
        typename TPZTensor<T>::TPZDecomposed sigma_trial;
        sigma.EigenSystem(sigma_trial);
#ifdef LOG4CXX
        if (loggerMohrCoulomb->isDebugEnabled()) {
            std::stringstream sout;
            sout << "Input stress tensor ";
            sigma.Print(sout);
            sout << "Input tensor in decomposed form\n";
            sigma_trial.Print(sout);
            LOGPZ_DEBUG(loggerMohrCoulomb, sout.str())
        }
#endif
        return sigma_trial;
    }
    
    template<class T>
    void ComputeSigma(TPZTensor<T> &epstotal, TPZTensor<T> &sigma)
    {
        typename TPZTensor<T>::TPZDecomposed sigma_trial = SigmaTrial(epstotal);
        T phi = PhiPlane<T>(sigma_trial);
        if (shapeFAD::val(phi) <= 0.) {
            sigma = TPZTensor<T>(sigma_trial);
            return;
        }
        typename TPZTensor<T>::TPZDecomposed sigma_projected;
        if (ReturnMapPlane<T>(sigma_trial, sigma_projected)) {
            sigma = TPZTensor<T>(sigma_projected);
        }
        else {
            const REAL sinpsi = sin(fPsi);
            TPZManVector<T,3> &eigenvalues = sigma_trial.fEigenvalues;
            REAL S = (1-sinpsi)*shapeFAD::val(eigenvalues[0])-2.*shapeFAD::val(eigenvalues[2])+(1+sinpsi)*shapeFAD::val(eigenvalues[1]);
            if (S > 0.) {
                ReturnMapRightEdge<T>(sigma_trial, sigma_projected);
            }
            else {
                ReturnMapLeftEdge<T>(sigma_trial, sigma_projected);
            }
#ifdef LOG4CXX
            {
                std::stringstream sout;
                sout << "After the map to the edge, sigma_projected :\n";
                sigma_projected.Print(sout);
                LOGPZ_DEBUG(loggerMohrCoulomb, sout.str())
            }
#endif
            sigma = TPZTensor<T>(sigma_projected);
        }
    }
    
    template<class T>
    T PhiPlane(typename TPZTensor<T>::TPZDecomposed &sigma) const
    {
        const REAL sinphi = sin(fPhi);
        const REAL cosphi = cos(fPhi);
        T sigmay,H;
        PlasticityFunction(T(fState.fEpsPlasticBar),sigmay, H);
        return sigma.fEigenvalues[0]-sigma.fEigenvalues[2]+(sigma.fEigenvalues[0]+sigma.fEigenvalues[2])*sinphi-2.*sigmay*cosphi;
    }

    template<class T>
    bool ReturnMapPlane(const typename TPZTensor<T>::TPZDecomposed &sigma_trial, typename TPZTensor<T>::TPZDecomposed &sigma_projected)
    {
        sigma_projected = sigma_trial;
        TPZManVector<T,3> &eigenvalues = sigma_projected.fEigenvalues;
//        TPZManVector<TPZTensor<T>,3> &eigenvectors = sigma_projected.fEigenvectors;
        const REAL sinphi = sin(fPhi);
        const REAL sinpsi = sin(fPsi);
        const REAL cosphi = cos(fPhi);
        const REAL sinphi2 = sinphi*sinphi;
        const REAL cosphi2 = 1.-sinphi2;
        const REAL constA = 4.* G() *(1.+ sinphi*sinpsi/3.) + 4.*K() * sinphi*sinpsi;
        T sigmay,H;
        PlasticityFunction(fState.fEpsPlasticBar,sigmay, H);
        T phi = eigenvalues[0]-eigenvalues[2]+(eigenvalues[0]+eigenvalues[2])*sinphi-2.*sigmay*cosphi;
        T gamma = 0.;
        REAL phival = shapeFAD::val(phi);
        REAL tolerance = 1.e-8;
        do {
            T denom = -constA- T(4.*cosphi2)*H;
//            T d = T(-4.*G()*(1.+sinphi*sinpsi/3.)-4.*K()*sinphi*sinpsi)-T(4.*cosphi2)*H;
            T deriv_gamma = -phi/denom;
            gamma += deriv_gamma;
            T epsbar = T(fState.fEpsPlasticBar)+gamma*T(2.*cosphi);
            PlasticityFunction(epsbar, sigmay, H);
            if (shapeFAD::val(H) < 0.) {
                DebugStop();
            }
            phi = eigenvalues[0]-eigenvalues[2]+(eigenvalues[0]+eigenvalues[2])*sinphi-2.*sigmay*cosphi-constA*gamma;
            phival = shapeFAD::val(phi);
            
        } while (abs(phival) > tolerance);
        eigenvalues[0] -= T(2.*G()*(1+sinpsi/3.)+2.*K()*sinpsi)*gamma;
        eigenvalues[1] += T((4.*G()/3. - K()*2.)*sinpsi)*gamma;
        eigenvalues[2] += T(2.*G()*(1-sinpsi/3.)-2.*K()*sinpsi)*gamma;
#ifdef DEBUG
        phi = eigenvalues[0]-eigenvalues[2]+(eigenvalues[0]+eigenvalues[2])*sinphi-2.*sigmay*cosphi;
#endif
        return (shapeFAD::val(eigenvalues[0])>shapeFAD::val(eigenvalues[1]) && shapeFAD::val(eigenvalues[1]) > shapeFAD::val(eigenvalues[2]));
    }
    
    template<class T>
    bool ReturnMapLeftEdge(const typename TPZTensor<T>::TPZDecomposed &sigma_trial, typename TPZTensor<T>::TPZDecomposed &sigma_projected)
    {
        sigma_projected = sigma_trial;
        TPZManVector<T,3> &eigenvalues = sigma_projected.fEigenvalues;
//        TPZManVector<TPZTensor<T>,3> &eigenvectors = sigma_projected.fEigenvectors;        
        const REAL sinphi = sin(fPhi);
        const REAL sinpsi = sin(fPsi);
        const REAL cosphi = cos(fPhi);
        const REAL sinphi2 = sinphi*sinphi;
        const REAL cosphi2 = 1.-sinphi2;
        TPZManVector<T,2> gamma(2,0.),phi(2,0.),sigma_bar(2,0.),ab(2,0.);
        TPZManVector<REAL,2> phival(2,0.);
        TPZFNMatrix<4,T> d(2,2,0.), dinverse(2,2,0.);
        sigma_bar[0] = eigenvalues[0]-eigenvalues[2]+(eigenvalues[0]+eigenvalues[2])*T(sinphi);
        sigma_bar[1] = eigenvalues[1]-eigenvalues[2]+(eigenvalues[1]+eigenvalues[2])*T(sinphi);
        T sigmay,H;
        PlasticityFunction(fState.fEpsPlasticBar,sigmay, H);
        phi[0] = sigma_bar[0] - T(2.*cosphi)*sigmay;
        phi[1] = sigma_bar[1] - T(2.*cosphi)*sigmay;
        ab[0] = T(4.*G()*(1+sinphi*sinpsi/3.)+4.*K()*sinphi*sinpsi);
        ab[1] = T(2.*G()*(1.-sinphi-sinpsi-sinphi*sinpsi/3.)+4.*K()*sinphi*sinpsi);
        REAL tolerance = 1.e-8;
        do {
            d(0,0) = -ab[0]-T(4.*cosphi2)*H;
            d(1,0) = -ab[1]-T(4.*cosphi2)*H;
            d(0,1) = -ab[1]-T(4.*cosphi2)*H;
            d(1,1) = -ab[0]-T(4.*cosphi2)*H;
            T detd = d(0,0)*d(1,1)-d(0,1)*d(1,0);
            dinverse(0,0) = d(1,1)/detd;
            dinverse(1,0) = -d(1,0)/detd;
            dinverse(0,1) = -d(0,1)/detd;
            dinverse(1,1) = d(0,0)/detd;
            gamma[0] -= (dinverse(0,0)*phi[0]+dinverse(0,1)*phi[1]);
            gamma[1] -= (dinverse(1,0)*phi[0]+dinverse(1,1)*phi[1]);
            T epsbar = T(fState.fEpsPlasticBar)+(gamma[0]+gamma[1])*T(2.*cosphi);
            PlasticityFunction(epsbar, sigmay, H);
            phi[0] = sigma_bar[0] - ab[0]*gamma[0] - ab[1]*gamma[1] - T(2.*cosphi)*sigmay;
            phi[1] = sigma_bar[1] - ab[1]*gamma[0] - ab[0]*gamma[0] - T(2.*cosphi)*sigmay;
            phival[0] = shapeFAD::val(phi[0]);
            phival[1] = shapeFAD::val(phi[1]);
        } while (abs(phival[0]) > tolerance || abs(phival[1]) > tolerance);
        
//        eigenvalues[0] -= T(2.*G()*(1+sinpsi/3.)+2.*K()*sinpsi)*gamma;
//        eigenvalues[1] += T((4.*G()/3. - K()*2.)*sinpsi)*gamma;
//        eigenvalues[2] += T(2.*G()*(1-sinpsi/3.)-2.*K()*sinpsi)*gamma;

        
        eigenvalues[0] -= T(2.*G()*(1+sinpsi/3.)+2.*K()*sinpsi)*gamma[0]+T((4.*G()/3.-2.*K())*sinpsi)*gamma[1];
        eigenvalues[1] += T((4.*G()/3.- K()*2.)*sinpsi)*gamma[0]-T(2.*G()*(1.+sinpsi/3.)+2.*K()*sinpsi)*gamma[1];
        eigenvalues[2] -= T(2.*G()*(1-sinpsi/3.)-2.*K()*sinpsi)*(gamma[0]+gamma[1]);
        return (shapeFAD::val(eigenvalues[0])>shapeFAD::val(eigenvalues[1]) && shapeFAD::val(eigenvalues[1]) > shapeFAD::val(eigenvalues[2]));
    }
    
    template<class T>
    bool ReturnMapRightEdge(const typename TPZTensor<T>::TPZDecomposed &sigma_trial, typename TPZTensor<T>::TPZDecomposed &sigma_projected)
    {
        sigma_projected = sigma_trial;
        TPZManVector<T,3> &eigenvalues = sigma_projected.fEigenvalues;
//        TPZManVector<TPZTensor<T>,3> &eigenvectors = sigma_projected.fEigenvectors;
        const REAL sinphi = sin(fPhi);
        const REAL sinpsi = sin(fPsi);
        const REAL cosphi = cos(fPhi);
        const REAL sinphi2 = sinphi*sinphi;
        const REAL cosphi2 = 1.-sinphi2;
        const REAL KV = K();
        const REAL GV = G();
        TPZManVector<T,2> gamma(2,0.),phi(2,0.),sigma_bar(2,0.),ab(2,0.);
        TPZManVector<REAL,2> phival(2,0.);
        TPZFNMatrix<4,T> d(2,2,0.), dinverse(2,2,0.);
        sigma_bar[0] = eigenvalues[0]-eigenvalues[2]+(eigenvalues[0]+eigenvalues[2])*T(sinphi);
        sigma_bar[1] = eigenvalues[0]-eigenvalues[1]+(eigenvalues[0]+eigenvalues[1])*T(sinphi);
        T sigmay,H;
        PlasticityFunction(fState.fEpsPlasticBar,sigmay, H);
        phi[0] = sigma_bar[0] - T(2.*cosphi)*sigmay;
        phi[1] = sigma_bar[1] - T(2.*cosphi)*sigmay;
        ab[0] = T(4.*GV*(1+sinphi*sinpsi/3.)+4.*KV*sinphi*sinpsi);
        ab[1] = T(2.*GV*(1.+sinphi+sinpsi-sinphi*sinpsi/3.)+4.*KV*sinphi*sinpsi);
#ifdef LOG4CXX
        {
            std::stringstream sout;
            sout << "phi = " << phi << std::endl;
            LOGPZ_DEBUG(loggerMohrCoulomb, sout.str())
        }
#endif
        
//#ifdef DEBUG
//        gamma[0] = 0.;
//        gamma[1] = 1.;
//        T v[3];
//        v[0] = -T(2.*GV*(1+sinpsi/3.)+2.*KV*sinpsi)*(gamma[0]+gamma[1]);
//        v[1] = T((4.*GV/3.- KV*2.)*sinpsi)*gamma[0]+T(2.*GV*(1.-sinpsi/3.)-2.*KV*sinpsi)*gamma[1];
//        v[2] = T(2.*GV*(1-sinpsi/3.)-2.*KV*sinpsi)*gamma[0]+T((4.*GV/3.-2.*KV)*sinpsi)*gamma[1];
//        eigenvalues[0] = sigma_trial.fEigenvalues[0]+v[0];
//        eigenvalues[1] = sigma_trial.fEigenvalues[1]+v[1];
//        eigenvalues[2] = sigma_trial.fEigenvalues[2]+v[2];
//        
//        T test1 = (v[0]-v[2])+(v[0]+v[2])*sinphi;
//        T test2 = (v[0]-v[1])+(v[0]+v[1])*sinphi;
//
//        sigma_bar[0] = eigenvalues[0]-eigenvalues[2]+(eigenvalues[0]+eigenvalues[2])*T(sinphi);
//        sigma_bar[1] = eigenvalues[0]-eigenvalues[1]+(eigenvalues[0]+eigenvalues[1])*T(sinphi);
//        T A = phi[0] - sigma_bar[0] + T(2.*cosphi)*sigmay;
//        T B = phi[1] - sigma_bar[1] + T(2.*cosphi)*sigmay;
//
//#endif
        REAL tolerance = 1.e-8;
        int iter = 0;
        T epsbar = T(fState.fEpsPlasticBar);
        do {
#ifdef LOG4CXX
            {
                std::stringstream sout;
                sout << "epsbar = " << epsbar << std::endl;
                sout << "sigmay = " << sigmay << std::endl;
                sout << "H = " << H << std::endl;
                LOGPZ_DEBUG(loggerMohrCoulomb, sout.str())
            }
#endif
            d(0,0) = -ab[0]-T(4.*cosphi2)*H;
            d(1,0) = -ab[1]-T(4.*cosphi2)*H;
            d(0,1) = -ab[1]-T(4.*cosphi2)*H;
            d(1,1) = -ab[0]-T(4.*cosphi2)*H;
            T detd = d(0,0)*d(1,1)-d(0,1)*d(1,0);
            dinverse(0,0) = d(1,1)/detd;
            dinverse(1,0) = -d(1,0)/detd;
            dinverse(0,1) = -d(0,1)/detd;
            dinverse(1,1) = d(0,0)/detd;
            gamma[0] -= (dinverse(0,0)*phi[0]+dinverse(0,1)*phi[1]);
            gamma[1] -= (dinverse(1,0)*phi[0]+dinverse(1,1)*phi[1]);
            epsbar = T(fState.fEpsPlasticBar)+(gamma[0]+gamma[1])*T(2.*cosphi);
            PlasticityFunction(epsbar, sigmay, H);
            if (shapeFAD::val(H) < 0.) {
                DebugStop();
            }
            iter++;
            phi[0] = sigma_bar[0] - ab[0]*gamma[0] - ab[1]*gamma[1] - T(2.*cosphi)*sigmay;
            phi[1] = sigma_bar[1] - ab[1]*gamma[0] - ab[0]*gamma[1] - T(2.*cosphi)*sigmay;
            phival[0] = shapeFAD::val(phi[0]);
            phival[1] = shapeFAD::val(phi[1]);
#ifdef LOG4CXX
            {
                std::stringstream sout;
                sout << "iter = " << iter << " phi = " << phival << std::endl;
                LOGPZ_DEBUG(loggerMohrCoulomb, sout.str())
            }
#endif
        } while (abs(phival[0]) > tolerance || abs(phival[1]) > tolerance);
        
//        eigenvalues[0] -= T(2.*GV*(1+sinpsi/3.)+2.*KV*sinpsi)*gamma;
//        eigenvalues[1] += T((4.*GV/3. - KV*2.)*sinpsi)*gamma;
//        eigenvalues[2] += T(2.*GV*(1-sinpsi/3.)-2.*KV*sinpsi)*gamma;
#ifdef LOG4CXX
        {
            std::stringstream sout;
            sout << "gamma = " << gamma << std::endl;
            sout << "phival = " << phival << std::endl;
            sout << "ab = " << ab << std::endl;
            sout << "sigma_bar = " << sigma_bar << std::endl;
            d.Print("Jacobian",sout);
            dinverse.Print("Inverse Jacobian",sout);
            sout << "epsbar = " << epsbar << std::endl;
            LOGPZ_DEBUG(loggerMohrCoulomb, sout.str())
        }
#endif
        eigenvalues[0] -= T(2.*GV*(1+sinpsi/3.)+2.*KV*sinpsi)*(gamma[0]+gamma[1]);
        eigenvalues[1] += T((4.*GV/3.- KV*2.)*sinpsi)*gamma[0]+T(2.*GV*(1.-sinpsi/3.)-2.*KV*sinpsi)*gamma[1];
        eigenvalues[2] += T(2.*GV*(1-sinpsi/3.)-2.*KV*sinpsi)*gamma[0]+T((4.*GV/3.-2.*KV)*sinpsi)*gamma[1];
#ifdef DEBUG
        sigma_bar[0] = eigenvalues[0]-eigenvalues[2]+(eigenvalues[0]+eigenvalues[2])*T(sinphi);
        sigma_bar[1] = eigenvalues[0]-eigenvalues[1]+(eigenvalues[0]+eigenvalues[1])*T(sinphi);
        epsbar = T(fState.fEpsPlasticBar)+(gamma[0]+gamma[1])*T(2.*cosphi);
        PlasticityFunction(epsbar, sigmay, H);

        phi[0] = sigma_bar[0] - T(2.*cosphi)*sigmay;
        phi[1] = sigma_bar[1] - T(2.*cosphi)*sigmay;
#endif
        return (shapeFAD::val(eigenvalues[0])>shapeFAD::val(eigenvalues[1]) && shapeFAD::val(eigenvalues[1]) > shapeFAD::val(eigenvalues[2]));        
    }

    
};


#endif //TPZMohrCoulomb_H
