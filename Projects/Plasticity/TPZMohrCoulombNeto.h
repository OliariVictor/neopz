/*
 *  TPZMohrCoulomb.h
 *  FEMPZ
 *
 *  Created by Diogo Cecilio on 5/4/10.
 *  Copyright 2010 __MyCompanyName__. All rights reserved.
 *
 */


/* Generated by Together */// $Id: TPZMohrCoulomb.h,v 1.2 2010-06-11 22:12:14 diogo Exp $

#ifndef TPZMOHRCOULOMBNETO_H
#define TPZMOHRCOULOMBNETO_H

#include "pzlog.h"
#include "TPZTensor.h"
#include "pzvec_extras.h"
#include "pzsave.h"

#ifdef LOG4CXX
static LoggerPtr loggerMohrCoulomb(Logger::getLogger("pz.plasticity.mohrcoulombneto"));
#endif



class TPZMohrCoulombNeto
{

    REAL fYoung;
    REAL fPoisson;
    REAL fPhi;
    REAL fPsi;
    REAL coesion;
    
public:
    
    struct TPlasticState
    {
        TPZTensor<REAL> fEpsPlastic;
        REAL fEpsPlasticBar;
    };
    
protected:
    
    TPlasticState fState;
    
public:
    
    TPZMohrCoulombNeto() : fYoung(25000.), fPoisson(0.2), fPhi(M_PI/9.),fPsi(M_PI/9.), coesion(9.35)
    {
        
    }
    REAL Lambda()
    {
        return fPoisson*fYoung/(1.+fPoisson)*(1.-2.*fPoisson);
    }
    REAL Mu()
    {
        return fYoung/(2.*(1.+fPoisson));
    }
    REAL G()
    {
        return fYoung/(2.*(1+fYoung));
    }
    REAL K()
    {
        return fYoung/(3.*(1.-2.*fPoisson));
    }
    
    template<class T>
    void PlasticityFunction(T epsp, T &sigmay, T &H) const
    {
        sigmay = T(15.)+(T(2571.43)-T(2.95238e6)*epsp)*(T(-0.0035)+epsp);
        H = T(12904.8)-T(5.90476e6)*epsp;
    }
    
    template<class T>
    TPZTensor<T> SigmaElast(const TPZTensor<T> &deform)
    {
        T trdeform = deform.I1();
        TPZTensor<T> result;
        result.Identity();
        result *= (Lambda()*trdeform);
        result.Add(deform,2.*Mu());
        return result;
    }
    
    template<class T>
    typename TPZTensor<T>::TPZDecomposed SigmaTrial(const TPZTensor<T> &epstotal)
    {
        TPZTensor<T> epslocal(epstotal);
        epslocal -= fState.fEpsPlastic;
        TPZTensor<T> sigma;
        sigma = SigmaElast(epslocal);
        typename TPZTensor<T>::TPZDecomposed sigma_trial;
        sigma.EigenSystem(sigma_trial);
#ifdef LOG4CXX
        if (loggerMohrCoulomb->isDebugEnabled()) {
            std::stringstream sout;
            sout << "Input tensor ";
            sigma.Print(sout);
            sout << "Eigenvalues " << sigma_trial.fEigenvalues << std::endl;
            sout << "Eigenvectors\n";
            for (int i=0; i<sigma_trial.fEigenvectors.size(); i++) {
                sigma_trial.fEigenvectors[i].Print(sout);
                sout << std::endl;
            }
            LOGPZ_DEBUG(loggerMohrCoulomb, sout.str())
        }
#endif
        return sigma_trial;
    }
    
    template<class T>
    void ComputeSigma(TPZTensor<T> &epstotal, TPZTensor<T> &sigma)
    {
        typename TPZTensor<T>::TPZDecomposed sigma_trial = SigmaTrial(epstotal);
        T phi = PhiPlane<T>(sigma_trial);
        if (shapeFAD::val(phi) <= 0.) {
            sigma = TPZTensor<T>(sigma_trial);
            return;
        }
        typename TPZTensor<T>::TPZDecomposed sigma_projected;
        if (ReturnMapPlane<T>(sigma_trial, sigma_projected)) {
            sigma = TPZTensor<T>(sigma_projected);
        }
        else {
            const REAL sinpsi = sin(fPsi);
            TPZManVector<T,3> &eigenvalues = sigma_trial.fEigenvalues;
            REAL S = (1-sinpsi)*shapeFAD::val(eigenvalues[0])-2.*shapeFAD::val(eigenvalues[2])+(1+sinpsi)*shapeFAD::val(eigenvalues[1]);
            if (S > 0.) {
                ReturnMapRightEdge<T>(sigma_trial, sigma_projected);
            }
            else {
                ReturnMapLeftEdge<T>(sigma_trial, sigma_projected);
            }
            sigma = TPZTensor<T>(sigma_projected);
        }
    }
    
    template<class T>
    T PhiPlane(typename TPZTensor<T>::TPZDecomposed &sigma) const
    {
        const REAL sinphi = sin(fPhi);
        const REAL cosphi = cos(fPhi);
        T sigmay,H;
        PlasticityFunction(T(fState.fEpsPlasticBar),sigmay, H);
        return sigma.fEigenvalues[0]-sigma.fEigenvalues[2]+(sigma.fEigenvalues[0]+sigma.fEigenvalues[2])*sinphi-2.*sigmay*cosphi;
    }

    template<class T>
    bool ReturnMapPlane(const typename TPZTensor<T>::TPZDecomposed &sigma_trial, typename TPZTensor<T>::TPZDecomposed &sigma_projected)
    {
        sigma_projected = sigma_trial;
        TPZManVector<T,3> &eigenvalues = sigma_projected.fEigenvalues;
        TPZManVector<TPZTensor<T>,3> &eigenvectors = sigma_projected.fEigenvectors;
        const REAL sinphi = sin(fPhi);
        const REAL sinpsi = sin(fPsi);
        const REAL cosphi = cos(fPhi);
        const REAL sinphi2 = sinphi*sinphi;
        const REAL cosphi2 = 1.-sinphi2;
        const REAL constA = 4.* G() *(1.+ sinphi*sinpsi/3.) + 4.*K() * sinphi*sinpsi;
        T sigmay,H;
        PlasticityFunction(fState.fEpsPlasticBar,sigmay, H);
        T phi = eigenvalues[0]-eigenvalues[2]+(eigenvalues[0]+eigenvalues[2])*sinphi-2.*sigmay*cosphi;
        T gamma = 0.;
        REAL phival = shapeFAD::val(phi);
        REAL tolerance = 1.e-8;
        do {
            T denom = -constA- T(4.*cosphi2)*H;
            T d = T(-4.*G()*(1.+sinphi*sinpsi/3.)-4.*K()*sinphi*sinpsi)-T(4.*cosphi2)*H;
            T deriv_gamma = -phi/denom;
            gamma += deriv_gamma;
            T epsbar = T(fState.fEpsPlasticBar)+gamma*T(2.*cosphi);
            PlasticityFunction(epsbar, sigmay, H);
            phi = eigenvalues[0]-eigenvalues[2]+(eigenvalues[0]+eigenvalues[2])*sinphi-2.*sigmay*cosphi;
            phival = shapeFAD::val(phi);
            
        } while (abs(phival) > tolerance);
        eigenvalues[0] -= T(2.*G()*(1+sinpsi/3.)+2.*K()*sinpsi)*gamma;
        eigenvalues[1] += T((4.*G()/3. - K()*2.)*sinpsi)*gamma;
        eigenvalues[2] += T(2.*G()*(1-sinpsi/3.)-2.*K()*sinpsi)*gamma;
        return (shapeFAD::val(eigenvalues[0])>shapeFAD::val(eigenvalues[1]) && shapeFAD::val(eigenvalues[1]) > shapeFAD::val(eigenvalues[2]));
    }
    
    template<class T>
    bool ReturnMapLeftEdge(const typename TPZTensor<T>::TPZDecomposed &sigma_trial, typename TPZTensor<T>::TPZDecomposed &sigma_projected)
    {
        sigma_projected = sigma_trial;
        TPZManVector<T,3> &eigenvalues = sigma_projected.fEigenvalues;
        TPZManVector<TPZTensor<T>,3> &eigenvectors = sigma_projected.fEigenvectors;        const REAL sinphi = sin(fPhi);
        const REAL sinpsi = sin(fPsi);
        const REAL cosphi = cos(fPhi);
        const REAL sinphi2 = sinphi*sinphi;
        const REAL cosphi2 = 1.-sinphi2;
        TPZManVector<T,2> gamma(2,0.),phi(2,0.),sigma_bar(2,0.),ab(2,0.);
        TPZManVector<REAL,2> phival(2,0.);
        TPZFNMatrix<4,T> d(2,2,0.), dinverse(2,2,0.);
        sigma_bar[0] = eigenvalues[0]-eigenvalues[2]+(eigenvalues[0]+eigenvalues[2])*T(sinphi);
        sigma_bar[1] = eigenvalues[1]-eigenvalues[2]+(eigenvalues[1]+eigenvalues[2])*T(sinphi);
        T sigmay,H;
        PlasticityFunction(fState.fEpsPlasticBar,sigmay, H);
        phi[0] = sigma_bar[0] - T(2.*cosphi)*sigmay;
        phi[1] = sigma_bar[1] - T(2.*cosphi)*sigmay;
        ab[0] = T(4.*G()*(1+sinphi*sinpsi/3.)+4.*K()*sinphi*sinpsi);
        ab[1] = T(2.*G()*(1.-sinphi-sinpsi-sinphi*sinpsi/3.)+4.*K()*sinphi*sinpsi);
        REAL tolerance = 1.e-8;
        do {
            d(0,0) = -ab[0]-T(4.*cosphi2)*H;
            d(1,0) = -ab[1]-T(4.*cosphi2)*H;
            d(0,1) = -ab[1]-T(4.*cosphi2)*H;
            d(1,1) = -ab[0]-T(4.*cosphi2)*H;
            T detd = d(0,0)*d(1,1)-d(0,1)*d(1,0);
            dinverse(0,0) = d(1,1)/detd;
            dinverse(1,0) = -d(1,0)/detd;
            dinverse(0,1) = -d(0,1)/detd;
            dinverse(1,1) = d(0,0)/detd;
            gamma[0] -= (dinverse(0,0)*phi[0]+dinverse(0,1)*phi[1]);
            gamma[1] -= (dinverse(1,0)*phi[0]+dinverse(1,1)*phi[1]);
            T epsbar = T(fState.fEpsPlasticBar)+(gamma[0]+gamma[1])*T(2.*cosphi);
            PlasticityFunction(epsbar, sigmay, H);
            phi[0] = sigma_bar[0] - ab[0]*gamma[0] - ab[1]*gamma[1] - T(2.*cosphi)*sigmay;
            phi[1] = sigma_bar[1] - ab[1]*gamma[0] - ab[0]*gamma[0] - T(2.*cosphi)*sigmay;
        } while (abs(phival[0]) > tolerance || abs(phival[1]) > tolerance);
        eigenvalues[0] -= T(2.*G()*(1+sinpsi/3.+2.*K()*sinpsi))*gamma[1]+T((4.*G()/3.-2.*K())*sinpsi)*gamma[1];
        eigenvalues[1] += T((4.*G()/3.- K()*2.)*sinpsi)*gamma[0]-T(2.*G()*(1.+sinpsi/3.)+2.*K()*sinpsi)*gamma[1];
        eigenvalues[2] -= T(2.*G()*(1-sinpsi/3.)-2.*K()*sinpsi)*(gamma[0]+gamma[1]);
        return (shapeFAD::val(eigenvalues[0])>shapeFAD::val(eigenvalues[1]) && shapeFAD::val(eigenvalues[1]) > shapeFAD::val(eigenvalues[2]));
    }
    
    template<class T>
    bool ReturnMapRightEdge(const typename TPZTensor<T>::TPZDecomposed &sigma_trial, typename TPZTensor<T>::TPZDecomposed &sigma_projected)
    {
        sigma_projected = sigma_trial;
        TPZManVector<T,3> &eigenvalues = sigma_projected.fEigenvalues;
        TPZManVector<TPZTensor<T>,3> &eigenvectors = sigma_projected.fEigenvectors;
        const REAL sinphi = sin(fPhi);
        const REAL sinpsi = sin(fPsi);
        const REAL cosphi = cos(fPhi);
        const REAL sinphi2 = sinphi*sinphi;
        const REAL cosphi2 = 1.-sinphi2;
        TPZManVector<T,2> gamma(2,0.),phi(2,0.),sigma_bar(2,0.),ab(2,0.);
        TPZManVector<REAL,2> phival(2,0.);
        TPZFNMatrix<4,T> d(2,2,0.), dinverse(2,2,0.);
        sigma_bar[0] = eigenvalues[0]-eigenvalues[2]+(eigenvalues[0]+eigenvalues[2])*T(sinphi);
        sigma_bar[1] = eigenvalues[0]-eigenvalues[1]+(eigenvalues[0]+eigenvalues[1])*T(sinphi);
        T sigmay,H;
        PlasticityFunction(fState.fEpsPlasticBar,sigmay, H);
        phi[0] = sigma_bar[0] - T(2.*cosphi)*sigmay;
        phi[1] = sigma_bar[1] - T(2.*cosphi)*sigmay;
        ab[0] = T(4.*G()*(1+sinphi*sinpsi/3.)+4.*K()*sinphi*sinpsi);
        ab[1] = T(2.*G()*(1.+sinphi+sinpsi-sinphi*sinpsi/3.)+4.*K()*sinphi*sinpsi);
        REAL tolerance = 1.e-8;
        do {
            d(0,0) = -ab[0]-T(4.*cosphi2)*H;
            d(1,0) = -ab[1]-T(4.*cosphi2)*H;
            d(0,1) = -ab[1]-T(4.*cosphi2)*H;
            d(1,1) = -ab[0]-T(4.*cosphi2)*H;
            T detd = d(0,0)*d(1,1)-d(0,1)*d(1,0);
            dinverse(0,0) = d(1,1)/detd;
            dinverse(1,0) = -d(1,0)/detd;
            dinverse(0,1) = -d(0,1)/detd;
            dinverse(1,1) = d(0,0)/detd;
            gamma[0] -= (dinverse(0,0)*phi[0]+dinverse(0,1)*phi[1]);
            gamma[1] -= (dinverse(1,0)*phi[0]+dinverse(1,1)*phi[1]);
            T epsbar = T(fState.fEpsPlasticBar)+(gamma[0]+gamma[1])*T(2.*cosphi);
            PlasticityFunction(epsbar, sigmay, H);
            phi[0] = sigma_bar[0] - ab[0]*gamma[0] - ab[1]*gamma[1] - T(2.*cosphi)*sigmay;
            phi[1] = sigma_bar[1] - ab[1]*gamma[0] - ab[0]*gamma[0] - T(2.*cosphi)*sigmay;
        } while (abs(phival[0]) > tolerance || abs(phival[1]) > tolerance);
        eigenvalues[0] -= T(2.*G()*(1+sinpsi/3.+2.*K()*sinpsi))*(gamma[0]+gamma[1]);
        eigenvalues[1] += T((4.*G()/3.- K()*2.)*sinpsi)*gamma[0]+T(2.*G()*(1.-sinpsi/3.)-2.*K()*sinpsi)*gamma[1];
        eigenvalues[2] += T(2.*G()*(1-sinpsi/3.)-2.*K()*sinpsi)*gamma[0]+T((4.*G()/3.-2.*K())*sinpsi)*gamma[1];
        return (shapeFAD::val(eigenvalues[0])>shapeFAD::val(eigenvalues[1]) && shapeFAD::val(eigenvalues[1]) > shapeFAD::val(eigenvalues[2]));        
    }

    
};


#endif //TPZMohrCoulomb_H
