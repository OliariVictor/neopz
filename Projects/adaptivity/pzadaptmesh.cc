/* Generated by Together */

#include "pzadaptmesh.h"
#include "pzgclonemesh.h"
#include "pzcclonemesh.h"
#include "pzgeoel.h"
#include "pzcompel.h"
#include "pzfstrmatrix.h"
#include "pzstepsolver.h"
#include "pzintel.h"
#include "pzquad.h"
#include "pzonedref.h"

TPZAdaptMesh::TPZAdaptMesh(){
  fReference = 0;
  fGeoRef.Resize(0);
  fPatch.Resize(0);
  fPatchIndex.Resize(0);
  fElementError.Resize(0);
  fCloneMesh.Resize(0);
  fFineCloneMesh.Resize(0);
  fMaxP = 10;
}

TPZAdaptMesh::~TPZAdaptMesh(){
  CleanUp();
}

void TPZAdaptMesh::SetCompMesh(TPZCompMesh * mesh){
  if(!mesh){
    cout <<"TPZAdaptMesh::Error:\n computational reference mesh must not be NULL!\n";
    return;
  }
  CleanUp();
  //  fReference = mesh;
  fReference = mesh;
  int nel = fReference->ElementVec().NElements();
  fElementError.Resize(nel);
}

void TPZAdaptMesh::SetMaxP(int maxp){
  if (maxp < 1) {
    cout << "TPZAdaptMesh::Error : SetMaxP - maximum p order must be greter than 0... trying to set maximum p to " 
	 << maxp << endl;
    return;
  }
  fMaxP = maxp;
  TPZOneDRef::gMaxP = fMaxP;
}

void TPZAdaptMesh::CleanUp(){

  int i;
  for (i=0;i<fCloneMesh.NElements();i++){
    TPZGeoMesh *gmesh =  fCloneMesh[i]->Reference();
	gmesh->ResetReference();
	fFineCloneMesh[i]->LoadReferences();
	this->RemoveCloneBC(fFineCloneMesh[i]);
	DeleteElements(fFineCloneMesh[i]);
	delete fFineCloneMesh[i];
	gmesh->ResetReference();
	fCloneMesh[i]->LoadReferences();
	RemoveCloneBC(fCloneMesh[i]);
	DeleteElements(fCloneMesh[i]);
    delete fCloneMesh[i];
    delete gmesh;
  }
  fCloneMesh.Resize(0);
  fFineCloneMesh.Resize(0);
}

TPZCompMesh * TPZAdaptMesh::GetAdaptedMesh(REAL &error, REAL & truerror, TPZVec<REAL> &ervec, 
					   void(*f)(TPZVec<REAL> &loc, TPZVec<REAL> &val, TPZFMatrix &deriv),
					   TPZVec<REAL> &truervec, 
					   TPZVec<REAL> &effect){
  //gets the geometric reference elements that will generate the patch
  GetReferenceElements();
  //  int ngrp = fGeoRef.NElements();
  int i;

  //Generates the patch
  BuildReferencePatch();

  //Creates the patch clones;
  fReference->ComputeNodElCon();

  int printing = 0;
  if(printing) {
	  ofstream test("test.txt",ios::app);
	  fReference->Print(test);
	  fReference->Reference()->Print(test);
  }
  CreateClones();

  //clone analysis
  int cliter;
  int ncl = fCloneMesh.NElements();
  fFineCloneMesh.Resize(ncl);
  int nelmesh = fReference->ElementVec().NElements();
  fElementError.Resize(nelmesh);
  
  effect.Resize(nelmesh);
  truervec.Resize(nelmesh);
  ervec.Resize(nelmesh);
  ervec.Fill(0.);
  truervec.Fill(0.);
  effect.Fill(0.);
  fElementError.Fill(0);

  for (cliter=0;cliter<nelmesh;cliter++)  fElementError[cliter] = 0.;

  //Creates an uniformly refined mesh and evaluates the error
  for (cliter = 0; cliter<ncl; cliter++){
    //Análise dos Clones
    //    if(cliter == 24 && gPrintLevel ==1) gPrintLevel =2;
    fFineCloneMesh [cliter] = fCloneMesh[cliter]->UniformlyRefineMesh();
    {
      ofstream out("output.txt");
      fCloneMesh[cliter]->Print(out);
      out.close();
    }

    fCloneMesh[cliter]->MeshError(fFineCloneMesh[cliter],fElementError,f,truervec);  
    //    fCloneMesh[cliter]->MeshError(fCloneMesh[cliter],fElementError,f,truervec);  
  }

  //Ordena o vetor de erros
  int nelem = fElementError.NElements();
  TPZVec<int> perm(nelem,0);
  for(i=0; i<nelem; i++) {
    perm[i] = i;
    ervec[i]=fElementError[i];
  }
  Sort(fElementError,perm);
  
  //  REAL totalerror = 0.;
  //  REAL totaltruerror = 0.;
  //somatório dos componentes do vetor de erro
  for(i=0; i<nelem; i++) error += fElementError[i];

  REAL ninetyfivepercent,auxerror = 0.;
  for(i=0;i<nelem;i++){
    auxerror += fElementError[perm[i]];
    if (auxerror >= 0.65*error){
      ninetyfivepercent = fElementError[perm[i]];
      break;
    }
  }

  if(f) {
    for(i=0; i<nelem; i++){
      truerror += truervec[i];
    }
  }
  
  //inicializa effect com o tamanho de trueeerror
  effect.Resize(truervec.NElements());
  effect.Fill(0.);
  if(f) {
    for(i=0; i<nelem; i++) {
      if(truervec[i] >= 1.e-4*truerror && truervec[i] >= 5e-20 ) {
	effect[i] = ervec[i]/truervec[i];
      }
      else {
	effect[i]=0.;
	truervec[i]=0.;
      }
    }
  }
  //  int nstate = fCloneMesh[0]->MaterialVec()[0]->NStateVariables();
  
  TPZStack <TPZGeoEl*> gelstack;
  TPZStack <int> porder;
    
  //Analyse clone element error and, if necessary, analyse element and changes its refinement pattern
  for (i=0;i<fCloneMesh.NElements();i++){
    fCloneMesh[i]->ApplyRefPattern(ninetyfivepercent,fElementError,fFineCloneMesh[i],gelstack,porder);
  }
  
/*   int igeo,ngeoel = gelstack.NElements(); */
/*   for (igeo =0; igeo<ngeoel; igeo++){ */
/*     gelstack[igeo]->Print(); */
/*   } */

  TPZCompMesh * adapted =   CreateCompMesh(fReference,gelstack,porder);
  return adapted;
}


void TPZAdaptMesh::GetReferenceElements(){
  if (!fReference){
    cout << "TPZAdaptMesh::Error:\n computational mesh must be initialized to call GetReferenceElements!\n";
    return;
  }
  fReference->GetRefPatches(fGeoRef);

/*   int i; */
/*   int nel = fGeoRef.NElements(); */
/*   for (i=0;i<nel; i++){ */
/*     fGeoRef[i]->Print(cout); */
/*   } */

}

void TPZAdaptMesh::BuildReferencePatch(){

  TPZGeoMesh *gmesh = fReference->Reference();
  gmesh->ResetReference();
  TPZCompMesh *tmpcmesh = new TPZCompMesh (gmesh);
  int i,j;
  for (i=0;i<fGeoRef.NElements();i++){
    fGeoRef[i]->CreateCompEl(*tmpcmesh,i);
  } 
  tmpcmesh->CleanUpUnconnectedNodes();
  TPZStack <int> patchelindex;
  TPZStack <TPZGeoEl *> toclonegel;
  TPZVec<int> n2elgraph;
  TPZVec<int> n2elgraphid;
  TPZStack<int> elgraph;
  TPZVec<int> elgraphindex;
  tmpcmesh->GetNodeToElGraph(n2elgraph,n2elgraphid,elgraph,elgraphindex);
  int clnel = tmpcmesh->NElements();
  fPatchIndex.Push(0);
  for (i=0; i<clnel; i++){
    tmpcmesh->GetElementPatch(n2elgraph,n2elgraphid,elgraph,elgraphindex,i,patchelindex);
    for (j=0; j<patchelindex.NElements(); j++){
      TPZGeoEl *gel = tmpcmesh->ElementVec()[patchelindex[j]]->Reference();
      //      int count = 0;
      if(gel) fPatch.Push(gel);
    }
    int sum = fPatch.NElements();
    fPatchIndex.Push(sum);
  }
  gmesh->ResetReference();
  delete tmpcmesh;
  fReference->LoadReferences();
}

void TPZAdaptMesh::CreateClones(){
  fReference->Reference()->ResetReference();
  fReference->LoadReferences();
  TPZGeoMesh *geomesh = fReference->Reference();
  
  TPZStack<TPZGeoEl*> patch;
  
  int clid,elid;
  for (clid=0; clid<fPatchIndex.NElements()-1;clid++){
    TPZGeoCloneMesh *geoclone = new TPZGeoCloneMesh(geomesh);
    TPZStack<TPZGeoEl*> patch;
    for (elid=fPatchIndex[clid];elid<fPatchIndex[clid+1];elid++){
      patch.Push(fPatch[elid]);
    }
    geoclone->SetElements(patch,fGeoRef[clid]);
    TPZVec<TPZGeoEl *> sub;
    //    int ngcel = geoclone->ElementVec().NElements();
    int printing = 0;
    if(printing) {
      ofstream out("test.txt",ios::app);
      geoclone->Print(out);
    }
    TPZCompCloneMesh *clonecompmesh = new TPZCompCloneMesh(geoclone,fReference);
    clonecompmesh->AutoBuild();
    fCloneMesh.Push(clonecompmesh);    
  }
}


void TPZAdaptMesh::Sort(TPZVec<REAL> &vec, TPZVec<int> &perm) {
  int i,j;
  int imin = 0;
  int imax = vec.NElements();
  for(i=imin; i<imax; i++) {
    for(j=i+1; j<imax; j++) {
      if(vec[perm[i]] < vec[perm[j]]) {
	int kp = perm[i];
	perm[i] = perm[j];
	perm[j] = kp;
      }
    }
  }
}

void TPZAdaptMesh::HeapSort(TPZVec<REAL> &sol, TPZVec<int> &perm){

  int nelem = perm.NElements();
  int i,j;
  for(i=0; i<nelem; i++) perm[i] = i;
  
  if(nelem == 1) return;
  int l, ir,ind;
  REAL q;
  l= nelem/2;
  ir = nelem-1;
  while(l>0 && ir>0) {
    if(l> 0) {
      l--;
      ind = perm[l];
      q=sol[ind];
    } else {
      ind = perm[ir];
      q = sol[ind];
      perm[ir] = perm[0];
      ir--;
    }
    i=l;
    j=l+l+1;
    while(j<=ir) {
      if(j<ir && sol[perm[j]] < sol[perm[j+1]]) j++;
      if(q < sol[perm[j]]) {
	perm[i] = perm[j];
	i=j;
	j= i+i+1;
      } else {
	break;
      }
    }
    perm[i] = ind;
  }
}

TPZCompMesh *TPZAdaptMesh::CreateCompMesh (TPZCompMesh *mesh,                                          //malha a refinar
					     TPZVec<TPZGeoEl *> &gelstack,   //
					     TPZVec<int> &porders) {

        //Cria um ponteiro para a malha geométrica de mesh
  TPZGeoMesh *gmesh = mesh->Reference();
  if(!gmesh) {
    cout << "TPZAdaptMesh::CreateCompMesh encountered no geometric mesh\n";
    return 0;
  }

        //Reseta as referências do ponteiro para a malha geométrica criada
        //e cria uma nova malha computacional baseada nesta malha geométrica
  gmesh->ResetReference();
  TPZCompMesh *cmesh = new TPZCompMesh(gmesh);
  int nmat = mesh->MaterialVec().NElements();
  int m;

        //Cria um clone do vetor de materiais da malha mesh
  for(m=0; m<nmat; m++) {
    TPZMaterial *mat = mesh->MaterialVec()[m];
    if(!mat) continue;
    mat->Clone(cmesh->MaterialVec());
  }

        //Idenifica o vetor de elementos computacionais de mesh
  //  TPZAdmChunkVector<TPZCompEl *> &elementvec = mesh->ElementVec();

  int el,nelem = gelstack.NElements();
  //  cmesh->SetName("Antes PRefine");
  //  cmesh->Print(cout);
  for(el=0; el<nelem; el++) {

                //identifica os elementos geométricos passados em gelstack
    TPZGeoEl *gel = gelstack[el];
    if(!gel) {
      cout << "TPZAdaptMesh::CreateCompMesh encountered an null element\n";
      continue;
    }
    int celindex;

                //Cria um TPZIntel baseado no gel identificado
    TPZInterpolatedElement *csint;
    csint = dynamic_cast<TPZInterpolatedElement *> (gel->CreateCompEl(*cmesh,celindex));
    if(!csint) continue;

                //Refina em p o elemento criado
    //	cmesh->SetName("depois criar elemento");
    //	cmesh->Print(cout);
     
    csint->PRefine(porders[el]);
    //	cmesh->SetName("depois prefine no elemento");
    //	cmesh->Print(cout);
  }
        //Mais einh!!
  //	cmesh->SetName("Antes Adjust");
  //	cmesh->Print(cout);
  cmesh->AdjustBoundaryElements();
  //  cmesh->SetName("Depois");
  //  cmesh->Print(cout);
  return cmesh;

}

void TPZAdaptMesh::RemoveCloneBC(TPZCompMesh *mesh)
{
  int nelem = mesh->NElements();
  int iel;
  for(iel=0; iel<nelem; iel++) {
    TPZCompEl *cel = mesh->ElementVec()[iel];
    if(!cel) continue;
    int matid = cel->Material()->Id();
    if(matid == -1000) delete cel;
  }
}

void TPZAdaptMesh::DeleteElements(TPZCompMesh *mesh)
{
  int nelem = mesh->NElements();
  int iel;
  for(iel=0; iel<nelem; iel++) {
    TPZCompEl *cel = mesh->ElementVec()[iel];
    if(!cel) continue;
    TPZInterpolatedElement *cint = dynamic_cast<TPZInterpolatedElement *> (cel);
    if(!cint) continue;
    while(cint->HasDependency()) {
      TPZInterpolatedElement *large = LargeElement(cint);
      TPZInterpolatedElement *nextlarge = LargeElement(large);
      while(nextlarge != large) {
	large = nextlarge;
	nextlarge = LargeElement(large);
      }
      large->RemoveSideRestraintsII(TPZInterpolatedElement::EDelete);
      delete large;
    }
    cint->RemoveSideRestraintsII(TPZInterpolatedElement::EDelete);
    delete cint;
  }
}

TPZInterpolatedElement * TPZAdaptMesh::LargeElement(TPZInterpolatedElement *cint)
{
  int nc = cint->NConnects();
  int side;
  TPZInterpolatedElement *result = cint;
  for(side=0; side<nc; side++) {
    if(cint->Connect(side).HasDependency()) {
      TPZCompElSide cintside(cint,side);
      TPZCompElSide large = cintside.LowerLevelElementList(1);
      if(!large.Exists()) {
	cout << "TPZAdaptMesh::DeleteElements I dont understand\n";
	large = cintside.LowerLevelElementList(1);
				return cint;
      }
      result = dynamic_cast<TPZInterpolatedElement *> (large.Element());
      break;
    }
  }
  return result;
}
