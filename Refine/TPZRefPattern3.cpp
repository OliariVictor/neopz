// /**
//  * @file
//  * @brief Contains the implementation of the TPZRefPattern3 methods. 
//  */
// /* Generated by Together */

 #include "TPZRefPattern3.h"

#include "TPZRefPattern.h"

// #include "pztrnsform.h"
// #include "pzreal.h"
// #include "pzgmesh.h"
// #include "pzquad.h"
// #include "pzvec.h"
// #include "pzeltype.h"
// #include "tpzpermutation.h"
// #include "pzgeoel.h"
// #include "pzlog.h"
// #include "TPZVTKGeoMesh.h"

// #include <set>

// #include <fstream>
// #include <sstream>

//iniatilizing static variables
/// Id for identifying a non initialized pattern
const int TPZRefPattern3::fNonInitializedId = -50;
/// Name for identifying a non initialized pattern
const std::string TPZRefPattern3::fNonInitializedName = "noname";
/// Map of all valid permutations
std::map<MElementType, std::list<TPZRefPattern3::TPZRefPattern3Permute> > TPZRefPattern3::fPermutations;

 #ifdef LOG4CXX
 static LoggerPtr logger(Logger::getLogger("pz.mesh.tpzrefpattern3"));
 #endif

int TPZRefPattern3::ClassId() const {
    return Hash("TPZRefPattern3");
}

TPZRefPattern3::TPZRefPattern3() : fId(fNonInitializedId), fName(fNonInitializedName),
fSideRefPattern(0), fPermutedRefPatterns(0), fNSubEl(0){

}

TPZRefPattern3::TPZRefPattern3(TPZRefPattern &oldRef){
    fRefPatternMesh = oldRef.fRefPatternMesh;
    TPZGeoEl* geoEl = fRefPatternMesh.Element(0);
    MElementType type = geoEl->Type();

    const uint nSides = geoEl->NSides();
    //filling fFatherSideInfo
    fFatherSideInfo.Resize(nSides);
    for(uint iSide = 0; iSide < nSides; iSide++){
        //first member of the tuple to be stored in fFatherSideInfo[iSide]
        TPZManVector<int,4> sideNodes;
        oldRef.SideNodes(iSide, sideNodes);

        const uint nSideSubEls = oldRef.NSideSubElements(iSide);
        //second member of the tuple to be stored in fFatherSideInfo[iSide]
        TPZStack<TPZGeoElSide> sideSonsStack;
        for(uint iSubEl = 0; iSubEl < oldRef.NSubElements(); iSubEl++){
            TPZGeoEl *subEl = fRefPatternMesh.Element(iSubEl+1);
            for(uint iSubElSide = 0; iSubElSide < subEl->NSides(); iSubElSide ++){
                int fatherSide = oldRef.FatherSide(iSubElSide,iSubEl);
                if(fatherSide == iSide){
                    TPZGeoElSide geoElSideCandidate(subEl,iSubElSide);
                    bool isInList = false;
                    for(int iGelSide = 0; iGelSide < sideSonsStack.size(); iGelSide++){
                        if(isInList == true) break;
                        TPZGeoElSide neighbour = geoElSideCandidate.Neighbour();
                        while(neighbour.Element() && neighbour.Element()->Id() != geoElSideCandidate.Element()->Id()){
                            if(neighbour == sideSonsStack[iGelSide]){
                                isInList = true;
                                break;
                            }
                            neighbour = neighbour.Neighbour();
                        }
                    }
                    if(!isInList)   sideSonsStack.push_back(geoElSideCandidate);
                }
            }
        }
        if(sideSonsStack.size() != nSideSubEls) {
            DebugStop();
        }
        TPZManVector<TPZGeoElSide,27> sideSons(nSideSubEls);
        for(uint iSubEl = 0; iSubEl < nSideSubEls; iSubEl++){
            sideSons[iSubEl] = sideSonsStack[iSubEl];
        }

        //third member of the tuple to be stored in fFatherSideInfo[iSide]
        int64_t midSideIndex = -1;
        geoEl->MidSideNodeIndex(iSide,midSideIndex);
        fFatherSideInfo[iSide] = SPZFatherSideInfo(sideNodes,sideSons,midSideIndex);
    }

    const uint nSubEls = oldRef.NSubElements();
    //filling fSubElSideInfo
    fSubElSideInfo.Resize(nSubEls);
    for(uint iSubEl = 0; iSubEl < nSubEls; iSubEl++){
        TPZGeoEl *subEl = oldRef.Element(iSubEl + 1);//Element 0 is the father element
        const uint nSubElSides = subEl->NSides();
        fSubElSideInfo[iSubEl].Resize(nSubElSides);
        for(uint iSubElSides = 0; iSubElSides < nSubElSides; iSubElSides++){
            const int fatherSide = oldRef.FatherSide(iSubElSides, iSubEl);
            auto transform = oldRef.Transform(iSubElSides,iSubEl);
            fSubElSideInfo[iSubEl][iSubElSides] = std::make_pair(fatherSide, transform);
        }
    }
    //other attributes
    fName = oldRef.Name();
    fId = oldRef.Id();
    fSideRefPattern = oldRef.fSideRefPattern;
    fPermutedRefPatterns = oldRef.fPermutedRefPatterns;
    fNSubEl = oldRef.fNSubEl;
}

TPZRefPattern3::TPZRefPattern3(TPZGeoMesh &gmesh){
    fRefPatternMesh = gmesh;
    CreateRefinementPattern();
}

TPZRefPattern3::TPZRefPattern3(std::istream &file) : fSideRefPattern(0), fId(nonInitializedId), fName("noname")
{
    ReadAndCreateRefinementPattern(file);
}

TPZRefPattern3::TPZRefPattern3(const std::string &file ) : fSideRefPattern(0), fId(nonInitializedId), fName("noname")
{
    std::ifstream input(file.c_str());
    ReadAndCreateRefinementPattern(input);

    /*
     BuildName();
     ofstream output(file.c_str());
     ExportPattern(output);
     */
}

 void TPZRefPattern3::PrintMore(std::ostream &out) const
 {
    out << "TPZRefPattern3::PrintMore\n\n";
 	int iSide,iSubEl;
// 	int nsubs = NSubElements();
 	int nSubs = fSubElSideInfo.size();
 	out << "Refinement Pattern named " << fName << endl;
 	for(iSubEl=0;iSubEl<nSubs;iSubEl++){
 		int nSides = fSubElSideInfo[iSubEl].size();
 		for(iSide=0;iSide<nSides;iSide++){
 		    auto transform = fSubElSideInfo[iSubEl][iSide].second;
 		    out << "sub/side = " << iSubEl + 1 << "/" << iSide << "  FatherSide = " << fSubElSideInfo[iSubEl][iSide].first  << endl;
 		    out << "Transform = " << std::endl;
 		    transform.Mult().Print("Transformation T: ", out);
 		    transform.Sum().Print("Translation b: ", out);
 		}
 	}
 }

TPZRefPattern3::TPZRefPattern3(const TPZRefPattern3 &copy, const TPZPermutation &permute) : fRefPatternMesh(copy.fRefPatternMesh), fId(nonInitializedId), fName("noname")
{
    fNSubEl = copy.fNSubEl;
    this->PermuteMesh(permute);

    SetRefPatternMeshToMasterDomain();

    ComputeTransforms();/**calcula as transformacoes entre filhos e pai*/
    ComputePartition();/**efetua a particao do elemento pai de acordo com os lados dos sub-elementos*/
    GenerateSideRefPatterns();
}


int TPZRefPattern3::NSubElements() const
{
    #ifdef PZDEBUG
    if(fNSubEl != fSubElSideInfo.size()){
        PZError << "The refinement pattern is not in a consistent state."<<std::endl;
        PZError << "It has two different values of number of sub-elements, namely: "<<std::endl;
        PZError << fNSubEl<<" and "<<fSubElSideInfo.size()<<std::endl;
        PZError << "Aborting..."<<std::endl;
        DebugStop();
    }
    #endif
    return fNSubEl;
}

int TPZRefPattern3::FatherSide(int side, int sub) const
{
    #ifdef PZDEBUG
    if(sub < 0 || sub >= NSubElements()){
        PZError << "TPZRefPattern3::FatherSide: wrong parameter 'sub'."<<std::endl;
        PZError << "The current ref pattern has "<<NSubElements()<<" and the parameter 'sub' was "<<sub<<std::endl;
        DebugStop();

    }
    if(side < 0 || side >= fRefPatternMesh.ElementVec()[sub+1]->NSides()){
        PZError << "TPZRefPattern3::FatherSide: wrong parameter 'side'."<<std::endl;
        PZError << "The current sub element has "<<fRefPatternMesh.ElementVec()[sub+1]->NSides()<<" sides ";
        PZError << "and the parameter 'side' was "<<side<<std::endl;
        DebugStop();
    }
    #endif
    return fSubElSideInfo[sub][side].first;
}
int TPZRefPattern3::NSideSubGeoElSides(int fatherSide) const{
    #ifdef PZDEBUG
    if(!CheckSideConsistency(fatherSide)) {
        DebugStop();
    }
    #endif

    return fFatherSideInfo[fatherSide].fSideSons.size();
}

void TPZRefPattern3::SideSubGeoElSide(int fatherSide, int subElPos, TPZGeoElSide & subGeoEl) const{
    #ifdef PZDEBUG
    if(!CheckSideAndSubElConsistency(fatherSide,subElPos)) {
        DebugStop();
    }
    #endif
    subGeoEl = fFatherSideInfo[fatherSide].fSideSons[subElPos];
}

 TPZTransform<> TPZRefPattern3::Transform(int subElSide, int sub)
 {
    #ifdef PZDEBUG
     if(sub<0 || sub >= NSubElements()) {
         DebugStop();
     }
     TPZGeoEl *subEl = Element(sub+1);
     if(subElSide<0 || subElSide >= subEl->NSides()){
         DebugStop();
     }
    #endif
    return fSubElSideInfo[sub][subElSide].second;
 }

void TPZRefPattern3::SideNodes(int fatherSide, TPZVec<int> &vecNodes){
#ifdef PZDEBUG
    if(!CheckSideConsistency(fatherSide)) {
        DebugStop();
    }
#endif
    vecNodes = fFatherSideInfo[fatherSide].fSideNodes;
}

int TPZRefPattern3::NSideNodes(int fatherSide){
    #ifdef PZDEBUG
    if(!CheckSideConsistency(fatherSide)) {
        DebugStop();
    }
    #endif
    return fFatherSideInfo[fatherSide].fSideNodes.size();
}

int TPZRefPattern3::NNodes() const{
    return fRefPatternMesh.NNodes();
}

bool TPZRefPattern3::IsFatherNeighbour(TPZGeoElSide fatherSide,TPZGeoEl *son) const{
    const int side = fatherSide.Side();

    for (auto &geoElSide : fFatherSideInfo[side].fSideSons ) {
        if(geoElSide.Element() == son) return true;
    }
    return false;
}

TPZGeoEl *TPZRefPattern3::Element(int iel){
    int nel = NSubElements()+1;/*sub-elements and father el*/
    if(iel < 0 || iel >= nel){
        PZError <<  "TPZRefPattern::Element the element with the following id does not exist: " << iel << endl;
        DebugStop();
    }
    return ( fRefPatternMesh.ElementVec()[iel]  );
}

void TPZRefPattern3::InternalNodesIndexes(int side, TPZVec<TPZGeoElSideIndex> &nodeIndexes){
    #ifdef PZDEBUG
    if(!CheckSideConsistency(side)) {
        DebugStop();
    }
    #endif
    nodeIndexes.Resize(0);
    int count = 0;
    for(auto &subElSide : fFatherSideInfo[side].fSideSons){
        if(subElSide.Dimension() == 0){
            nodeIndexes.Resize(count + 1);
            nodeIndexes[count] = TPZGeoElSideIndex(subElSide);
            count++;
        }
    }
}

void TPZRefPattern3::InternalSidesIndexes(int side, TPZVec<TPZGeoElSideIndex> &sideIndexes){
    #ifdef PZDEBUG
    if(!CheckSideConsistency(side)) {
        DebugStop();
    }
    #endif
    const int nSubElSides = fFatherSideInfo[side].fSideSons.size();
    sideIndexes.Resize(nSubElSides);
    for(int iSub = 0; iSub < nSubElSides; iSub++){
        sideIndexes[iSub] = TPZGeoElSideIndex(fFatherSideInfo[side].fSideSons[iSub]);
    }
}

int TPZRefPattern3::SidePartition(TPZVec<TPZGeoElSide> &gelvec, int side)
{
    #ifdef PZDEBUG
    if(!CheckSideConsistency(side)) {
        DebugStop();
    }
    #endif
    gelvec = fFatherSideInfo[side].fSideSons;
    return gelvec.size();//numero de elementos da particao do lado
}
/****************************PROTECTED METHODS*************************************************************************/

void TPZRefPattern3::SetRefPatternMeshToMasterDomain(){
    TPZGeoEl * fatherEl = fRefPatternMesh.ElementVec()[0];


    const int dim = fatherEl->Dimension();
    const int nNodes = fRefPatternMesh.NodeVec().NElements();
    TPZManVector< TPZManVector<REAL,3> ,20> nodecoords_inQSI(nNodes,TPZManVector<REAL,3>(dim));
    TPZManVector<REAL,3> nodecoords_inX(3,0);
    TPZManVector<REAL,3> temp(3,0.);
    REAL Tol;
    ZeroTolerance(Tol);
    for(int n = 0; n < nNodes; n++)
    {
        fRefPatternMesh.NodeVec()[n].GetCoordinates(nodecoords_inX);
        fatherEl->ComputeXInverse(nodecoords_inX, nodecoords_inQSI[n],Tol);
    }

    TPZVec<REAL> coordQSIprojected(dim,0.);
    for(int n = 0; n < nNodes; n++)
    {
        //Let us guarantee that ComputeXInverse did not result in a point outside the reference element
        fatherEl->ProjectInParametricDomain(nodecoords_inQSI[n], coordQSIprojected);

        int c;
        for(c = 0; c < dim; c++)
        {
            double qsi = coordQSIprojected[c];
            fRefPatternMesh.NodeVec()[n].SetCoord(c,qsi);
        }
        for(; c < 3; c++)
        {
            fRefPatternMesh.NodeVec()[n].SetCoord(c,0.);
        }
    }
}

void TPZRefPattern3::GeneratePermutations(TPZGeoEl *fatherEl){
    if (!fatherEl)
    {
        PZError << "Error at " << __PRETTY_FUNCTION__ << " at line " << __LINE__ << " Father Element is NULL\n";
        return;
    }
    MElementType fatherEltype = fatherEl->Type();

    if(fPermutations.count(fatherEltype))
    {
        return;
    }
    TPZGeoMesh *fatherElMesh = fatherEl->Mesh();
    TPZGeoMesh gmesh;
    gmesh.NodeVec().Resize(fatherEl->NNodes());

    int in, nNodes = fatherEl->NNodes();
    for(in = 0; in < nNodes; in++)
    {
        gmesh.NodeVec()[in].Initialize(fatherElMesh->NodeVec()[fatherEl->NodeIndex(in)], gmesh);
    }
    TPZManVector<int64_t,8> nodes(nNodes), nodesPerm(nNodes);
    for(in = 0; in < nNodes; in++)
    {
        nodes[in]=in;
    }
    int matid = fatherEl->MaterialId();
    TPZPermutation permute(nNodes);
    TPZTransform<> trans(fatherEl->Dimension());
    TPZRefPattern3Permute refpermute;

    refpermute.fPermute = permute;
    refpermute.fTransform = trans;
    fPermutations[fatherEl->Type()].push_back(refpermute);
    permute++;
    TPZIntPoints *integ = fatherEl->CreateSideIntegrationRule(fatherEl->NSides()-1,3);
    TPZGeoEl *fatherElPermuted;
    while(!permute.IsFirst())
    {
        permute.Permute(nodes,nodesPerm);
        int64_t index;
        fatherElPermuted = gmesh.CreateGeoElement(fatherEl->Type(),nodesPerm,matid,index,0);
        int dim = fatherEl->Dimension();
        TPZManVector<REAL,3> point(dim,0.);
        REAL w;
        int nPoints = integ->NPoints();
        bool valid = true;
        for(int intPoint = 0; intPoint < nPoints; intPoint++)
        {
            integ->Point(intPoint,point,w);
            TPZFNMatrix<9> jac(dim,dim),jacinv(dim,dim),axes(3,3);
            REAL detjac,detjac2;
            fatherElPermuted->Jacobian(point,jac,axes,detjac,jacinv);
            fatherEl->Jacobian(point,jac,axes,detjac2,jacinv);
            if(fabs(fabs(detjac)-fabs(detjac2)) > 1.e-10)
            {
                valid = false;
                break;
            }
        }
        if(valid)
        {
            TPZRefPattern3Permute candidate;
            candidate.fPermute = permute;
//            candidate.fTransform = fatherEl->ComputeParamTrans(fatherElPermuted,fatherEl->NSides()-1,fatherEl->NSides()-1);
            candidate.fTransform = ComputeParamTransform(fatherEl,fatherElPermuted,fatherEl->NSides()-1,fatherEl->NSides()-1);
            fPermutations[fatherEl->Type()].push_back(candidate);
        }
        permute++;
    }

    delete integ;
}

void TPZRefPattern3::ComputeTransforms(){
    TPZGeoEl *fatherEl = fRefPatternMesh.Element(0);
    if(!fatherEl)
    {
        PZError << "TPZRefPattern3::ComputePartition Father not exists?!\n";
        DebugStop();
    }

    const int nSubEls = fRefPatternMesh.NElements() - 1;/**total filhos*/
    fSubElSideInfo.Resize(nSubEls);

    REAL Tol;
    ZeroTolerance(Tol);
    const int dim = fatherEl->Dimension();
    TPZManVector<REAL,3> massCenter(3,0.), xPoint(3,0.), fatherParam(dim,0.);
    for(int iSubEl=0; iSubEl < nSubEls; iSubEl++)
    {
        TPZGeoEl *son = Element(iSubEl+1);

        int nSides = son->NSides();
        fSubElSideInfo[iSubEl].Resize(nSides);
        for(int iSide = 0; iSide < nSides; iSide++)
        {
            TPZGeoElSide elside (son, iSide);

            son->CenterPoint(iSide,massCenter);/**percorre todos os lados do elemento filho*/
            son->X(massCenter,xPoint);//already in father's coordinates. but the dimension must be set up
            for(int iX = 0; iX < dim; iX++) fatherParam[iX] = xPoint[iX];
            const int fatherSide = fatherEl->WhichSide(fatherParam);/**lado do pai contendo o lado do filho*/
            fSubElSideInfo[iSubEl][iSide].first = fatherSide;
//            fSubElSideInfo[iSubEl][iSide].second = son->ComputeParamTrans(fatherEl,fatherSide,iSide);
            fSubElSideInfo[iSubEl][iSide].second = ComputeParamTransform(son,fatherEl,iSide,fatherSide);
        }
    }
}

void TPZRefPattern3::ComputePartition(){
    //this method will fill the fFatherSideInfo data structure
    TPZGeoEl *fatherEl = Element(0);/**elemento pai da divisco*/
    int nSides = fatherEl->NSides();

    fFatherSideInfo.Resize(nSides);
    for(int iSide = 0; iSide < nSides; iSide++){//for nodes it is simple

        TPZStack<TPZGeoElSide> sideSonsStack;
        TPZStack<int> cornerNodeStack;
        TPZStack<int> internalNodesStack;
        fFatherSideInfo[iSide].fMidSideIndex = -1;
        const int nSideNodes = fatherEl->NSideNodes(iSide);
        for(int iNode = 0; iNode < nSideNodes; iNode++){
            const int nodeIndex = fatherEl->SideNodeIndex(iSide,iNode);
            cornerNodeStack.push_back(nodeIndex);
        }
        for(uint iSubEl = 0; iSubEl < NSubElements(); iSubEl++){
            TPZGeoEl *subEl = Element(iSubEl+1);
            for(uint iSubElSide = 0; iSubElSide < subEl->NSides(); iSubElSide ++){
                int fatherSide = FatherSide(iSubElSide,iSubEl);
                if(fatherSide == iSide){
                    TPZGeoElSide geoElSideCandidate(subEl,iSubElSide);
                    bool isInList = false;
                    for(int iGelSide = 0; iGelSide < sideSonsStack.size(); iGelSide++){
                        if(isInList) break;
                        TPZGeoElSide neighbour = geoElSideCandidate.Neighbour();
                        while(neighbour.Element() && neighbour.Element()->Id() != geoElSideCandidate.Element()->Id()){
                            if(neighbour == sideSonsStack[iGelSide]){
                                isInList = true;
                                break;
                            }
                            neighbour = neighbour.Neighbour();
                        }
                    }
                    if(!isInList)   {
                        sideSonsStack.push_back(geoElSideCandidate);
                        if(subEl->SideDimension(iSubElSide) == 0){
                            const int nodeIndex = subEl->NodeIndex(iSubElSide);
                            bool isNodeInList = false;
                            const int nCornerNodes = cornerNodeStack.size();
                            const int nInternalNodes = internalNodesStack.size();
                            for(int iNode = 0; iNode < nInternalNodes; iNode++){
                                if(internalNodesStack[iNode] == nodeIndex) isNodeInList = true;
                            }
                            //the following garantees that for a 0D side its node is put correctly in internalNodesStack
                            for(int iNode = 0; iNode < nCornerNodes && fatherEl->SideDimension(iSide) > 0; iNode++){
                                if(cornerNodeStack[iNode] == nodeIndex) isNodeInList = true;
                            }
                            if(!isNodeInList){
                                internalNodesStack.push_back(nodeIndex);
                                if(fFatherSideInfo[iSide].fMidSideIndex != -1){
                                    DebugStop();
                                }
                                fFatherSideInfo[iSide].fMidSideIndex = nodeIndex;
                            }
                        }
                    }
                }
            }
        }
        fFatherSideInfo[iSide].fSideNodes.Resize(internalNodesStack.size());
        for(uint iNode = 0; iNode < internalNodesStack.size(); iNode++){
            fFatherSideInfo[iSide].fSideNodes[iNode] = internalNodesStack[iNode];
        }
        fFatherSideInfo[iSide].fSideSons.Resize(sideSonsStack.size());
        for(uint iSubEl = 0; iSubEl < sideSonsStack.size(); iSubEl++){
            fFatherSideInfo[iSide].fSideSons[iSubEl] = sideSonsStack[iSubEl];
        }
    }
}


/**
 * @brief Generate the refinement patterns associated with the sides of the father element
 */
void TPZRefPattern3::GenerateSideRefPatterns(){
    if(!fRefPatternMesh.ElementVec().NElements())
    {
        return;
    }

    TPZGeoEl *fatherEl = fRefPatternMesh.ElementVec()[0];

    int nsides = fatherEl->NSides();
    fSideRefPattern.Resize(nsides,-1);
    fSideRefPattern.Fill(-1.);

    int thisId = this->Id();
    fSideRefPattern[nsides-1] = thisId;

    int is;
    for(is=0; is<nsides-1; is++)
    {
        if(fatherEl->SideDimension(is) == 0)  continue;
        if(NSideSubGeoElSides(is) == 1) continue;

        TPZAutoPointer<TPZRefPattern3> sideref(new TPZRefPattern3());

        BuildSideMesh(is, sideref->fRefPatternMesh);

        sideref->SetRefPatternMeshToMasterDomain();

        sideref->fNSubEl = sideref->fRefPatternMesh.NElements()-1;
        sideref->ComputeTransforms();/**calcula as transformacoes entre filhos e pai*/
        sideref->ComputePartition();/**efetua a particao do elemento pai de acordo com os lados dos */

        TPZAutoPointer<TPZRefPattern> found = gRefDBase.FindRefPattern(sideref);

        if(!found.operator ->())
        {
            if(this->NameInitialized())
            {
                sideref->BuildName();
            }
            sideref->GenerateSideRefPatterns();
//            gRefDBase.InsertRefPattern(sideref);//@TODOFran: uncomment this.
            fSideRefPattern[is] = sideref->Id();
            sideref->InsertPermuted();
        }
        else
        {
            fSideRefPattern[is] = found->Id();
        }
    }
}

 int TPZRefPattern3::FindSubEl(TPZGeoEl *geoEl) const{
    const int nSubEls = NSubElements();
    for(int i = 0; i < nSubEls; i++){
        if(fRefPatternMesh.ElementVec()[i+1] == geoEl){
            return i;
        }
    }
    PZError<<"TPZRefPattern3::FindSubEl: ERROR"<<std::endl;
    PZError<<"This method should not be called with an element ";
    PZError<<"that is not a sub-element of this Refinement Pattern."<<std::endl;
    PZError<<"Aborting..."<<std::endl;
    DebugStop();
    return -1;
}

bool TPZRefPattern3::CheckSideConsistency(const int fatherSide) const{
    int nSides = fRefPatternMesh.ElementVec()[0]->NSides();
    if(fatherSide < 0 || fatherSide >= nSides)
    {
        PZError << "TPZRefPattern3::NSideSubElements: wrong argument\n";
        PZError << "father side = " << fatherSide << std::endl;
        return false;
    }
    return true;
}

bool TPZRefPattern3::CheckSideAndSubElConsistency(const int fatherSide, const int subEl) const{
    const int nSides = fRefPatternMesh.ElementVec()[0]->NSides();
    const int nSubGeoElSides = NSideSubGeoElSides(fatherSide);
    if(fatherSide < 0 || fatherSide >= nSides || subEl < 0 || subEl >= nSubGeoElSides)
    {
        PZError << "TPZRefPattern3::CheckSideAndSubElConsistency: wrong argument\n";
        PZError << "father side = " << fatherSide << std::endl;
        PZError << "subEl = " << subEl << std::endl;
        return false;
    }
    return true;
}

void TPZRefPattern3::BuildSideMesh(int side, TPZGeoMesh &SideRefPatternMesh)
{
    if(!fRefPatternMesh.ElementVec().NElements())
    {
        return;
    }
    TPZGeoEl *gel = fRefPatternMesh.ElementVec()[0];
    TPZStack<int> allsides;
    std::map<int,int> allsidenodes;
    int count =0;
    gel->LowerDimensionSides(side, allsides);
    allsides.Push(side);
    int s;
    for(s=0; s<allsides.NElements(); s++)
    {
        TPZStack<int> sidenodes;
        SideNodes(allsides[s],sidenodes);
        int t;
        for(t=0; t<sidenodes.NElements(); t++)
        {
            if(!allsidenodes.count(sidenodes[t])) allsidenodes[sidenodes[t]] = count++;
        }
    }
    SideRefPatternMesh.NodeVec().Resize(allsidenodes.size());
    std::map<int,int>::iterator it;
    for(it = allsidenodes.begin(); it!= allsidenodes.end(); it++)
    {
        int nodeorig = (*it).first;
        int nodedest = (*it).second;

        SideRefPatternMesh.NodeVec()[nodedest].Initialize(fRefPatternMesh.NodeVec()[nodeorig], SideRefPatternMesh);
        SideRefPatternMesh.NodeVec()[nodedest].SetNodeId(nodedest);
    }
    TPZStack<int64_t> nodeindices;
    nodeindices.Resize(gel->NSideNodes(side));
    int64_t in;
    for(in=0; in<nodeindices.NElements(); in++)
    {
        nodeindices[in] = allsidenodes[gel->SideNodeIndex(side,in)];
    }
    int matid = gel->MaterialId();
    int64_t index;
    TPZGeoEl *father = SideRefPatternMesh.CreateGeoElement(gel->Type(side),nodeindices,matid,index,1);
    int sidedim = father->Dimension();
    TPZStack<TPZGeoElSide> gelvec;
    SidePartition(gelvec, side);
    int nsub = gelvec.NElements();
    int subel;
    for(subel=0; subel<nsub; subel++)
    {
        if(gelvec[subel].Dimension() != sidedim)
        {
            continue;
        }
        nodeindices.Resize(gelvec[subel].NSideNodes());
        for(in=0; in<nodeindices.NElements(); in++)
        {
            nodeindices[in] = allsidenodes[gelvec[subel].SideNodeIndex(in)];
        }
        MElementType type = gelvec[subel].Element()->Type(gelvec[subel].Side());
        TPZGeoEl *subel = SideRefPatternMesh.CreateGeoElement(type,nodeindices,matid,index);
        subel->SetFather(father);
    }
    SideRefPatternMesh.BuildConnectivity();
}

void TPZRefPattern3::InsertPermuted()
{
    if(!fRefPatternMesh.ElementVec().NElements() || !fRefPatternMesh.ElementVec()[0])
    {
        return;
    }

    GenerateSideRefPatterns();
    TPZGeoEl * gel = fRefPatternMesh.ElementVec()[0];
    GeneratePermutations(gel);
    MElementType geltype = gel->Type();

    std::list<TPZRefPattern3Permute> &permlist = fPermutations[geltype];
    std::list<TPZRefPattern3Permute>::iterator it;
    fPermutedRefPatterns.resize(permlist.size());

    int64_t counter;
    for(it=permlist.begin(), counter=0; it != permlist.end(); it++,counter++)
    {
        TPZAutoPointer<TPZRefPattern3> refp(new TPZRefPattern3(*this,(*it).fPermute));
        TPZAutoPointer<TPZRefPattern3> found = nullptr;//gRefDBase.FindRefPattern(refp);//@TODOFran: uncomment this

#ifdef LOG4CXX
        if (logger->isDebugEnabled())
        {
            std::stringstream sout;
            sout << "Permutation " << it->fPermute;
            sout << "Created refpattenr refp ";
//            refp->Print(sout);//@TODOFran: uncomment this
            sout << "found refpattern ";
//            if(found) found->Print(sout);
//            else sout << "Pattern not found";////@TODOFran: uncomment this
            LOGPZ_DEBUG(logger,sout.str())
        }
#endif

        if(found)
        {
            fPermutedRefPatterns[counter] = found->Id();
        }
        else
        {
            if(this->NameInitialized())
            {
                refp->BuildName();
            }
//            gRefDBase.InsertRefPattern(refp);//@TODOFran: uncomment this
        }
    }
}

void TPZRefPattern3::BuildName()
{
    fName = TPZRefPatternTools::BuildRefPatternModelName(*this);
}

void TPZRefPattern3::PermuteMesh(const TPZPermutation &permute)
{
    int in;
    TPZGeoEl *father = this->fRefPatternMesh.ElementVec()[0];
    int nn = father->NNodes();
    TPZVec<int> nodes(nn), nodeperm(nn);
    for(in=0; in<nn; in++){
        nodes[in] = father->NodeIndex(in);
    }
    permute.Permute(nodes,nodeperm);
    for(in=0; in<nn; in++){
        father->SetNodeIndex(in, nodeperm[in]);
    }
    fRefPatternMesh.ResetConnectivities();
    fRefPatternMesh.BuildConnectivity();
}

void TPZRefPattern3::ReadAndCreateRefinementPattern(std::istream &pattern){
    int nNodes, nElems;
    pattern >> nNodes >> nElems;
    pattern >> fId >> fName;

    TPZVec<REAL> coord(3);
    fRefPatternMesh.NodeVec().Resize(nNodes);

    //criacao dos nohs
    for(int iNode = 0; iNode < nNodes; iNode++)
    {
        pattern >> coord[0];
        pattern >> coord[1];
        pattern >> coord[2];
        fRefPatternMesh.NodeVec()[iNode].Initialize(iNode,coord,fRefPatternMesh);
    }

    TPZGeoEl *father = 0;
    //criacao dos elementos geometricos que definem a particao
    int ntype, nummat, naorners, incid, el;
    for(el=0; el<nElems; el++)//os sub-elementos podem nao ter de uma mesma geometria
    {
        pattern >> ntype >> nummat;
        MElementType etype = (MElementType) ntype;
        naorners = MElementType_NNodes(etype);
        TPZVec<int64_t> nodes(naorners);
        for(incid = 0; incid < naorners; incid++)
        {
            pattern >> nodes[incid];
        }
        int64_t index;
        TPZGeoEl *subel = fRefPatternMesh.CreateGeoElement(etype, nodes, nummat, index, 0);
        if(el == 0)
        {
            father = subel;
            fRefPatternMesh.SetDimension(father->Dimension());
        }
        if(el > 0)
        {
            subel->SetFather(father);
            subel->SetFatherIndex(father->Index());
            father->SetSubElement(el-1,subel);
        }
    }
    CreateRefinementPattern();
}

void TPZRefPattern3::CreateRefinementPattern(){
    //ensure that the all the sub-elements are aware of their father
    //the first element is supposed to be the father element
    TPZGeoEl* fatherEl = fRefPatternMesh.Element(0);
    MElementType type = fatherEl->Type();
    fNSubEl = fRefPatternMesh.NElements() - 1;

    for(int iSubEl = 0; iSubEl < fNSubEl; iSubEl++){
        TPZGeoEl* subEl = fRefPatternMesh.Element(iSubEl + 1);
        subEl->SetFather(fatherEl);
        subEl->SetFatherIndex(0);
        fatherEl->SetSubElement(iSubEl, subEl);
    }

    SetRefPatternMeshToMasterDomain();
    fRefPatternMesh.BuildConnectivity();//conectividades entre sub-elementos
    GeneratePermutations(fatherEl);

    ComputeTransforms();//calcula as transformacoes entre filhos e pai
    ComputePartition();//efetua a particao do elemento pai de acordo com os lados dos sub-elementos

    BuildName();
    GenerateSideRefPatterns();
}

TPZTransform<> TPZRefPattern3::ComputeParamTransform(TPZGeoEl *geoElSon, TPZGeoEl *geoElFather, int sideSon, int sideFather){
    int dimFather = geoElFather->Dimension();
    int dimSideFather = geoElFather->SideDimension(sideFather);
    int dimSon = geoElSon->Dimension();
    int dimSideSon = geoElSon->SideDimension(sideSon);
    if(dimSideFather < dimSideSon){
        PZError << "\nTPZRefPattern3::ComputeParamTransform called with sides error\n";
        DebugStop();
    }

    /**There is no transformation defined to the element's nodes*/
    if(!geoElFather->SideDimension(sideFather)) return TPZTransform<>(0,0);

    REAL weight;
    TPZFNMatrix<9> jac(dimSon,dimSon),axes(3,3,0.);
    TPZFNMatrix<9> jacinv(dimSon,dimSon);
    TPZManVector<REAL,3> x(3,0.);
    TPZManVector<REAL,3> intpoint(dimSideSon,0.);
    int tam = (dimSideSon+1);
    TPZFNMatrix<16> hess(tam,tam,0.),grad0(tam,1,0.);
    TPZIntPoints *intrule = geoElSon->CreateSideIntegrationRule(sideSon,2);
    TPZManVector<int,3> order(dimSideSon,2);
    intrule->SetOrder(order);
    //integrating over the side of the son that is contained on the father's side
    int ij,ik,indp;
    REAL D2Edaikdaij,D2Edcidaij,D2Edci2;
    D2Edcidaij = 0.;
    D2Edci2 = 0.;
    for(ij=0;ij<dimSideSon;ij++){
        for(ik=ij;ik<dimSideSon;ik++){
            D2Edaikdaij = 0.;
            D2Edcidaij  = 0.;
            for(indp = 0; indp < intrule->NPoints(); ++indp){
                intrule->Point(indp,intpoint,weight);
                D2Edaikdaij += intpoint[ik]*intpoint[ij]*weight;
                if(ik==ij) D2Edcidaij += intpoint[ij]*weight;
                if(ij==0 && ik==0) D2Edci2 += weight;
            }
            hess(ij,ik) = 2.*D2Edaikdaij;
            hess(ik,ij) = hess(ij,ik);/**basta repassar sendo ik>ij*/
            if(ik==ij) {
                hess(ij,dimSideSon) = 2.*D2Edcidaij;
                hess(dimSideSon,ij) = hess(ij,dimSideSon);
            }
            if(ij==0 && ik==0) hess(dimSideSon,dimSideSon) = 2.*D2Edci2;
        }
    }// end of integral
    //defining transform from the son's side to the son's element
    TPZTransform<> transformSideToSon(dimSon);//identidade
    if(dimSideSon<dimSon) transformSideToSon = geoElSon->SideToSideTransform(sideSon,geoElSon->NSides()-1);
    TPZTransform<> fatelside = geoElFather->SideToSideTransform(geoElFather->NSides()-1,sideFather);
    TPZManVector<REAL,3> sidepoint(dimSon);
    int j;
    TPZFNMatrix<9> Amat(dimSideFather,dimSideSon,0.),Bmat(dimSideFather,1,0.);
    REAL Tol;
    ZeroTolerance(Tol);
    TPZVec<REAL> xiFather(dimFather,0.);
    TPZVec<REAL> xiFatherSide(dimSideFather,0.);
    for(int ifat=0;ifat<dimSideFather;ifat++){
        REAL DEdci = 0.;
        for(j=0;j<(dimSideSon+1);j++){
            REAL DEdaij = 0.;
            for(indp = 0; indp < intrule->NPoints(); ++indp){
                intrule->Point(indp,intpoint,weight);
                transformSideToSon.Apply(intpoint,sidepoint);//lado do filho para o seu interior: mestre
                geoElSon->X(sidepoint,x);//this is already on father's domain, but in 3 dimensions
                for(int iX = 0; iX < dimFather; iX++) xiFather[iX] = x[iX];
                fatelside.Apply(xiFather,xiFatherSide);
                if(j<dimSideSon) DEdaij += xiFatherSide[ifat]*intpoint[j]*weight;
                if(j==0) DEdci += xiFatherSide[ifat]*weight;
            }
            if(j<dimSideSon) grad0(j,0) = 2.*DEdaij;
            if(j==0) grad0(dimSideSon,0) = 2.*DEdci;
            if(!dimSideSon) grad0(0,0) = DEdci;
        }

        if(dimSideSon) hess.SolveDirect(grad0,ELU);
        for(int k=0;k<dimSideSon;k++) Amat(ifat,k) = grad0(k,0);
        Bmat(ifat,0) = grad0(dimSideSon,0);
    }

    delete intrule;
    TPZTransform<> t(dimSideFather,dimSideSon);
    t.SetMatrix(Amat,Bmat);
    return t;
}

int TPZRefPattern3::TPZRefPattern3Permute::ClassId() const {
 return Hash("TPZRefPattern3::TPZRefPattern3Permute");
}

void TPZRefPattern3::TPZRefPattern3Permute::Read(TPZStream& buf, void* context) { //ok
 fPermute.Read(buf, context);
 fTransform.Read(buf, context);
}

void TPZRefPattern3::TPZRefPattern3Permute::Write(TPZStream& buf, int withclassid) const { //ok
 fPermute.Write(buf, withclassid);
 fTransform.Write(buf, withclassid);
}
