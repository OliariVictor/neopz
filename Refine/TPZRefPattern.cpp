/* Generated by Together */

#include "TPZRefPattern.h"
//#include "pzgmesh.h"
#include "pztrnsform.h"
#include "pzreal.h"
#include "pzgmesh.h"
#include "pzquad.h"
#include "pzvec.h"
#include "pzeltype.h"
#include "tpzpermutation.h"
#include "pzgeoel.h"
#include <pzlog.h>

#include <fstream>
#include <sstream>

using namespace std;

#ifdef LOG4CXX
#include <log4cxx/propertyconfigurator.h>
using namespace log4cxx;
using namespace log4cxx::helpers;
#endif

std::map<MElementType, std::list<TPZRefPattern::TPZRefPatternPermute> > TPZRefPattern::fPermutations;

TPZRefPattern::TPZRefPattern() : fSideRefPattern(0), fId(-50) {
  fSideRefPattern.Resize(0);
  fName = "";
  fNSubEl = 0;
}

TPZRefPattern::TPZRefPattern(const TPZRefPattern &copy) : fSideRefPattern(copy.fSideRefPattern) , fId(-50) {
  fFileRefPatt = copy.fFileRefPatt;
  fName = copy.fName;
  fNSubEl = copy.fNSubEl;
  CopyMesh(copy.fMesh);
  fMesh.BuildConnectivity();
  ComputeTransforms();/**calcula as transforma�es entre filhos e pai*/
  ComputePartition();/**efetua a parti�o do elemento pai de acordo com os lados dos sub-elementos*/
  fName = GenericName();
}

    /**
     * Create a copy of the TPZRefPattern applying the permutation on the first element
     */
TPZRefPattern::TPZRefPattern (const TPZRefPattern &copy,const TPZPermutation &permute) : fSideRefPattern(copy.fSideRefPattern), fId(copy.fId) {
  fFileRefPatt = copy.fFileRefPatt;
  fNSubEl = copy.fNSubEl;
  CopyMesh(copy.fMesh,permute);
  fMesh.BuildConnectivity();
  ComputeTransforms();/**calcula as transforma�es entre filhos e pai*/
  ComputePartition();/**efetua a parti�o do elemento pai de acordo com os lados dos sub-elementos*/
  fName = GenericName();
}


TPZRefPattern::TPZRefPattern(std::string &file ) : fSideRefPattern(0), fId(-50) {
  fMesh.SetName("***RefinementPattern***");
  fFileRefPatt = file;/**arquivo contendo o padr� de refinamento*/
  ReadPattern2();/**l�o arquivo contendo o refinamento e cria a malha fMesh*/
  fMesh.BuildConnectivity();/**conectividades entre sub-elementos*/
  //  fMesh.Print(); /**Printing mesh info to check */
  ComputeTransforms();/**calcula as transforma�es entre filhos e pai*/
  ComputePartition();/**efetua a parti�o do elemento pai de acordo com os lados dos sub-elementos*/
}

TPZRefPattern::TPZRefPattern(std::ifstream &file ) : fSideRefPattern(0), fId(-50) {
  ReadPattern(file);
}


TPZRefPattern::TPZRefPattern(TPZGeoMesh &GMesh): fSideRefPattern(0), fId(-50) {
  fFileRefPatt = '\0';
  //fMesh = GMesh;
  CopyMesh(GMesh);
  fNSubEl = GMesh.NElements() - 1;
  fMesh.BuildConnectivity();/**conectividades entre sub-elementos*/
  ComputeTransforms();/**calcula as transforma�es entre filhos e pai*/
  ComputePartition();/**efetua a parti�o do elemento pai de acordo com os lados dos sub-elementos*/
  fName = GenericName();
}


void TPZRefPattern::Print(){

#ifdef LOG4CXX
  static LoggerPtr logger(Logger::getLogger("pz.mesh.refpattern"));
#endif

 // std::ostringstream buf;

  int nnewnodes=0;
  //cout << endl;
  std::cout << std::endl;
  std::cout << "=================" << std::endl;
  std::cout <<"PRINTING REFINEMENT PATTERN / Name : "<< fName <<  std::endl;
  std::cout << std::endl;
  int nnodes = fMesh.NNodes() ;
  std::cout << "=================" << std::endl;
  std::cout << "Number of nodes: " << nnodes << std::endl ;
  int nel = fMesh.NElements();
  std::cout << "Number of elements: " << nel << std::endl;
  //cout << "Refinement Type: " << fRefineType << endl;
  std::cout << "________________" << std::endl;
  std::cout << "Element Node Indexes" << std::endl;
  for (int i=0 ; i<nel ; i++){
    if (i==0){
      std::cout << "Master element nodes: "  ;
    }
    else{
      std::cout << "Element: " << i << " Nodes: " ;
    }
    
    for (int k=0 ; k<fMesh.ElementVec()[i]->NNodes() ; k++){
      std::cout << fMesh.ElementVec()[i]->NodeIndex(k) << "  ";
    }
    std::cout << std::endl;
  }
  std::cout << std::endl;
  std::cout << "________________" << std::endl;
  std::cout << "Number of new nodes per side ";
  for (int i=0 ; i<1 ; i++){
    //    cout << "Element: " << i << endl;
    for (int j=0 ; j<fMesh.ElementVec()[i]->NSides() ; j++){
      if (fMesh.ElementVec()[0]->SideDimension(j)==1){
        nnewnodes = NSideNodes(j);
        std::cout << j << ":" << nnewnodes << " ";
      }
    }
    std::cout << std::endl;
  }
  std::cout << std::endl;
  std::cout << "________________" << std::endl;
  std::cout << "Nodes coordinates " << std::endl;
  for (int i=0 ; i<nnodes ; i++){
    std::cout << "Node: " << i << " Coordinates:   " << fMesh.NodeVec()[i].Coord(0) << "   "  << fMesh.NodeVec()[i].Coord(1)  << "   "  << fMesh.NodeVec()[i].Coord(2) << std::endl;
  }
  std::cout << std::endl;
  std::cout << std::endl;
  std::cout << "=================" << std::endl;
  std::cout << "End of RefPattern Printing." << std::endl ;
  std::cout << "=================" << std::endl;
  std::cout << std::endl;
  std::cout << std::endl;
  std::cout << std::endl;
  //LOGPZ_DEBUG(logger, buf.str());
  

}


void TPZRefPattern::WritePattern(std::ofstream &filename){

  //std::ofstream filename;

  filename << fMesh.NNodes() << ' '  << fMesh.NElements() << ' ' << fId <<  std::endl ;
  filename << fName  << std::endl;
  //  filename << fName << "    Ref. Pattern Mesh" << std::endl;
  for (int i=0; i<fMesh.NNodes() ; i++){
    for (int k=0; k<3; k++){
	filename << fMesh.NodeVec()[i].Coord(k) << ' ';
    }
    filename << std::endl;
  }

  for (int i =0; i<fMesh.NElements(); i++){
    filename << fMesh.ElementVec()[i]->Type() << " " << fMesh.ElementVec()[i]->NCornerNodes() << " " ;
    for (int k=0; k<fMesh.ElementVec()[i]->NCornerNodes() ;k++){
      filename << fMesh.ElementVec()[i]->NodeIndex(k) << "  " ;
    }
    filename << std::endl;
  }
  int nperm = fPermutedRefPatterns.size();
  filename << nperm << ' ';
  int el;
  for(el=0; el<nperm; el++)
  {
    int ip;
    filename << fPermutedRefPatterns[el]->Id() << ' ';
  }
  filename << std::endl;
  TPZGeoEl *father = fMesh.ElementVec()[0];
  int nsides = father->NSides();
  int is;
  for(is=0; is<nsides; is++)
  {
    if(fSideRefPattern[is])
    {
      filename << fSideRefPattern[is]->Id() << ' ';
    } else
    {
      filename << -1 << ' ';
    }
  }
  filename << std::endl;
}

void TPZRefPattern::ReadPattern(std::ifstream &in)
{
  //ifstream in(fFileRefPatt.data());
  int nnodes,nelems,inode;
  in >> nnodes >> nelems >> fId;
  fNSubEl = nelems - 1;
  getline(in,fName);
  getline(in,fName);
  TPZManVector<REAL,3> coord(3);
  fMesh.NodeVec().Resize(nnodes);
  //criac� dos objetos nodais
  for(inode=0;inode<nnodes;inode++){
    in >> coord[0];
    in >> coord[1];
    in >> coord[2];
//    cout << coord << endl;
    fMesh.NodeVec()[inode].Initialize(inode,coord,fMesh);
  }
  TPZGeoEl *father;
  //criac� dos elementos geom�ricos que definem a partic�
  int ntype,nummat,ncorners,incid,el;
  for(el=0;el<nelems;el++) {/**os sub-elementos podem n� ter de uma mesma geometria*/
    in >> ntype >> ncorners;
    //ncorners = ntype;
    //if(ntype == 7) ncorners = 4;/**tetraedro*/

    MElementType etype = (MElementType) ntype;
    TPZVec<int> nodes(ncorners);
    for(incid=0;incid<ncorners;incid++){
      in >> nodes[incid];
    }
    int index;

    TPZGeoEl *subel = fMesh.CreateGeoElement(etype,nodes,nummat,index,-1);
    if(el==0){
      father = subel;
      subel->SetRefPattern(this);
      
    }
    if(el>0){
      father->SetSubElement(el-1,subel);
      subel->SetFather(father);
      subel->SetFather(father->Index());
    }
  }
  GeneratePermuted(father);
  fMesh.BuildConnectivity();/**conectividades entre sub-elementos*/
//  fMesh.Print(); /**Printing mesh info to check */
  ComputeTransforms();/**calcula as transforma�es entre filhos e pai*/
  ComputePartition();/**efetua a parti�o do elemento pai de acordo com os lados dos sub-elementos*/
}

void TPZRefPattern::ReadPattern(std::ifstream &in,std::vector<TPZRefPattern *> &collect){
  ReadPattern(in);
  int nperm;
  in >> nperm;
  this->fPermutedRefPatterns.resize(nperm);
  int el;
  for(el=0; el<nperm; el++)
  {
    int ip;
    in >> ip;
    fPermutedRefPatterns[el] = collect[ip];
  }
  TPZGeoEl *father = fMesh.ElementVec()[0];
  int nsides = father->NSides();
  fSideRefPattern.Resize(nsides,0);
  fSideRefPattern[nsides-1] = this;
  int is;
  for(is=0; is<nsides; is++)
  {
     int ip;
     in >> ip;
     if(ip >= 0)
     {
      fSideRefPattern[is] = collect[ip];
     } else 
     {
      fSideRefPattern[is] = 0;
     }
  }
}


void TPZRefPattern::ReadPattern2(){
  ifstream in(fFileRefPatt.data());
  int nnodes,nelems,inode,RefineType;
  in >> nnodes >> nelems;
  fNSubEl = nelems - 1;
  in >> RefineType;
  in >> fName;
  cout << "Reading pattern " << fName << " from file " << fFileRefPatt << std::endl;
  TPZVec<REAL> coord(3);
  fMesh.NodeVec().Resize(nnodes);
  //criac� dos objetos nodais
  for(inode=0;inode<nnodes;inode++){
    in >> coord[0];
    in >> coord[1];
    in >> coord[2];
//    cout << coord << endl;
    fMesh.NodeVec()[inode].Initialize(inode,coord,fMesh);
  }
  TPZGeoEl *father;
  //criac� dos elementos geom�ricos que definem a partic�
  int ntype,nummat,ncorners,incid,el;
  for(el=0;el<nelems;el++) {/**os sub-elementos podem n� ter de uma mesma geometria*/
    in >> ntype >> nummat;
    ncorners = ntype;
    if(ntype == 7) ncorners = 4;/**tetraedro*/
    TPZVec<int> nodes(ncorners);
    for(incid=0;incid<ncorners;incid++){
      in >> nodes[incid];
    }
    int index;
    MElementType etype;
    switch (ntype){
      case (1) :
        etype = EPoint;
        break;
      case (2) :
        etype = EOned;
        break;
      case(3):
        etype = ETriangle;
        break;
      case(4):
        etype = EQuadrilateral;
        break;
      case(5) :
        etype = EPiramide;
        break;
      case (6):
        etype = EPrisma;
        break;
      case(7):
        etype = ETetraedro;
        break;
      case (8):
        etype = ECube;
        break;
      default:
        std::cout << "ERROR : Undefined element type." << std::endl;
        exit(-1);
    }
   

    TPZGeoEl *subel = fMesh.CreateGeoElement(etype,nodes,nummat,index,-1);
    if(el==0){
      father = subel;
      subel->SetRefPattern(this);
      
    }
    if(el>0){
      father->SetSubElement(el-1,subel);
      subel->SetFather(father);
      subel->SetFather(father->Index());
    }
  }
}



/** Preenche-se a estrutura elemento/lado com aqueles objetos que tem
 *  transforma�o associada.Calcula-se a transforma�o entre o lado
 *  do sub-elemento e o lado do pai respectivo.
 */
void TPZRefPattern::ComputePartition(){
  int sizeinit = fTransforms.fInitSonSides.NElements()-1;/**igual ao nmero de filhos*/
  int init,iside;
  TPZGeoEl *fat = Element(0);/**elemento pai da divis�*/
  DefinitionOfSizePartition();/**calcula o tamanho da partic� dos lados do pai e inicializa fInitSide*/
  int sidestot = fFatherSides.fPartitionSubSide.NElements();
  /**inicializando o vetor de transformac�s*/
  for(int p=0;p<sidestot;p++) fFatherSides.fPartitionSubSide[p] = TPZGeoElSide();/**zera as entradas*/
  /**calcular a parti�o*/
  for(init=0;init<sizeinit;init++){/**percorre os filhos*/
    int initsideson = fTransforms.fInitSonSides[init];/**come� dos lados do filho*/
//    int lastsideson = fTransforms.fInitSonSides[init+1];/**comeco dos lados do pr�imo filho*/
//    int nsonsd = lastsideson-initsideson;/**comprimento da partic�*/
    TPZGeoEl *son = Element(init+1);/**filho*/
    int nsides = son->NSides();
    for(iside=0;iside<nsides;iside++){/**percorre-se os lados do filho*/
      int sdf = fTransforms.fFatherSide[initsideson+iside];/**lado do pai associado ao lado do sub-elemento*/
      if(sdf < fat->NNodes()) continue;/**cantos do pai n� entram na parti�o do lado*/
      int pos = 0;
      int sdf2 = sdf - fat->NNodes();/**fInitSide n� contempla os cantos, s�a partir de aresta para cima*/
      int initss = fFatherSides.fInitSide[sdf2];/**inicio da partic� do lado sdf do pai*/
      TPZGeoElSide sonside = fFatherSides.fPartitionSubSide[initss+pos];/**1o sub/lado da parti�o do lado do pai*/
      TPZGeoElSide empty(sonside);/**copia de sonside*/
      int sizept = fFatherSides.fInitSide[sdf2+1]-initss;/**comprimento da faixa do lado*/
      while(empty.Element() && pos < sizept){/**percorre-se a faixa do lado do pai*/
        pos++;/**procura-se o primeiro lugar desocupado na faixa do lado do pai*/
        empty = fFatherSides.fPartitionSubSide[initss+pos];
      }
      if(pos > sizept-1){/**a faixa toda esta ocupada com sub/lado n� nulo*/
        PZError << "TPZRefPattern::ComputePartition erro de dimensionamento\n";
        //exit(-1);
      }
      fFatherSides.fPartitionSubSide[initss+pos] = TPZGeoElSide(son,iside);
    }
  }
  /**conferindo a consist�cia da partic�*/
  for(int ss=0;ss<sidestot;ss++){
    if(!fFatherSides.fPartitionSubSide[ss].Element()){
      PZError << "TPZRefPattern::ComputePartition particao inconsistente";
    }
  }
  /**saida do arquivo de dados da particao*/
//  ofstream out("partition.out");
//  fFatherSides.Print(*fMesh,out);
  /**extraindo sub/side quando o side �repetido dentro da partic� do lado*/
  int init2;
  sizeinit = fFatherSides.fInitSide.NElements()-1;
  for(iside=0;iside<sizeinit;iside++){/**percorrendo fInitSide*/
    init = fFatherSides.fInitSide[iside];/**posic� inicial*/
    init2 = fFatherSides.fInitSide[iside+1];/**posic� final*/
    for(int sd=init;sd<init2;sd++){/**percorrendo a partic� do lado do pai*/
      TPZGeoElSide gs = fFatherSides.fPartitionSubSide[sd];/**1o sub/side do lado*/
      if(!gs.Element()) continue;
      for(int sd2=sd+1;sd2<init2;sd2++){
        TPZGeoElSide gs2 = fFatherSides.fPartitionSubSide[sd2];/**sub/side sub-seguinte do lado*/
        if(gs2.Element() && gs.Element()->NeighbourExists(gs.Side(),gs2)){
           fFatherSides.fPartitionSubSide[sd2] = TPZGeoElSide();/**apagando o sub/side com side repetido*/
        }
      }
    }
  }
  /**tirando os buracos da partic�*/
  TPZVec<int> newinit(fFatherSides.fInitSide.NElements());/**capacidade m�ima*/
  TPZVec<TPZGeoElSide> newpartition(fFatherSides.fPartitionSubSide.NElements());/**capacidade m�ima*/
  newinit[0] = 0;
  int count = 0;
  for(iside=0;iside<sizeinit;iside++){/**percorrendo fInitSide*/
    init = fFatherSides.fInitSide[iside];/**posic� inicial*/
    init2 = fFatherSides.fInitSide[iside+1];/**posic� final*/
    newinit[iside+1] = newinit[iside];
    for(int sd=init;sd<init2;sd++){/**percorrendo a partic� do lado do pai*/
      TPZGeoElSide gs = fFatherSides.fPartitionSubSide[sd];/**1o sub/side do lado*/
      if(!gs.Element()) continue;
      newinit[iside+1]++;
      newpartition[count++] = gs;
    }
  }
  fFatherSides.fInitSide = newinit;
  fFatherSides.fPartitionSubSide = newpartition;
  NSideSubElements();/**preenche fNSubSideFather com o nmero de elementos associados a cada lado do pai*/
//  out << "\n\n               *** Particao enxuta ***\n\n";
//  fFatherSides.Print(*fMesh,out);
//  out.flush();
//  out.close();
//  cout << "\nTPZRefPattern::ComputePartition arquivo contendo a particao dos lados do pai: partition.out\n";
//  ofstream out1("fathersides.out");
//  Print1(*fMesh,out1);
//  out1.flush();
//  out1.close();
//  cout << "\nTPZRefPattern::ComputePartition arquivo contendo o lado do pai associado ao lado do filho: fathersides.out\n";
}

using namespace std;

void TPZRefPattern::TPZPartitionFatherSides::Print(TPZGeoMesh &gmesh,std::ostream &out){
  out << "TPZRefPattern::TPZSideTransform::Print partic dos lados do pai pelos lados dos sub-elementos\n\n";
  int iss,iside;//,count=0;
  TPZGeoEl *father = gmesh.ElementVec()[0];/**elemento pai*/
  int nsfat = father->NSides();
  int nnod = father->NNodes();
  int ntot = nsfat-nnod;
  for(iside=0;iside<ntot;iside++){
    out << "\nLado do elemento pai = " << (iside+nnod) << endl;
    int initsideson = fInitSide[iside];
    int lastsideson = fInitSide[iside+1];
    for(iss=initsideson;iss<lastsideson;iss++){/**percorre-se os sub/lado da parti�o*/
      TPZGeoElSide subside = fPartitionSubSide[iss];
      if(!subside.Element()){
        cout <<  "ERRO : Elemento da partic� nulo\n ";
        continue;
      }
      out << "Sub id = " << subside.Element()->Id() << "  Lado do sub " << subside.Side()  << endl;
    }
    out << endl;  
  }  
}


void TPZRefPattern::Print1(TPZGeoMesh &gmesh,std::ostream &out){
  out << "TPZRefPattern::TPZSideTransform::Print lado do pai associados aos lados dos sub-elementos\n\n";
  int iside,isub;
//  int nnod = Element(0)->NNodes();
  int nsubs = NSubElements(); // so dava certo pq era igual ao uniforme
  out << "Refinement Pattern named " << fName << endl;
  for(isub=0;isub<nsubs;isub++){
    TPZGeoEl *sub = Element(isub+1);
    int nsides = sub->NSides();
    for(iside=0;iside<nsides;iside++){
      out << "sub/lado = " << isub << "/" << iside << "  Lado do pai = " << FatherSide(iside,isub)  << endl;
    }
  }
  this->fFatherSides.Print(gmesh,out);
  this->fTransforms.Print(gmesh,out);
}

/** Determina-se, para todos e cada um dos lados dos sub-elementos, o lado do pai no
 *  qual est�contido. Caso o lado do elemento �igual ao lado do pai asigna-se
 *  o valor -1. Neste caso n�existe depend�cia. 
 */
void TPZRefPattern::ComputeTransforms(){
/**calcula transformacoes entre lado de filho e lado de pai*/
//  int ind = 0;
//  int sizemesh = NSubElements()+1;
  TPZGeoEl *fath = Element(0);/**Elemento pai deve ser o primeiro elemento da lista*/
  if(!fath){
    PZError << "TPZRefPattern::ComputePartition Father not exists?!\n";
    exit(-1);
  }
  int isub,nsubs = NSubElements();/**total filhos*/
  /**preenchendo a estrutura TPZFatherSides*/
  int initside=0,cont=0,side,fatside;  
  TPZManVector<REAL,3> masscent(3,0.),xpoint(3,0.),fathparam(fath->Dimension(),0.);
  xpoint[0] = 0.;
  xpoint[1] = 0.;
  xpoint[2] = 0.; 
  fTransforms.fInitSonSides.Resize(nsubs+1);/** +1 para incluir a posi�o final de fSideFather*/
  int size = SizeOfSubsSides(nsubs);
  fTransforms.fFatherSide.Resize(size);/**vale -1 quando o lado n� �contido propriamente*/
  fTransforms.fSideTransform.Resize(size);
  for(isub=0;isub<nsubs;isub++){
    fTransforms.fInitSonSides[isub] = initside;
    TPZGeoEl *son = Element(isub+1);/**o pai n� sabe quem s� os filhos*/
    //cout << "Tipo de elemento :" << son->Type() << endl;
    int nsides = son->NSides();/**um dos elementos implementados no PZ*/
    //cout << "\n------------------------> ELemento de id = " << son->Id() << endl << endl;
    for(side=0;side<nsides;side++){/**cantos + arestas + faces, o interior n� �compartilhado*/
      TPZGeoElSide elside (son,side);
      //cout << "Tipo do elemento lado: " << elside.NSideNodes() << endl;
      son->CenterPoint(side,masscent);/**percorre todos os lados do elemento filho*/
      son->X(masscent,xpoint);
      fath->ComputeXInverse(xpoint,fathparam);
      //cout << "\nxpoint = " << xpoint[0] << " , " << xpoint[1] << " , " << xpoint[2] << endl << endl;
      fatside = fath->WhichSide(fathparam);/**lado do pai contendo o lado do filho*/
      fTransforms.fSideTransform[cont] = son->ComputeParamTrans(fath,fatside,side);
      //cout << "sub/side -> fath side: " << son->Id() << "/" << side << " -> " << fatside << endl; 
      //fTransforms.fSideTransform[cont].Mult().Print(" T ");
      //fTransforms.fSideTransform[cont].Sum().Print(" b ");
      fTransforms.fFatherSide[cont++] = fatside;
      initside++;
    }
  }
  fTransforms.fInitSonSides[isub] = initside;/**posi�o final em fSideFather*/
//  ofstream out("transformacoes.out");
//  fTransforms.Print(*fMesh,out);
//  out.flush();
//  out.close();
//  cout << "\nTPZRefPattern::ComputeTransforms lados do pai asssociados aos subs, fathersides.out\n";
}

void TPZRefPattern::TPZSideTransform::Print(TPZGeoMesh &gmesh,std::ostream &out){
  out << "TPZRefPattern::TPZSideTransform::Print transformacoes parametricas\n\n";
  int isub,iside,count=0;
  int nsubs = gmesh.ElementVec().NElements()-1;/**a malha cont� um elemento pai e filhos*/
  for(isub=0;isub<nsubs;isub++){
    int elid = gmesh.ElementVec()[isub+1]->Id();
    out << "\n>>>>>>>>>>>> Sub-element id = " << elid << " <<<<<<<<<<<< " << endl << endl;/**a informa�o da malha �est�ica*/
    int nsides = gmesh.ElementVec()[isub+1]->NSides();
    for(iside=0;iside<nsides;iside++){/**percorre-se os lados de cada filho*/
      out << "> Sub-element/side = " << elid << "/" << iside << "  Side of father = " << fFatherSide[count] << endl;
      fSideTransform[count].Mult().Print("Transformacao  T :",out);
      fSideTransform[count++].Sum().Print("Vetor b : ",out);
    }
    out << endl;  
  }
}

int TPZRefPattern::FatherSide(int side, int sub ){
  int nsides = fMesh.ElementVec()[sub+1]->NSides();
  int nsubs = NSubElements();
  if(side<0 || side>nsides ||  sub <0 ||  sub >nsubs){
    PZError << "TPZRefPattern::FatherSide arguments wrong argument\n";
    PZError << "side = " << side << " sub = " << sub;
    return -1;
  }
  int pos = fTransforms.fInitSonSides[sub];
  return ( fTransforms.fFatherSide[pos+side]  );
}

TPZTransform TPZRefPattern::Transform(int side, int sub){
  int nsides = Element(sub+1)->NSides();
  int nsubs = NSubElements();
  if(side<0 || side>nsides ||  sub <0 ||  sub >nsubs){
    PZError << "TPZRefPattern::Transform wrong arguments\n";
    PZError << "side = " << side << " sub = " << sub;
    return TPZTransform(0);
  }
  int pos = fTransforms.fInitSonSides[sub];
  return ( fTransforms.fSideTransform[pos+side]  );
}

void TPZRefPattern::SideNodes(int side, TPZVec<int> &vecnodes){
  /**side �um lado �do pai, �preciso achar todos os n� internos ao lado*/
  TPZGeoEl *father = Element(0);
  int nsdfat = father->NSides();
  int nnod = father->NNodes();
  if(side<0 || side>nsdfat){
    PZError << "TPZRefPattern::SideNodes wrong side, side = " << side << endl;
    vecnodes.Resize(0);
    return;
  }
  if (side < nnod){
    vecnodes.Resize(1);
    vecnodes[0] = Element(0)->NodeIndex(side);
    return ;
  }
  //Aparentemente a estrutura nao contempla os nos...
  side -= nnod;

#ifdef HUGE_DEBUG
if (gDebug == 2){
  cout << "************" << endl;
  cout << fFatherSides.fInitSide << endl;
  cout << "************" << endl;
  cout << fFatherSides.fNSubSideFather << endl;
  cout << "************" << endl;
  int nss = fFatherSides.fPartitionSubSide.NElements()-1;
  for (int i =0; i<nss ;i++){
    cout << "\nsubelement " << i << endl;
    cout << "side " << fFatherSides.fPartitionSubSide[i].Side() << endl;
    if (fFatherSides.fPartitionSubSide[i].Element())
      fFatherSides.fPartitionSubSide[i].Element()->Print(cout);
    else cout <<  "No associated element " << endl;
  }
}
#endif  
    
  int pos = fFatherSides.fInitSide[side];
  int pos2 = fFatherSides.fInitSide[side+1];
  vecnodes.Resize(pos2-pos);/**o nmero de n� no lado �menor que isto*/
  int count = 0;
  for(int par=pos;par<pos2;par++){/**intervalo do lado side*/
    TPZGeoElSide subs = fFatherSides.fPartitionSubSide[par];//[pos];
    if(!subs.Element()){
      PZError << "TPZRefPattern::NSideSubElements puncture in the partition\n";
      vecnodes.Resize(0);
      return;
    }
//    subs.Element()->Print(cout);
    int sd = subs.Side();
    if(sd < subs.Element()->NNodes()){
      TPZGeoEl *el = subs.Element();
      int node = el->NodeIndex(sd);
      //vecnodes[par-pos] = sd;/**cada n�aparece uma nica ves na partic� do lado*/
      vecnodes[par-pos] = node;
      count++;
    }
  }
  vecnodes.Resize(count);
//  cout << "VecNodes " << vecnodes << endl;
}

int TPZRefPattern::NNodes(){
  return ( fMesh.NodeVec().NElements() );
}

int TPZRefPattern::NSideNodes(int side){
  int nsdfat = Element(0)->NSides();
  if(side<0 || side>nsdfat){
    PZError << "TPZRefPattern::NSideNodes wrong side, side = " << side << endl;
    return -1;
  }
  TPZManVector<int,10> vec;
  SideNodes(side,vec);  
  return ( vec.NElements() );
}

int TPZRefPattern::NSubElements(){
  //return ( fMesh->ElementVec().NElements() - 1 );
  return fNSubEl;
}

void TPZRefPattern::SideSubElement(int sidein, int position, int & sub, int & sideout){
  if(sidein<0 || sidein>Element(0)->NSides()){
    PZError << "TPZRefPattern::SideSubElement null side, side = " << sidein << endl;  
  }
  //Para contemplar os lados de dimensao 0
/*  if (side < Element(0).NCornerNodes()){
    TPZGeoElSide thisside (Element(0),sidein);
    TPZGeoElSide neighbour = thisside.Neighbour();
    while (neighbour != thisside && neighbour.Exists()){
      sub.Push (neighbour.Element().Id() -1);
      sideout.Push (neighbour.Side());
      neighbour = neighbour.Neighbour();
    }
    return;
  }*/
  int insd = fFatherSides.fInitSide[sidein];
  int insd2 = fFatherSides.fInitSide[sidein+1];
/*
  for (int i = 0; i<fFatherSides.fPartitionSubSide.NElements(); i++){
    if (!fFatherSides.fPartitionSubSide[i].Exists()) cout << "error for element side " << i << endl;
    else cout << "Fathersides.PartitionSubSide " << fFatherSides.fPartitionSubSide[i].Element()->Id() -1
         << " side " << fFatherSides.fPartitionSubSide[i].Side() << endl;
  }
*/  
  if(position < 0 || position > (insd2-insd)){/**subs2-subsd �o nmero de sub's do lado*/
     PZError << "TPZRefPattern::SideSubElement wrong position, position = " << position << endl;
     sub = sideout = -1;
     return;
  }
  /**a ordem �determinada pela partic� dos lados do pai, �uma ordem fixa*/
  sub = fFatherSides.fPartitionSubSide[insd].Element()->Id()-1;/**id contemplado como filho*/
  sideout = fFatherSides.fPartitionSubSide[insd].Side();
}

void TPZRefPattern::NSideSubElements(){
  /**procura-se o nmero de sub-elementos da partic�, isto n� �igual ao nmero de
     elementos da partic�*/
  /**side �um lado do pai, �preciso achar o nmero de sub-elementos ligados a este lado*/
  TPZGeoEl *father = Element(0);
  int nsdfat = father->NSides();
  int nnod = father->NNodes();
  fFatherSides.fNSubSideFather.Resize(nsdfat); 
  for(int side=0;side<nsdfat;side++){/**percorre-se os lados do pai*/
    if(side<nnod){/**os cantos n� fazem parte da partic�*/
    /*
      TPZGeoElSide fat(Element(0),side),neigh;//elemento pai e seu vizinho
      if(!fat.Element()){
        PZError <<  "TPZRefPattern::NSideSubElements null father\n"; 
        exit(-1);//radicalizou
      }
      neigh = fat.Neighbour();
      //isso  um crime... pq conta aqui en no conta para os outros lados ??? int count = 1;//o pai est�contado
      int count = 0;
      while(neigh.Element() && neigh.Element()!=fat.Element()){
        neigh = neigh.Neighbour(); 
        count++;
      }
      if(!neigh.Element()){
        PZError <<  "TPZRefPattern::NSideSubElements null neighbour\n"; 
        exit(-1);///terrorismo, extremismo
      }   
      fFatherSides.fNSubSideFather[side] = count; */
      fFatherSides.fNSubSideFather[side] = 1;
      continue;
    }
    /**arestas, faces e interior: side > nnod*/
    /**tomo todos os elemento distintos da partic� do lado*/
    int sidepos = side-nnod;
    int pos = fFatherSides.fInitSide[sidepos];
    int pos2 = fFatherSides.fInitSide[sidepos+1];
    int size = pos2-pos;
    //    TPZVec<int> subs(size,0);/**tamanho m�imo*/
    //    for(p=pos;p<pos2;p++) subs[p-pos] = fFatherSides.fPartitionSubSide[p].Element()->Id();/**todos positivos > 0*/
    //    for(int i=0;i<size;i++) for(int j=i+1;j<size;j++) if(subs[j]==subs[i]) subs[j] = 0;/**anulando os repetidos*/
    //    int count = 0;
    //    for(int k=0;k<size;k++) if(subs[k]) count++;
    //    fFatherSides.fNSubSideFather[side] = count;
    fFatherSides.fNSubSideFather[side] = size;
  }
}

int TPZRefPattern::NSideSubElements(int side){
  if(side<0 || side>Element(0)->NSides()){
    PZError << "TPZRefPattern::NSideSubElement null side, side = " << side << endl;
    return -1;/**danou-se*/
  }
//  cout << "NSideSubElements " <<  fFatherSides.fNSubSideFather << endl;
  return (fFatherSides.fNSubSideFather[side]);
}


void TPZRefPattern::MeshPrint(){
  ofstream out("meshrefpatt.out");
  cout << "\nTPZRefPattern::Print imprime a malha do padrao de refinamento, arquivo de saida: meshrefpatt.out\n";
  fMesh.Print(out);
  out.flush();
  out.close();
}

/*
TPZGeoEl *TPZRefPattern::CreateGeoEl(int ntype, int mat,TPZVec<int> &nodes,TPZGeoMesh *gmesh, int el){
  int index = -1;
  el = (el == 0) ? ntype : 0;
  switch(ntype) {//tipo de elemento
    case 1:
      return gmesh->CreateGeoElement(EPoint,nodes,mat,index,el);
    case 2://unidimensional ; elg1d =
      return gmesh->CreateGeoElement(EOned,nodes,mat,index,el);
      //return new TPZGeoEl1d(nodes,mat,*gmesh);
      //return;
    case 3://tri�gulo ; elgt2d =
      return gmesh->CreateGeoElement(ETriangle,nodes,mat,index,el);
      //return new TPZGeoElT2d(nodes,mat,*gmesh);
      //return;
    case 4://quadril�ero ; elgq2d
      return gmesh->CreateGeoElement(EQuadrilateral,nodes,mat,index,el);
      //return;
    case 7://tetraedro ; elgt3d =
      return gmesh->CreateGeoElement(ETetraedro,nodes,mat,index,el);
      //return new TPZGeoElT3d(nodes,mat,*gmesh);
      //return;
    case 5://pir�ide ; elgpi3d =
      return gmesh->CreateGeoElement(EPiramide,nodes,mat,index,el);
      //return new TPZGeoElPi3d(nodes,mat,*gmesh);
      //return;
    case 6://prisma ; elgpi3d =
      return gmesh->CreateGeoElement(EPrisma,nodes,mat,index,el);
      //return new TPZGeoElPr3d(nodes,mat,*gmesh);
      //return;
    case 8://cubo ; elgc3d =
      return gmesh->CreateGeoElement(ECube,nodes,mat,index,el);
      //return new TPZGeoElC3d(nodes,mat,*gmesh);
      //return;
    default:
        PZError << "\nTPZRefPattern::CreateGeoEl -> Elemento nao conhecido "
                << ntype << endl << "Good Bye::Program Aborted" << endl;
        exit(-1);
  }
  PZError <<  "\nTPZRefPattern::CreateGeoEl ntype error, ntype = " << ntype << endl;
  PZError << "\nAborted program\n";
  exit(-1);//acabou a festa
  return 0;
}
*/

int TPZRefPattern::SizeOfSubsSides(int ison){/**ison �o nmero do sub-elemento*/
  int nsubs = NSubElements();
  if(ison==nsubs) ison--;
  if(ison < 0 || ison > nsubs-1){
    PZError <<  "TPZRefPattern::SizeOfSubsSides filho nao existe, filho = " << ison << endl;
  }
  int count = 0,isub;
  for(isub=0;isub<nsubs;isub++){    
    count += Element(isub+1)->NSides();
    if(isub == ison) return count;
  }
  return 0;
}

int TPZRefPattern::IsFatherNeighbour(TPZGeoElSide fathside,TPZGeoEl *son){
  /**se elementos filho e pai tem um lado em comum eles compartilham a vizinhan�*/
  TPZGeoElSide neighbour = fathside.Neighbour();
  while(neighbour.Element() && neighbour.Element()->Id() != fathside.Element()->Id()){
    if(neighbour.Element()->Id() == son->Id()) return 1;/**elementos pai e filho s� vizinhos*/
    neighbour = neighbour.Neighbour();/**percorre-se a vizinhan� do lado do pai*/
  }
  return 0;//**se n� �vizinho ent� nenhum sub-elemento compartilha esse lado*/
}

void TPZRefPattern::DefinitionOfSizePartition(){
  TPZGeoEl *fat = Element(0);/**elemento pai da divis�*/
  int nsidefat = fat->NSides();
  int nnodes = fat->NNodes();
  int nsides = nsidefat-nnodes;
  fFatherSides.fInitSide.Resize(nsides+1);/**nmero de lados do pai + final*/  
  int maxsize = 0,sidefat,sf;
//  int nsubs = NSubElements();
  int size = fTransforms.fFatherSide.NElements();  
  fFatherSides.fInitSide[0] = 0;
  for(sf=nnodes;sf<nsidefat;sf++){/**os cantos do pai n� s� particionados*/
    int sd = 0;
    int nsidestot = 0;
    while(sd < size){
      sidefat = fTransforms.fFatherSide[sd];/**percorre fFatherSide: lado do pai contendo lado de filho*/
      if(sidefat == sf) nsidestot++;/**conta todos os lados repetidos igual a sf*/      
      sd++;
    }
    maxsize += nsidestot;/**nmero total de lados que particionam os lados do pai (exceto cantos do pai)*/
    fFatherSides.fInitSide[sf-nnodes + 1] = maxsize;/**comeco do pr�imo lado do pai*/    
  }
  fFatherSides.fPartitionSubSide.Resize(maxsize);
  /**PARA TESTES*/
//  ofstream out("dimofpartition.out");
//  out << "Valores de fFatherSides.fInitSide[sd]\n\n";
//  for(int sd=0;sd<nsides;sd++){
//    out << "sd : fInitSide[sd] = " << sd << " : " << fFatherSides.fInitSide[sd] << endl;
//  }
//  out << "Tamanho de fPartitionSubSide =  " << maxsize; 
//  cout << "\nTPZRefPattern::DefinitionOfSizePartition arquivo da particao: dimofpartition.out\n";
}

TPZGeoEl *TPZRefPattern::Element(int iel){
  int nel = NSubElements()+1;/**filhos mais o pai*/
  if(iel<0 || iel>nel){
    PZError <<  "TPZRefPattern::Element elemento nao existe, elemento de id = " << iel << endl;
  }
  return ( fMesh.ElementVec()[iel]  );
}

int TPZRefPattern::SidePartition(TPZVec<TPZGeoElSide> &gelvec, int side){
  int nsides = Element(0)->NSides();/**nmero de lados do pai*/
  int nnodes = Element(0)->NNodes();
  if(side<nnodes || side>nsides){
    PZError <<  "TPZRefaPattern::SidePartition side error: side = " << side << endl;
    gelvec.Resize(0);
    return 0;
  }
  side -= Element(0)->NNodes();/**n� inclui cantos*/
  int firstpos = fFatherSides.fInitSide[side];/**posic� inicial da partic� do lado*/
  int lastpos = fFatherSides.fInitSide[side+1];/**posic� final da partic� do lado*/
  int size = lastpos-firstpos;
  gelvec.Resize(size);/**tamanho: nmero de elementos da partic� do lado*/
  int pos;
  for(pos = firstpos;pos<lastpos;pos++){
    int pos0 = pos - firstpos;
    gelvec[pos0] = fFatherSides.fPartitionSubSide[pos];
  }
  return size;/**nmero de elementos da partic� do lado*/;
}

/**verifica as transformac�s do lado do sub-elemento para o lado do pai*/
void TPZRefPattern::TransformationTest(){
  int isub,sd,ip;
  //x1 no filho deformado, x2 no pai deformado
  TPZManVector<REAL> x1(3),pf(3),x2(3),xpf(3,0.);
  REAL weight;
  TPZGeoEl *father = Element(0);/**pai*/
  int dimfatside,fatside,nsides;
  int dimfat = father->Dimension();
  TPZGeoEl *subel;
  int nsubs = NSubElements();
  for(isub=0;isub<nsubs;isub++){    
    subel  = Element(isub+1);
    nsides = subel->NSides();
    for(sd=0;sd<nsides;sd++){
      if( sd<subel->NNodes() && IsFatherNeighbour(TPZGeoElSide(father,sd),subel) ) continue;
      int dims = subel->SideDimension(sd);
      int dimsub = subel->Dimension();
      /**regra de integrac� para o espaco param�rico do lado do sub-elemento*/
      TPZIntPoints *rule = subel->CreateSideIntegrationRule(sd,5);
      TPZVec<int> order(dims,5);
      TPZVec<REAL> point(dims,0.),point2(dimsub);
      rule->SetOrder(order);
      for(ip=0;ip<rule->NPoints();ip++){
        /**ponto no espaco param�rico do lado do filho*/
        rule->Point(ip,point,weight);        
        TPZTransform sidet(dimsub);/**transformac� unit�ia*/
        if(dims < dimsub){          
          sidet = subel->SideToSideTransform(sd,nsides-1);/**transf. no elemento metre*/
       //   TPZTransform told(sidet);
      //    sidet =  subel->SideToElemShapeT(sd);
      //    if(IsNotEqual(sidet,told)) 
       //     PZError <<  "TPZRefPattern::TransformationTest as transformacoes nao sao iguais -> 1\n\n";
        }
        sidet.Apply(point,point2);//**transformac� para o interior do mestre do sub-elemento*
        subel->X(point2,x1);/**ponto no lado do filho deformado*/
        /**transformac�: espaco param�rico do filho/lado  -> espaco param�rico do pai/lado*/
        fatside = father->WhichSide(x1);/**no elemento mestre do pai, father �o deformado*/;
        dimfatside = father->SideDimension(fatside);
        TPZTransform trans = Transform(sd,isub);/**transforma�o calculada pelo TPZRefPattern*/
        /**------------teste das transforma�es-----------*/
        TPZTransform sdtosd(dims);
        TPZGeoElSide(subel,sd).SideTransform3(TPZGeoElSide(father,fatside),sdtosd);
        if(IsNotEqual(trans,sdtosd)){
          PZError <<  "TPZRefPattern::TransformationTest as transformacoes nao sao iguais -> 2\n\n";
        }
        /**-----------fim teste das transforma�es--------*/
        TPZVec<REAL> pf(dimfatside);
        trans.Apply(point,pf);/**ponto pf no espaco param�rico do lado do pai*/
        TPZTransform sidetf(dimfatside);/**unit�ia do lado do pai*/
        if(dimfatside < dimfat){
          /**para o interior do sub-elemento*/  
          sidetf = father->SideToSideTransform(fatside,father->NSides()-1);
          //sidetf =  father->SideToElemShapeT(fatside);
        }
        sidetf.Apply(pf,xpf);/**do espaco param�rico do lado do pai para o interior do pai*/
        father->X(xpf,x2);//ponto no lado do pai deformado	
        if( sqrt( (x1[0]-x2[0])*(x1[0]-x2[0]) + (x1[1]-x2[1])*(x1[1]-x2[1]) + (x1[2]-x2[2])*(x1[2]-x2[2]) ) > 1.e-10 ){
          PZError << "\nTransformacao errada\n";
          PZError << "son    = " << (subel->Id()) << endl;
          PZError << "father = " << (father->Id()) << endl;
          PZError << "side   = " << sd << endl << endl;
          int ok;
          cin >> ok;
        } else {
/*           cout << "Transformacao OK!\n"; */
/*           cout << "Filho/lado : " << subel->Id() << "/" << sd << endl; */
/*           cout << "Pai : " << father->Id() << endl << endl; */
        }//fim if sqrt..
      }//fim rule
    }//fim for sd
  }//fim for isub
}

int TPZRefPattern::IsNotEqual(TPZTransform &Told, TPZTransform &Tnew){
  int nrows = Told.Mult().Rows();
  int ncols = Told.Mult().Cols();
  if(Tnew.Mult().Rows()!=nrows || Tnew.Mult().Cols()!=ncols) return 1;
  if(Tnew.Sum().Rows()!=Told.Sum().Rows() || Tnew.Sum().Cols()!=Told.Sum().Cols()) return 1;
  int c,r;
   for(r=0;r<nrows;r++){
     for(c=0;c<ncols;c++){         
      if( fabs(Tnew.Mult()(r,c)-Told.Mult()(r,c)) > 1.e-12 ) return 1;
    }
    if( fabs(Tnew.Sum()(r,0)-Told.Sum()(r,0)) > 1.e-12 ) return 1; 
  }
  return 0;
}


void TPZRefPattern::CreateNewNodes (TPZGeoEl * gel, TPZVec<int> &newnodeindexes){
  int side;
  int nnodes = gel->NCornerNodes();
  int totalnodes = fMesh.NNodes();
  newnodeindexes.Resize(totalnodes);
  
  if (gel->HasSubElement()){
    cout << "CreateNewNodes called for an element which is already divided. \n";
    cout.flush();
    return;
// Este trecho nao teria funcionado mesmo. Nada garante que esta ordem seria
// respeitada pelo padrao de refinamento
//    for (side=gel->NCornerNodes();side<gel->NSides();side++){
//      gel->MidSideNodeIndex(side,index);
//      newnodeindexes[side-sum] = index;
//    }
//    return;
  }

  int nsides = gel->NSides();
  //Nao estou mais iterando em i... melhorou??
  for (side = nnodes;side<nsides;side++){
    CreateMidSideNodes(gel,side,newnodeindexes);
  }
}

void TPZRefPattern::CreateMidSideNodes (TPZGeoEl * gel, int side, TPZVec<int> &newnodeindexes){
  
  int i,j,k,index;
  TPZGeoMesh *gmesh = gel->Mesh();
  //SideNodes retorna um vetor com os indices dos nos internos da malha refpatern
  //com ele eu sei quantos nos internos ou, na linguagem antiga , quantos MidSideNodes tem
  TPZManVector<int> sidenodes;
  SideNodes(side,sidenodes);
  TPZGeoElSide gelside(gel,side);
  TPZGeoElSide neighbour(gelside.Neighbour());
  TPZManVector<int> sideindices(0);
  while(neighbour.Element() && neighbour != gelside) {
    //if(!neighbour.HasSubElement()) {
    if(neighbour.HasSubElement() && neighbour.Element()->NSideSubElements2(neighbour.Side()) > 1) {      
      neighbour.Element()->MidSideNodeIndices(neighbour.Side(),sideindices);
      break;
    }
    neighbour = neighbour.Neighbour();
  }
  for (j=0;j<sidenodes.NElements();j++){
    index = sidenodes[j];
    //coordenadas do novo no na malha ref pattern
    TPZVec<REAL> refnodecoord(3,0.);
    TPZManVector<REAL,3> neighbourcoord(3,0.);
    for (k=0;k<3;k++) refnodecoord[k] = fMesh.NodeVec()[index].Coord(k);
    //passando para as coordenadas do elemento da malha real...
    TPZManVector<REAL,3> newnodecoord(Element(0)->Dimension(),0.);
    //coordenada no espaco do elemento mestre do elemento de
    //referencia da malha refpattern
    Element(0)->ComputeXInverse(refnodecoord,newnodecoord);
    //coordenada espacial do no na malha real
    gel->X(newnodecoord,refnodecoord);
    newnodeindexes[index] = -1;
    //verificar se um vizinho ja criou o no
    for(i=0; i< sideindices.NElements(); i++) {
      for(k=0; k<3; k++) neighbourcoord[k] = gmesh->NodeVec()[sideindices[i]].Coord(k);
      REAL dif = 0.;
      for (k=0;k<3;k++) {
        dif += (refnodecoord[k] - neighbourcoord[k]) * (refnodecoord[k] - neighbourcoord[k]);
      }
      if (dif < 1e-12) {
        newnodeindexes[index] = sideindices[i];
        break;
      }
    }
    if (newnodeindexes[index] == -1) {
      //Caso o no nao exista nos vizinhos sera necessario cria-lo...
      int newindex = gmesh->NodeVec().AllocateNewElement();
      gmesh->NodeVec()[newindex].Initialize(refnodecoord,*gmesh);
      newnodeindexes[index] = newindex;
    }
  }
}
/** Returns the refinement pattern identifier */
string TPZRefPattern::GetName(){
  return fName;
}


/*!
    \fn TPZRefPattern::operator==(const TPZRefPattern &compare)
 */
int TPZRefPattern::operator==(const TPZRefPattern &compare) const
{
  int nnodes = fMesh.NNodes();
  if(fMesh.NNodes() != compare.fMesh.NNodes() || fMesh.NElements() != compare.fMesh.NElements()) return 0;
  TPZGeoEl *father = fMesh.ElementVec()[0];
  TPZGeoEl *compfather = compare.fMesh.ElementVec()[0];
  if(father->Type() != compfather->Type()) return 0;
  int dim = father->Dimension();
  int nsides = father->NSides();
//  TPZTransform t = father->ComputeParamTrans(compfather,nsides-1,nsides-1);
  std::map<int,int> nodemap;
  int in;
  for(in = 0; in<nnodes; in++) 
  {
    TPZManVector<REAL,3> coord(3,0.), coordcompare(3,0.), elparam(dim,0.), compareparam(dim,0.);
    int i; 
    for(i=0; i<3; i++) coord[i] = fMesh.NodeVec()[in].Coord(i);
    father->ComputeXInverse(coord,elparam);
//    t.Apply(elparam,compareparam);
//    compfather->X(compareparam,coordcompare);
    int jn;
    for(jn=0; jn<nnodes; jn++)
    {
      REAL diff = 0.;
      int j;
      for(j=0; j<3; j++) coordcompare[j] = compare.fMesh.NodeVec()[jn].Coord(j);
      compfather->ComputeXInverse(coordcompare,compareparam);
      for(j=0 ; j<dim; j++) diff += (elparam[j]-compareparam[j])*(elparam[j]-compareparam[j]);
      diff = sqrt(diff);
      if(diff < 1.e-8) 
      {
        nodemap[in] = jn;
        break;
      }
    }
    if(jn == nnodes) return 0;
  }
  int nelem = fMesh.NElements();
  int iel;
  std::map<int,int> elementmap;
  for(iel = 0; iel<nelem; iel++)
  {
    std::set<int> nodeset;
    TPZGeoEl *igel = fMesh.ElementVec()[iel];
    int in, nnode = igel->NNodes();
    for(in=0; in<nnode; in++) nodeset.insert(nodemap[igel->NodeIndex(in)]);
    int jel;
    for(jel=0; jel < nelem; jel++) 
    {
      if(elementmap.find(jel) != elementmap.end()) continue;
      std::set<int> compnodeset;
      TPZGeoEl *jgel = compare.fMesh.ElementVec()[jel];
      int jn, jnnode = jgel->NNodes();
      if(jnnode != nnode) continue;
      for(jn=0; jn<jnnode; jn++) compnodeset.insert(jgel->NodeIndex(jn));
      if(nodeset == compnodeset)
      {
        elementmap[jel] = iel;
        break;
      }
    }
    if(jel == nelem) 
    {
    
      cout << "node map\n";
      for(in=0; in<nnodes; in++) cout << in << " -> " << nodemap[in] << " | ";
      cout << endl;
      int iel;
      cout << "The mapped element node indices are\n";
      for(iel = 0; iel<nelem; iel++)
      {
        TPZGeoEl *igel = fMesh.ElementVec()[iel];
        int in, nnode = igel->NNodes();
        for(in=0; in<nnode; in++) cout << nodemap[igel->NodeIndex(in)] << ' ';
        cout << std::endl;
      }
      cout << "The compared element node indices are\n";
      for(iel = 0; iel<nelem; iel++)
      {
        TPZGeoEl *igel = compare.fMesh.ElementVec()[iel];
        int in, nnode = igel->NNodes();
        for(in=0; in<nnode; in++) cout << igel->NodeIndex(in) << ' ';
        cout << std::endl;
      }
      
      return 0;
    }
  }
  return 1;
}


    /**
    * Generate a string which may represent the refinement pattern
    */
std::string TPZRefPattern::GenericName()
{
  TPZGeoEl * gel = fMesh.ElementVec()[0];
  if(!gel) return "noname";
  std::stringstream result;
  result << gel->TypeName();
  int nsides = gel->NSides();
  int nnodes = gel->NNodes();
  result << ":";
  int is;
  for(is=nnodes; is<nsides; is++)
  {
    result << this->NSideNodes(is) << ":";
  }
  return result.str();
}

    /**
    *  Automatically generate all permuted partitioned
    */
void TPZRefPattern::GeneratePermuted(TPZGeoEl *gel)
{
  if(fPermutations.count(gel->Type())) return;
  TPZGeoMesh *gelmesh = gel->Mesh();
  TPZGeoMesh gmesh;
  gmesh.NodeVec().Resize(gel->NNodes());
  int in,nnodes;
  nnodes = gel->NNodes();
  for(in=0; in<nnodes; in++) 
  {
    gmesh.NodeVec()[in].Initialize(gelmesh->NodeVec()[gel->NodeIndex(in)],gmesh);
  }
  TPZGeoEl *gelp;
  TPZIntPoints *integ = gel->CreateSideIntegrationRule(gel->NSides()-1,3);
  TPZVec<int> nodes(nnodes),nodesperm(nnodes);
  for(in=0; in<nnodes; in++) 
  {
    nodes[in]=in;
  }
  int matid = gel->MaterialId();
  TPZPermutation permute(nnodes);
  TPZTransform trans(gel->Dimension());
  TPZRefPatternPermute refpermute;
  
  refpermute.fPermute = permute;
  refpermute.fTransform = trans;
  fPermutations[gel->Type()].push_back(refpermute);
  permute++;
  while(!permute.IsFirst())
  {
    permute.Permute(nodes,nodesperm);
    int index;
    gelp = gmesh.CreateGeoElement(gel->Type(),nodesperm,matid,index,-1);
    int dim = gel->Dimension();
    TPZVec<REAL> point(dim,0.);
    REAL w;
    int npoint = integ->NPoints();
    int ip;
    bool valid = true;
    for(ip=0; ip<npoint; ip++)
    {
      integ->Point(ip,point,w);
      TPZFMatrix jac(dim,dim),jacinv(dim,dim),axes(3,3);
      REAL detjac,detjac2;
      gelp->Jacobian(point,jac,axes,detjac,jacinv);
      gel->Jacobian(point,jac,axes,detjac2,jacinv);
      if(fabs(fabs(detjac)-fabs(detjac2)) > 1.e-10)
      {
        valid = false;
        break;;
      }
    }
    if(valid)
    {
      cout << " element type " << gel->Type() << " nodesperm " << nodesperm << endl;
      TPZRefPatternPermute candidate;
      candidate.fPermute = permute;
      candidate.fTransform = gel->ComputeParamTrans(gelp,gel->NSides()-1,gel->NSides()-1);
      fPermutations[gel->Type()].push_back(candidate);
    }
    permute++;
  }
  
  delete integ;
}
    
    /**
     *  Generate all permuted partitions and insert them in the mesh
     */
void TPZRefPattern::InsertPermuted(TPZGeoMesh &gmesh)
{
  if(!fMesh.ElementVec().NElements() || !fMesh.ElementVec()[0]) return;
  TPZGeoEl *gel = fMesh.ElementVec()[0];
  GeneratePermuted(gel);
  MElementType geltype = gel->Type();
  std::list<TPZRefPatternPermute> &permlist = fPermutations[geltype];
  std::list<TPZRefPatternPermute>::iterator it;
  fPermutedRefPatterns.resize(permlist.size());
  int counter;
  for(it=permlist.begin(),counter=0; it != permlist.end(); it++,counter++)
  {
    TPZRefPattern *refp = new TPZRefPattern(*this,(*it).fPermute);
    TPZRefPattern *found = gmesh.FindRefPattern(refp);
    if(found)
    {
      fPermutedRefPatterns[counter] = found;
      delete refp;
    }
    else
    {
      //refp->Print();
      gmesh.InsertRefPattern(refp);
      fPermutedRefPatterns[counter] = refp;
      refp->ShortPrint(std::cout);
      std::cout << std::endl;
      refp->InsertPermuted(gmesh);
    }
  }
  GenerateSideRefPatterns(gmesh);
}

void TPZRefPattern::CopyMesh(const TPZGeoMesh &gmesh,const TPZPermutation &permute)
{
  int nnodes = gmesh.NNodes();
  int nelem = gmesh.NElements();
  int in;
  fMesh.NodeVec().Resize(nnodes);
  for(in=0; in<nnodes; in++)
  {
    fMesh.NodeVec()[in].Initialize(gmesh.NodeVec()[in],fMesh);
  }
  TPZGeoEl *gel;
  TPZGeoEl *father = 0;
  int el;
  for(el=0; el<nelem; el++)
  {
    gel = gmesh.ElementVec()[el];
    int nn = gel->NNodes();
    TPZVec<int> nodes(nn), nodeperm(nn);
    int in;
    for(in=0; in<nn; in++)
    {
      nodes[in] = gel->NodeIndex(in);
    }
    int matid = gel->MaterialId();
    int index;
    if(el==0)
    {
      permute.Permute(nodes,nodeperm);
      father = fMesh.CreateGeoElement(gel->Type(),nodeperm,matid,index,-1);
    } else
    {
      TPZGeoEl *sub = fMesh.CreateGeoElement(gel->Type(),nodes,matid,index,-1);
      sub->SetFather(father);
    }
  }
}

void TPZRefPattern::CopyMesh(const TPZGeoMesh &gmesh)
{
  int nnodes = gmesh.NNodes();
  int nelem = gmesh.NElements();
  int in;
  fMesh.NodeVec().Resize(nnodes);
  for(in=0; in<nnodes; in++)
  {
    fMesh.NodeVec()[in].Initialize(gmesh.NodeVec()[in],fMesh);
  }
  TPZGeoEl *gel;
  int el;
  TPZGeoEl *father = 0;
  for(el=0; el<nelem; el++)
  {
    gel = gmesh.ElementVec()[el];
    int nn = gel->NNodes();
    TPZVec<int> nodes(nn);
    int in;
    for(in=0; in<nn; in++)
    {
      nodes[in] = gel->NodeIndex(in);
    }
    int matid = gel->MaterialId();
    int index;
    TPZGeoEl *subel  = fMesh.CreateGeoElement(gel->Type(),nodes,matid,index,-1);
    if(el==0) 
    {
      father = subel;
    }
    else 
    {
      subel->SetFather(father);
    }
  }
}

    /**
    * Generate the refinement patterns associated with the sides of the father element
    */
void TPZRefPattern::GenerateSideRefPatterns(TPZGeoMesh &gmesh)
{
  if(fSideRefPattern.NElements()) return;
  if(!fMesh.ElementVec().NElements()) return;
  TPZGeoEl *gel = fMesh.ElementVec()[0];
  int nsides = gel->NSides();
  fSideRefPattern.Resize(nsides,0);
  fSideRefPattern[nsides-1] = this;
  int is;
  for(is=0; is<nsides-1; is++)
  {
    if(gel->SideDimension(is) == 0) continue;
    if(NSideSubElements(is) == 1) continue;
    TPZRefPattern *sideref = new TPZRefPattern();
    BuildSideMesh(is, sideref->fMesh);
    sideref->fNSubEl = sideref->fMesh.NElements()-1;
    sideref->ComputeTransforms();/**calcula as transforma�es entre filhos e pai*/
    sideref->ComputePartition();/**efetua a parti�o do elemento pai de acordo com os lados dos */
    sideref->fName = sideref->GenericName();
    TPZRefPattern *found = gmesh.FindRefPattern(sideref);
    if(!found)
    {
      sideref->GenerateSideRefPatterns(gmesh);
      gmesh.InsertRefPattern(sideref);
      sideref->InsertPermuted(gmesh);
      fSideRefPattern[is] = sideref;
    }
    else
    {
      fSideRefPattern[is] = found;
      delete sideref;
    }
  }
}

  /**
   *  build a geometric mesh associated with the side of the refinement pattern
   */
void TPZRefPattern::BuildSideMesh(int side, TPZGeoMesh &gmesh)
{
  if(!fMesh.ElementVec().NElements()) return;
  TPZGeoEl *gel = fMesh.ElementVec()[0];
  TPZStack<int> allsides;
  std::map<int,int> allsidenodes;
  int count =0;
  gel->LowerDimensionSides(side,allsides);
  allsides.Push(side);
  int s;
  for(s=0; s<allsides.NElements(); s++)
  {
    TPZStack<int> sidenodes;
    SideNodes(allsides[s],sidenodes);
    int t;
    for(t=0; t<sidenodes.NElements(); t++)
    {
      if(!allsidenodes.count(sidenodes[t])) allsidenodes[sidenodes[t]] = count++;
    }
  }
  gmesh.NodeVec().Resize(allsidenodes.size());
  std::map<int,int>::iterator it;
  for(it=allsidenodes.begin(); it!= allsidenodes.end(); it++)
  {
    int nodeorig = (*it).first;
    int nodedest = (*it).second;
    gmesh.NodeVec()[nodedest].Initialize(fMesh.NodeVec()[nodeorig],gmesh);
  }
  TPZStack<int> nodeindices;
  nodeindices.Resize(gel->NSideNodes(side));
  int in;
  for(in=0; in<nodeindices.NElements(); in++)
  {
    nodeindices[in] = allsidenodes[gel->SideNodeIndex(side,in)];
  }
  int matid = gel->MaterialId();
  int index;
  TPZGeoEl *father = gmesh.CreateGeoElement(gel->Type(side),nodeindices,matid,index,-1);
  int sidedim = father->Dimension();
  TPZStack<TPZGeoElSide> gelvec;
  SidePartition(gelvec, side);
  int nsub = gelvec.NElements();
  int subel;
  for(subel=0; subel<nsub; subel++)
  {
    if(gelvec[subel].Dimension() != sidedim) continue;
    nodeindices.Resize(gelvec[subel].NSideNodes());
    for(in=0; in<nodeindices.NElements(); in++)
    {
      nodeindices[in] = allsidenodes[gelvec[subel].SideNodeIndex(in)];
    }
    MElementType type = gelvec[subel].Element()->Type(gelvec[subel].Side());
    TPZGeoEl *subel = gmesh.CreateGeoElement(type,nodeindices,matid,index);
    subel->SetFather(father);
  }
  gmesh.BuildConnectivity();
//  gmesh.Print(std::cout);
}

    /**
     * Find the side refinement pattern corresponding to the parameter transformation
     */
TPZRefPattern *TPZRefPattern::SideRefPattern(int side, TPZTransform &trans)
{
  if(side >= fSideRefPattern.NElements()) return 0;
  TPZRefPattern *sideref = fSideRefPattern[side];
  if(!sideref) return 0;
  return sideref->FindRefPattern(trans);
}

    /**
     * Find the refinement pattern corresponding to the give transformation
     */
 TPZRefPattern *TPZRefPattern::FindRefPattern(TPZTransform &trans)
 {
   REAL tol = 1.e-6;
   if(!fMesh.ElementVec().NElements() || ! fMesh.ElementVec()[0]) return 0;
   MElementType type = fMesh.ElementVec()[0]->Type();
   int count;
   std::list<TPZRefPatternPermute> &permlist = fPermutations[type];
   std::list<TPZRefPatternPermute>::iterator it;
   for(it = permlist.begin(), count = 0; it != permlist.end(); it++,count++)
   {
     TPZRefPatternPermute &tmp = (*it);
     if(!tmp.fTransform.Compare(trans,tol))
     {
       return fPermutedRefPatterns[count];
     }
   }
   return 0;
 }
 
/**
 * build a list of all refinement patterns compatible with the refinements of the neighbouring elements
 */
void TPZRefPattern::GetCompatibleRefinementPatterns(TPZGeoEl *gel, std::list<TPZRefPattern *> &refs)
{
  if(!gel) return;
  refs.clear();
  if(gel->HasSubElement()) 
  {
    refs.push_back(gel->GetRefPattern());
    return;
  }
  // first we build the refinement patterns associated with the neighbours of the current element
  int is,nsides,nnodes;
  nsides = gel->NSides();
  nnodes = gel->NNodes();
  TPZManVector<TPZRefPattern *,27> SideRefPatterns(nsides,0);
  TPZManVector<int, 27> refsides(nsides,0);
  for(is=nnodes; is<nsides; is++)
  {
    TPZGeoElSide gelside(gel,is);
    TPZGeoElSide neigh = gelside.Neighbour();
    while(neigh != gelside)
    {
      if(neigh.Element()->HasSubElement() && neigh.NSubElements2() > 1)
      {
        refsides[is] = 1;
        TPZRefPattern *refp = neigh.Element()->GetRefPattern();
        if(refp)
        {
//          TPZTransform trans = gelside.NeighbourSideTransform(neigh);
          TPZTransform trans = neigh.NeighbourSideTransform(gelside);
          SideRefPatterns[is] = refp->SideRefPattern(neigh.Side(),trans);
          break;
        }
      }
      neigh=neigh.Neighbour();
    }
  }
  /*
  for(is = nnodes; is<nsides; is++)
  {
    if(gel->SideDimension(is) == 2)
    {
      if(SideRefPatterns[is])
      {
        cout << gel->TypeName() << " for side " << is << " local side ref ";
        TPZStack<int> smallsides;
        gel->LowerDimensionSides(is,smallsides);
        int ils;
        for(ils=0; ils<smallsides.NElements(); ils++)
        {
          if(refsides[smallsides[ils]]) cout << ils << ' ';
        }
        cout << endl << "Side ref pattern ";
        
        SideRefPatterns[is]->ShortPrint(cout); cout << endl;
      }
    }
  }
  */
  // having the refinement patterns associated with the sides, look for compatible refinement patterns
  std::list<TPZRefPattern *> reflist = gel->Mesh()->RefPatternList(gel->Type());
  std::list<TPZRefPattern *>::iterator it;
  for(it=reflist.begin(); it != reflist.end(); it++)
  {
    // compare the side refinement patterns
    for(is=nnodes; is<nsides-1; is++) 
    {
      TPZRefPattern *candidate = (*it)->SideRefPattern(is);
      if(SideRefPatterns[is] && SideRefPatterns[is] != candidate) 
      {
        break;
      }
    }
    // if all refinement patterns are equal
    if(is == nsides-1) refs.push_back((*it));
  }

}

void TPZRefPattern::ShortPrint(std::ostream &out)
{
      TPZGeoEl *elemento = Element(0);
      int nsides = elemento->NSides();
      TPZVec<int> indices;
      //TPZVec<int> selected(nsides,0);
      out << elemento->TypeName();
      out << " Id " << fId << " Sides " ;
      for (int p=0 ; p<nsides; p++){
        if (elemento->SideDimension(p)==1 && NSideNodes(p))
        {
             out << p << " ";
        }
       }
}
