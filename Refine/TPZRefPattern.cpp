/* Generated by Together */

#include "TPZRefPattern.h"
//#include "pzgmesh.h"
#include "pztrnsform.h"
#include "pzreal.h"
#include "pzgmesh.h"
#include "pzquad.h"
#include "pzvec.h"
#include "pzeltype.h"
#include "tpzpermutation.h"
#include "pzgeoel.h"
#include "pzlog.h"
#include <set>

#include <fstream>
#include <sstream>

using namespace std;


#ifdef LOG4CXX
static LoggerPtr logger(Logger::getLogger("pz.mesh.tpzrefpattern"));
#endif

std::map<MElementType, std::list<TPZRefPattern::TPZRefPatternPermute> > TPZRefPattern::fPermutations;

TPZRefPattern::TPZRefPattern(TPZGeoMesh * OwnerMesh) : fInternalMesh(), fOwnerMesh(OwnerMesh), fSideRefPattern(0), fId(-50), fName(){
  fSideRefPattern.Resize(0);
  //fName = "";
  fNSubEl = 0;
}

TPZRefPattern::TPZRefPattern(const TPZRefPattern &copy) : fInternalMesh(copy.fInternalMesh), fSideRefPattern(copy.fSideRefPattern),fId(-50){
  fFileRefPatt = copy.fFileRefPatt;
  fName = copy.fName;
  fNSubEl = copy.fNSubEl;
  ComputeTransforms();/**calcula as transforma�es entre filhos e pai*/
  ComputePartition();/**efetua a parti�o do elemento pai de acordo com os lados dos sub-elementos*/
  fName = GenericName();
  this->fOwnerMesh = copy.fOwnerMesh;
}

    /**
     * Create a copy of the TPZRefPattern applying the permutation on the first element
     */
TPZRefPattern::TPZRefPattern (const TPZRefPattern &copy,const TPZPermutation &permute) : fInternalMesh(copy.fInternalMesh), fSideRefPattern(copy.fSideRefPattern), fId(copy.fId) {
  fFileRefPatt = copy.fFileRefPatt;
  fNSubEl = copy.fNSubEl;
  this->PermuteMesh(permute);
  ComputeTransforms();/**calcula as transforma�es entre filhos e pai*/
  ComputePartition();/**efetua a parti�o do elemento pai de acordo com os lados dos sub-elementos*/
  fName = GenericName();
  this->fOwnerMesh = copy.fOwnerMesh;
}


TPZRefPattern::TPZRefPattern(TPZGeoMesh * OwnerMesh,  const std::string &file ) : fSideRefPattern(0), fId(-50), fName() {
  this->fOwnerMesh = OwnerMesh;
  fInternalMesh.SetName("***RefinementPattern***");
  fFileRefPatt = file;/**arquivo contendo o padr� de refinamento*/
  ReadPattern2();/**l�o arquivo contendo o refinamento e cria a malha fInternalMesh*/
  fInternalMesh.BuildConnectivity();/**conectividades entre sub-elementos*/
  //  fInternalMesh.Print(); /**Printing mesh info to check */
  ComputeTransforms();/**calcula as transforma�es entre filhos e pai*/
  ComputePartition();/**efetua a parti�o do elemento pai de acordo com os lados dos sub-elementos*/
}

TPZRefPattern::TPZRefPattern(TPZGeoMesh * OwnerMesh, std::istream &file ) : fSideRefPattern(0), fId(-50),fName() {
  this->fOwnerMesh = OwnerMesh;
  ReadPattern(file);
}


TPZRefPattern::TPZRefPattern(TPZGeoMesh * OwnerMesh, TPZGeoMesh &GMesh): fInternalMesh(GMesh), fOwnerMesh(OwnerMesh), fSideRefPattern(0), fId(-50) {
  fFileRefPatt = '\0';
  fNSubEl = GMesh.NElements() - 1;
  fInternalMesh.BuildConnectivity();/**conectividades entre sub-elementos*/
  ComputeTransforms();/**calcula as transforma�es entre filhos e pai*/
  ComputePartition();/**efetua a parti�o do elemento pai de acordo com os lados dos sub-elementos*/
  fName = GenericName();
}


void TPZRefPattern::Print(){

#ifdef LOG4CXX
  static LoggerPtr logger(Logger::getLogger("pz.mesh.refpattern"));
#endif

 // std::ostringstream buf;

  int nnewnodes=0;
  //cout << endl;
  std::cout << std::endl;
  std::cout << "=================" << std::endl;
  std::cout <<"PRINTING REFINEMENT PATTERN / Name : "<< fName <<  std::endl;
  std::cout << std::endl;
  int nnodes = fInternalMesh.NNodes() ;
  std::cout << "=================" << std::endl;
  std::cout << "Number of nodes: " << nnodes << std::endl ;
  int nel = fInternalMesh.NElements();
  std::cout << "Number of elements: " << nel << std::endl;
  //cout << "Refinement Type: " << fRefineType << endl;
  std::cout << "________________" << std::endl;
  std::cout << "Element Node Indexes" << std::endl;
  for (int i=0 ; i<nel ; i++){
    if (i==0){
      std::cout << "Master element nodes: "  ;
    }
    else{
      std::cout << "Element: " << i << " Nodes: " ;
    }

    for (int k=0 ; k<fInternalMesh.ElementVec()[i]->NNodes() ; k++){
      std::cout << fInternalMesh.ElementVec()[i]->NodeIndex(k) << "  ";
    }
    std::cout << std::endl;
  }
  std::cout << std::endl;
  std::cout << "________________" << std::endl;
  std::cout << "Number of new nodes per side ";
  for (int i=0 ; i<1 ; i++){
    //    cout << "Element: " << i << endl;
    for (int j=0 ; j<fInternalMesh.ElementVec()[i]->NSides() ; j++){
      if (fInternalMesh.ElementVec()[0]->SideDimension(j)==1){
        nnewnodes = NSideNodes(j);
        std::cout << j << ":" << nnewnodes << " ";
      }
    }
    std::cout << std::endl;
  }
  std::cout << std::endl;
  std::cout << "________________" << std::endl;
  std::cout << "Nodes coordinates " << std::endl;
  for (int i=0 ; i<nnodes ; i++){
    std::cout << "Node: " << i << " Coordinates:   " << fInternalMesh.NodeVec()[i].Coord(0) << "   "  << fInternalMesh.NodeVec()[i].Coord(1)  << "   "  << fInternalMesh.NodeVec()[i].Coord(2) << std::endl;
  }
  std::cout << std::endl;
  std::cout << std::endl;
  std::cout << "=================" << std::endl;
  std::cout << "End of RefPattern Printing." << std::endl ;
  std::cout << "=================" << std::endl;
  std::cout << std::endl;
  std::cout << std::endl;
  std::cout << std::endl;
  //LOGPZ_DEBUG(logger, buf.str());


}


void TPZRefPattern::WritePattern(std::ofstream &filename){

  //std::ofstream filename;

  filename << fInternalMesh.NNodes() << ' '  << fInternalMesh.NElements() << ' ' << fId <<  std::endl ;
  filename << fName  << std::endl;
  //  filename << fName << "    Ref. Pattern Mesh" << std::endl;
  for (int i=0; i<fInternalMesh.NNodes() ; i++){
    for (int k=0; k<3; k++){
	filename << fInternalMesh.NodeVec()[i].Coord(k) << ' ';
    }
    filename << std::endl;
  }

  for (int i =0; i<fInternalMesh.NElements(); i++){
    filename << fInternalMesh.ElementVec()[i]->Type() << " " << fInternalMesh.ElementVec()[i]->NCornerNodes() << " " ;
    for (int k=0; k<fInternalMesh.ElementVec()[i]->NCornerNodes() ;k++){
      filename << fInternalMesh.ElementVec()[i]->NodeIndex(k) << "  " ;
    }
    filename << std::endl;
  }
  int nperm = fPermutedRefPatterns.size();
  filename << nperm << ' ';
  int el;
  for(el=0; el<nperm; el++)
  {
//    int ip;
    filename << fPermutedRefPatterns[el] << ' ';
  }
  filename << std::endl;
  TPZGeoEl *father = fInternalMesh.ElementVec()[0];
  int nsides = father->NSides();
  int is;
  for(is=0; is<nsides; is++)
  {
    if(fSideRefPattern[is])
    {
      filename << fSideRefPattern[is] << ' ';
    } else
    {
      filename << -1 << ' ';
    }
  }
  filename << std::endl;
}

void TPZRefPattern::ReadPattern(std::istream &in)
{
  //ifstream in(fFileRefPatt.data());
  int nnodes,nelems,inode;
  in >> nnodes >> nelems >> fId;
  fNSubEl = nelems - 1;
  in >> fName;
//  getline(in,fName);
//  getline(in,fName);
  TPZManVector<REAL,3> coord(3);
  fInternalMesh.NodeVec().Resize(nnodes);
  //criac� dos objetos nodais
  for(inode=0;inode<nnodes;inode++){
    in >> coord[0];
    in >> coord[1];
    in >> coord[2];
//    cout << coord << endl;
    fInternalMesh.NodeVec()[inode].Initialize(inode,coord,fInternalMesh);
  }
  TPZGeoEl *father;
  //criac� dos elementos geom�ricos que definem a partic�
  int ntype,nummat = 1;
  int ncorners,incid,el;
  for(el=0;el<nelems;el++) {/**os sub-elementos podem n� ter de uma mesma geometria*/
    in >> ntype >> ncorners;
    //ncorners = ntype;
    //if(ntype == 7) ncorners = 4;/**tetraedro*/
    MElementType etype = (MElementType) ntype;
    TPZVec<int> nodes(ncorners);
    for(incid=0;incid<ncorners;incid++){
      in >> nodes[incid];
    }
    //cout << "nodes...: " << nodes << endl;
    int index;

    TPZGeoEl *subel = fInternalMesh.CreateGeoElement(etype,nodes,nummat,index,0);
    if(el==0){
      father = subel;
      //subel->SetRefPattern(this);

    }
    if(el>0){
      //father->SetSubElement(el-1,subel);
      subel->SetFather(father);
      subel->SetFather(father->Index());
    }
  }
  GeneratePermuted(father);
  fInternalMesh.BuildConnectivity();/**conectividades entre sub-elementos*/
//  fInternalMesh.Print(); /**Printing mesh info to check */
  ComputeTransforms();/**calcula as transforma�es entre filhos e pai*/
  ComputePartition();/**efetua a parti�o do elemento pai de acordo com os lados dos sub-elementos*/
}

void TPZRefPattern::ReadPattern(std::istream &in,std::vector< TPZAutoPointer<TPZRefPattern> > &collect){
  ReadPattern(in);
  int nperm;
  in >> nperm;
  this->fPermutedRefPatterns.resize(nperm);
  int el;
  for(el=0; el<nperm; el++)
  {
    int ip;
    in >> ip;
    fPermutedRefPatterns[el] = collect[ip]->Id();
  }
  TPZGeoEl *father = fInternalMesh.ElementVec()[0];
  int nsides = father->NSides();
  fSideRefPattern.Resize(nsides,0);
  fSideRefPattern[nsides-1] = this->Id();
  int is;
  for(is=0; is<nsides; is++)
  {
     int ip;
     in >> ip;
     if(ip >= 0)
     {
      fSideRefPattern[is] = collect[ip]->Id();
     } else
     {
      fSideRefPattern[is] = 0;
     }
  }
}


void TPZRefPattern::ReadPattern2(){
  ifstream in(fFileRefPatt.data());
  int nnodes,nelems,inode,RefineType;
  in >> nnodes >> nelems;
  fNSubEl = nelems - 1;
  in >> RefineType;
  in >> fName;
  cout << "Reading pattern " << fName << " from file " << fFileRefPatt << std::endl;
  TPZVec<REAL> coord(3);
  fInternalMesh.NodeVec().Resize(nnodes);
  //criac� dos objetos nodais
  for(inode=0;inode<nnodes;inode++){
    in >> coord[0];
    in >> coord[1];
    in >> coord[2];
//    cout << coord << endl;
    fInternalMesh.NodeVec()[inode].Initialize(inode,coord,fInternalMesh);
  }
  TPZGeoEl *father;
  //criac� dos elementos geom�ricos que definem a partic�
  int ntype,nummat,ncorners,incid,el;
  for(el=0;el<nelems;el++) {/**os sub-elementos podem n� ter de uma mesma geometria*/
    in >> ntype >> nummat;
    ncorners = ntype;
    if(ntype == 7) ncorners = 4;/**tetraedro*/
    TPZVec<int> nodes(ncorners);
    for(incid=0;incid<ncorners;incid++){
      in >> nodes[incid];
    }
    int index;
    MElementType etype;
    switch (ntype){
      case (1) :
        etype = EPoint;
        break;
      case (2) :
        etype = EOned;
        break;
      case(3):
        etype = ETriangle;
        break;
      case(4):
        etype = EQuadrilateral;
        break;
      case(5) :
        etype = EPiramide;
        break;
      case (6):
        etype = EPrisma;
        break;
      case(7):
        etype = ETetraedro;
        break;
      case (8):
        etype = ECube;
        break;
      default:
        std::cout << "ERROR : Undefined element type." << std::endl;
        exit(-1);
    }


    TPZGeoEl *subel = fInternalMesh.CreateGeoElement(etype,nodes,nummat,index,0);
    if(el==0){
      father = subel;
      //subel->SetRefPattern(this);

    }
    if(el>0){
      //father->SetSubElement(el-1,subel);
      subel->SetFather(father);
      subel->SetFather(father->Index());
    }
  }
}



/** Preenche-se a estrutura elemento/lado com aqueles objetos que tem
 *  transforma�o associada.Calcula-se a transforma�o entre o lado
 *  do sub-elemento e o lado do pai respectivo.
 */
void TPZRefPattern::ComputePartition(){
  int sizeinit = fTransforms.fInitSonSides.NElements()-1;/**igual ao nmero de filhos*/
  int init,iside;
  TPZGeoEl *fat = Element(0);/**elemento pai da divis�*/
  DefinitionOfSizePartition();/**calcula o tamanho da partic� dos lados do pai e inicializa fInitSide*/
  int sidestot = fFatherSides.fPartitionSubSide.NElements();
  /**inicializando o vetor de transformac�s*/
  for(int p=0;p<sidestot;p++) fFatherSides.fPartitionSubSide[p] = TPZGeoElSide();/**zera as entradas*/
  /**calcular a parti�o*/
  for(init=0;init<sizeinit;init++){/**percorre os filhos*/
    int initsideson = fTransforms.fInitSonSides[init];/**come� dos lados do filho*/
//    int lastsideson = fTransforms.fInitSonSides[init+1];/**comeco dos lados do pr�imo filho*/
//    int nsonsd = lastsideson-initsideson;/**comprimento da partic�*/
    TPZGeoEl *son = Element(init+1);/**filho*/
    int nsides = son->NSides();
    for(iside=0;iside<nsides;iside++){/**percorre-se os lados do filho*/
      int sdf = fTransforms.fFatherSide[initsideson+iside];/**lado do pai associado ao lado do sub-elemento*/
      if(sdf < fat->NNodes()) continue;/**cantos do pai n� entram na parti�o do lado*/
      int pos = 0;
      int sdf2 = sdf - fat->NNodes();/**fInitSide n� contempla os cantos, s�a partir de aresta para cima*/
      int initss = fFatherSides.fInitSide[sdf2];/**inicio da partic� do lado sdf do pai*/
      TPZGeoElSide sonside = TPZGeoElSide(fFatherSides.fPartitionSubSide[initss+pos], &fInternalMesh);/**1o sub/lado da parti�o do lado do pai*/
      TPZGeoElSide empty(sonside);/**copia de sonside*/
      int sizept = fFatherSides.fInitSide[sdf2+1]-initss;/**comprimento da faixa do lado*/
      while(empty.Element() && pos < sizept){/**percorre-se a faixa do lado do pai*/
        pos++;/**procura-se o primeiro lugar desocupado na faixa do lado do pai*/
        empty = TPZGeoElSide(fFatherSides.fPartitionSubSide[initss+pos], &fInternalMesh);
      }
      if(pos > sizept-1){/**a faixa toda esta ocupada com sub/lado n� nulo*/
        PZError << "TPZRefPattern::ComputePartition erro de dimensionamento\n";
        //exit(-1);
      }
      fFatherSides.fPartitionSubSide[initss+pos] = TPZGeoElSide(son,iside);
    }
  }
  /**conferindo a consist�cia da partic�*/
  for(int ss=0;ss<sidestot;ss++){
    if(!fFatherSides.fPartitionSubSide[ss].Element(&fInternalMesh)){
      PZError << "TPZRefPattern::ComputePartition particao inconsistente";
    }
  }
  /**saida do arquivo de dados da particao*/
//  ofstream out("partition.out");
//  fFatherSides.Print(*fInternalMesh,out);
  /**extraindo sub/side quando o side �repetido dentro da partic� do lado*/
  int init2;
  sizeinit = fFatherSides.fInitSide.NElements()-1;
  for(iside=0;iside<sizeinit;iside++){/**percorrendo fInitSide*/
    init = fFatherSides.fInitSide[iside];/**posic� inicial*/
    init2 = fFatherSides.fInitSide[iside+1];/**posic� final*/
    for(int sd=init;sd<init2;sd++){/**percorrendo a partic� do lado do pai*/
      TPZGeoElSide gs = TPZGeoElSide(fFatherSides.fPartitionSubSide[sd], &fInternalMesh);/**1o sub/side do lado*/
      if(!gs.Element()) continue;
      for(int sd2=sd+1;sd2<init2;sd2++){
        TPZGeoElSide gs2 = TPZGeoElSide(fFatherSides.fPartitionSubSide[sd2], &fInternalMesh);/**sub/side sub-seguinte do lado*/
        if(gs2.Element() && gs.Element()->NeighbourExists(gs.Side(),gs2)){
           fFatherSides.fPartitionSubSide[sd2] = TPZGeoElSide();/**apagando o sub/side com side repetido*/
        }
      }
    }
  }
  /**tirando os buracos da partic�*/
  TPZVec<int> newinit(fFatherSides.fInitSide.NElements());/**capacidade m�ima*/
  TPZVec<TPZGeoElSideIndex> newpartition(fFatherSides.fPartitionSubSide.NElements());/**capacidade m�ima*/
  newinit[0] = 0;
  int count = 0;
  for(iside=0;iside<sizeinit;iside++){/**percorrendo fInitSide*/
    init = fFatherSides.fInitSide[iside];/**posic� inicial*/
    init2 = fFatherSides.fInitSide[iside+1];/**posic� final*/
    newinit[iside+1] = newinit[iside];
    for(int sd=init;sd<init2;sd++){/**percorrendo a partic� do lado do pai*/
      TPZGeoElSideIndex gs = fFatherSides.fPartitionSubSide[sd];/**1o sub/side do lado*/
      if(!gs.Element(&fInternalMesh)) continue;
      newinit[iside+1]++;
      newpartition[count++] = gs;
    }
  }
  fFatherSides.fInitSide = newinit;
  fFatherSides.fPartitionSubSide = newpartition;
  NSideSubElements();/**preenche fNSubSideFather com o nmero de elementos associados a cada lado do pai*/
//  out << "\n\n               *** Particao enxuta ***\n\n";
//  fFatherSides.Print(*fInternalMesh,out);
//  out.flush();
//  out.close();
//  cout << "\nTPZRefPattern::ComputePartition arquivo contendo a particao dos lados do pai: partition.out\n";
//  ofstream out1("fathersides.out");
//  Print1(*fInternalMesh,out1);
//  out1.flush();
//  out1.close();
//  cout << "\nTPZRefPattern::ComputePartition arquivo contendo o lado do pai associado ao lado do filho: fathersides.out\n";
}

using namespace std;

void TPZRefPattern::TPZPartitionFatherSides::Print(TPZGeoMesh &gmesh,std::ostream &out){
  out << "TPZRefPattern::TPZSideTransform::Print partic dos lados do pai pelos lados dos sub-elementos\n\n";
  int iss,iside;//,count=0;
  TPZGeoEl *father = gmesh.ElementVec()[0];/**elemento pai*/
  int nsfat = father->NSides();
  int nnod = father->NNodes();
  int ntot = nsfat-nnod;
  for(iside=0;iside<ntot;iside++){
    out << "\nLado do elemento pai = " << (iside+nnod) << endl;
    int initsideson = fInitSide[iside];
    int lastsideson = fInitSide[iside+1];
    for(iss=initsideson;iss<lastsideson;iss++){/**percorre-se os sub/lado da parti�o*/
      TPZGeoElSideIndex subside = fPartitionSubSide[iss];
      if(!subside.Element(&gmesh)){
        cout <<  "ERRO : Elemento da partic� nulo\n ";
        continue;
      }
      out << "Sub id = " << subside.Element(&gmesh)->Id() << "  Lado do sub " << subside.Side()  << endl;
    }
    out << endl;
  }
}

void TPZRefPattern::TPZPartitionFatherSides::Read(TPZStream &buf){
  TPZSaveable::ReadObjects(buf, this->fInitSide);
  TPZSaveable::ReadObjects(buf, this->fNSubSideFather);
  int i, n;
  buf.Read(&n,1);
  this->fPartitionSubSide.Resize(n);
  for(i = 0; i < n; i++){
    this->fPartitionSubSide[i].Read(buf);
  }
}

void TPZRefPattern::TPZPartitionFatherSides::Write(TPZStream &buf){
  TPZSaveable::WriteObjects(buf, this->fInitSide);
  TPZSaveable::WriteObjects(buf, this->fNSubSideFather);
  int i, n = this->fPartitionSubSide.NElements();
  buf.Write(&n,1);
  for(i = 0; i < n; i++){
    this->fPartitionSubSide[i].Write(buf);
  }
}

void TPZRefPattern::Print1(/*TPZGeoMesh &gmesh,*/std::ostream &out){
  out << "TPZRefPattern::TPZSideTransform::Print lado do pai associados aos lados dos sub-elementos\n\n";
  int iside,isub;
//  int nnod = Element(0)->NNodes();
  int nsubs = NSubElements(); // so dava certo pq era igual ao uniforme
  out << "Refinement Pattern named " << fName << endl;
  for(isub=0;isub<nsubs;isub++){
    TPZGeoEl *sub = Element(isub+1);
    int nsides = sub->NSides();
    for(iside=0;iside<nsides;iside++){
      out << "sub/lado = " << isub << "/" << iside << "  Lado do pai = " << FatherSide(iside,isub)  << endl;
    }
  }
  this->fFatherSides.Print(this->fInternalMesh,out);
  this->fTransforms.Print(this->fInternalMesh,out);
}

/** Determina-se, para todos e cada um dos lados dos sub-elementos, o lado do pai no
 *  qual est�contido. Caso o lado do elemento �igual ao lado do pai asigna-se
 *  o valor -1. Neste caso n�existe depend�cia.
 */
void TPZRefPattern::ComputeTransforms(){
/**calcula transformacoes entre lado de filho e lado de pai*/
//  int ind = 0;
//  int sizemesh = NSubElements()+1;
  TPZGeoEl *fath = Element(0);/**Elemento pai deve ser o primeiro elemento da lista*/
  if(!fath){
    PZError << "TPZRefPattern::ComputePartition Father not exists?!\n";
    exit(-1);
  }
  int isub,nsubs = NSubElements();/**total filhos*/
  /**preenchendo a estrutura TPZFatherSides*/
  int initside=0,cont=0,side,fatside;
  TPZManVector<REAL,3> masscent(3,0.),xpoint(3,0.),fathparam(fath->Dimension(),0.);
  xpoint[0] = 0.;
  xpoint[1] = 0.;
  xpoint[2] = 0.;
  fTransforms.fInitSonSides.Resize(nsubs+1);/** +1 para incluir a posi�o final de fSideFather*/
  int size = SizeOfSubsSides(nsubs);
  fTransforms.fFatherSide.Resize(size);/**vale -1 quando o lado n� �contido propriamente*/
  fTransforms.fSideTransform.Resize(size);
  for(isub=0;isub<nsubs;isub++){
    fTransforms.fInitSonSides[isub] = initside;
    TPZGeoEl *son = Element(isub+1);/**o pai n� sabe quem s� os filhos*/
    //cout << "Tipo de elemento :" << son->Type() << endl;
    int nsides = son->NSides();/**um dos elementos implementados no PZ*/
    //cout << "\n------------------------> ELemento de id = " << son->Id() << endl << endl;
    for(side=0;side<nsides;side++){/**cantos + arestas + faces, o interior n� �compartilhado*/
      TPZGeoElSide elside (son,side);
      //cout << "Tipo do elemento lado: " << elside.NSideNodes() << endl;
      son->CenterPoint(side,masscent);/**percorre todos os lados do elemento filho*/
      son->X(masscent,xpoint);
      fath->ComputeXInverse(xpoint,fathparam);
      //cout << "\nxpoint = " << xpoint[0] << " , " << xpoint[1] << " , " << xpoint[2] << endl << endl;
      fatside = fath->WhichSide(fathparam);/**lado do pai contendo o lado do filho*/
      fTransforms.fSideTransform[cont] = son->ComputeParamTrans(fath,fatside,side);
      //cout << "sub/side -> fath side: " << son->Id() << "/" << side << " -> " << fatside << endl;
      //fTransforms.fSideTransform[cont].Mult().Print(" T ");
      //fTransforms.fSideTransform[cont].Sum().Print(" b ");
      fTransforms.fFatherSide[cont++] = fatside;
      initside++;
    }
  }
  fTransforms.fInitSonSides[isub] = initside;/**posi�o final em fSideFather*/
//  ofstream out("transformacoes.out");
//  fTransforms.Print(*fInternalMesh,out);
//  out.flush();
//  out.close();
//  cout << "\nTPZRefPattern::ComputeTransforms lados do pai asssociados aos subs, fathersides.out\n";
}

void TPZRefPattern::TPZSideTransform::Print(TPZGeoMesh &gmesh,std::ostream &out){
  out << "TPZRefPattern::TPZSideTransform::Print transformacoes parametricas\n\n";
  int isub,iside,count=0;
  int nsubs = gmesh.ElementVec().NElements()-1;/**a malha cont� um elemento pai e filhos*/
  for(isub=0;isub<nsubs;isub++){
    int elid = gmesh.ElementVec()[isub+1]->Id();
    out << "\n>>>>>>>>>>>> Sub-element id = " << elid << " <<<<<<<<<<<< " << endl << endl;/**a informa�o da malha �est�ica*/
    int nsides = gmesh.ElementVec()[isub+1]->NSides();
    for(iside=0;iside<nsides;iside++){/**percorre-se os lados de cada filho*/
      out << "> Sub-element/side = " << elid << "/" << iside << "  Side of father = " << fFatherSide[count] << endl;
      fSideTransform[count].Mult().Print("Transformacao  T :",out);
      fSideTransform[count++].Sum().Print("Vetor b : ",out);
    }
    out << endl;
  }
}

void TPZRefPattern::TPZSideTransform::Read(TPZStream &buf){
  TPZSaveable::WriteObjects(buf, this->fInitSonSides);
  TPZSaveable::WriteObjects(buf, this->fFatherSide);
  int n, i;
  buf.Read(&n,1);
  this->fSideTransform.Resize(n);
  for(i = 0; i < n; i++){
    this->fSideTransform[i].Read(buf);
  }
}

void TPZRefPattern::TPZSideTransform::Write(TPZStream &buf){
  TPZSaveable::WriteObjects(buf, this->fInitSonSides);
  TPZSaveable::WriteObjects(buf, this->fFatherSide);
  int i, n = this->fSideTransform.NElements();
  buf.Write(&n,1);
  for(i = 0; i < n; i++){
    this->fSideTransform[i].Write(buf);
  }
}

int TPZRefPattern::FatherSide(int side, int sub ){
  int nsides = fInternalMesh.ElementVec()[sub+1]->NSides();
  int nsubs = NSubElements();
  if(side<0 || side>nsides ||  sub <0 ||  sub >nsubs){
    PZError << "TPZRefPattern::FatherSide arguments wrong argument\n";
    PZError << "side = " << side << " sub = " << sub;
    return -1;
  }
  int pos = fTransforms.fInitSonSides[sub];
  return ( fTransforms.fFatherSide[pos+side]  );
}

TPZTransform TPZRefPattern::Transform(int side, int sub){
  int nsides = Element(sub+1)->NSides();
  int nsubs = NSubElements();
  if(side<0 || side>nsides ||  sub <0 ||  sub >nsubs){
    PZError << "TPZRefPattern::Transform wrong arguments\n";
    PZError << "side = " << side << " sub = " << sub;
    return TPZTransform(0);
  }
  int pos = fTransforms.fInitSonSides[sub];
  return ( fTransforms.fSideTransform[pos+side]  );
}

void TPZRefPattern::SideNodes(int side, TPZVec<int> &vecnodes){
  /**side �um lado �do pai, �preciso achar todos os n� internos ao lado*/
  TPZGeoEl *father = Element(0);
  int nsdfat = father->NSides();
  int nnod = father->NNodes();
  if(side<0 || side>nsdfat){
    PZError << "TPZRefPattern::SideNodes wrong side, side = " << side << endl;
    vecnodes.Resize(0);
    return;
  }
  if (side < nnod){
    vecnodes.Resize(1);
    vecnodes[0] = Element(0)->NodeIndex(side);
    return ;
  }
  //Aparentemente a estrutura nao contempla os nos...
  side -= nnod;

#ifdef HUGE_DEBUG
if (gDebug == 2){
  cout << "************" << endl;
  cout << fFatherSides.fInitSide << endl;
  cout << "************" << endl;
  cout << fFatherSides.fNSubSideFather << endl;
  cout << "************" << endl;
  int nss = fFatherSides.fPartitionSubSide.NElements()-1;
  for (int i =0; i<nss ;i++){
    cout << "\nsubelement " << i << endl;
    cout << "side " << fFatherSides.fPartitionSubSide[i].Side() << endl;
    if (fFatherSides.fPartitionSubSide[i].Element())
      fFatherSides.fPartitionSubSide[i].Element()->Print(cout);
    else cout <<  "No associated element " << endl;
  }
}
#endif

  int pos = fFatherSides.fInitSide[side];
  int pos2 = fFatherSides.fInitSide[side+1];
  vecnodes.Resize(pos2-pos);/**o nmero de n� no lado �menor que isto*/
  int count = 0;
  for(int par=pos;par<pos2;par++){/**intervalo do lado side*/
    TPZGeoElSide subs = TPZGeoElSide(fFatherSides.fPartitionSubSide[par], &fInternalMesh);//[pos];
    if(!subs.Element()){
      PZError << "TPZRefPattern::NSideSubElements puncture in the partition\n";
      vecnodes.Resize(0);
      return;
    }
//    subs.Element()->Print(cout);
    int sd = subs.Side();
    if(sd < subs.Element()->NNodes()){
      TPZGeoEl *el = subs.Element();
      int node = el->NodeIndex(sd);
      //vecnodes[par-pos] = sd;/**cada n�aparece uma nica ves na partic� do lado*/
      vecnodes[par-pos] = node;
      count++;
    }
  }
  vecnodes.Resize(count);
//  cout << "VecNodes " << vecnodes << endl;
}

int TPZRefPattern::NNodes(){
  return ( fInternalMesh.NodeVec().NElements() );
}

int TPZRefPattern::NSideNodes(int side){
  int nsdfat = Element(0)->NSides();
  if(side<0 || side>nsdfat){
    PZError << "TPZRefPattern::NSideNodes wrong side, side = " << side << endl;
    return -1;
  }
  TPZManVector<int,10> vec;
  SideNodes(side,vec);
  return ( vec.NElements() );
}

int TPZRefPattern::NSubElements(){
  //return ( fInternalMesh->ElementVec().NElements() - 1 );
  return fNSubEl;
}

void TPZRefPattern::SideSubElement(int sidein, int position, int & sub, int & sideout){
  if(sidein<0 || sidein>Element(0)->NSides()){
    PZError << "TPZRefPattern::SideSubElement null side, side = " << sidein << endl;
  }
  //Para contemplar os lados de dimensao 0
/*  if (side < Element(0).NCornerNodes()){
    TPZGeoElSide thisside (Element(0),sidein);
    TPZGeoElSide neighbour = thisside.Neighbour();
    while (neighbour != thisside && neighbour.Exists()){
      sub.Push (neighbour.Element().Id() -1);
      sideout.Push (neighbour.Side());
      neighbour = neighbour.Neighbour();
    }
    return;
  }*/
  int insd = fFatherSides.fInitSide[sidein];
  int insd2 = fFatherSides.fInitSide[sidein+1];
/*
  for (int i = 0; i<fFatherSides.fPartitionSubSide.NElements(); i++){
    if (!fFatherSides.fPartitionSubSide[i].Exists()) cout << "error for element side " << i << endl;
    else cout << "Fathersides.PartitionSubSide " << fFatherSides.fPartitionSubSide[i].Element()->Id() -1
         << " side " << fFatherSides.fPartitionSubSide[i].Side() << endl;
  }
*/
  if(position < 0 || position > (insd2-insd)){/**subs2-subsd �o nmero de sub's do lado*/
     PZError << "TPZRefPattern::SideSubElement wrong position, position = " << position << endl;
     sub = sideout = -1;
     return;
  }
  /**a ordem �determinada pela partic� dos lados do pai, �uma ordem fixa*/
  sub = fFatherSides.fPartitionSubSide[insd].Element(&fInternalMesh)->Id()-1;/**id contemplado como filho*/
  sideout = fFatherSides.fPartitionSubSide[insd].Side();
}

void TPZRefPattern::NSideSubElements(){
  /**procura-se o nmero de sub-elementos da partic�, isto n� �igual ao nmero de
     elementos da partic�*/
  /**side �um lado do pai, �preciso achar o nmero de sub-elementos ligados a este lado*/
  TPZGeoEl *father = Element(0);
  int nsdfat = father->NSides();
  int nnod = father->NNodes();
  fFatherSides.fNSubSideFather.Resize(nsdfat);
  for(int side=0;side<nsdfat;side++){/**percorre-se os lados do pai*/
    if(side<nnod){/**os cantos n� fazem parte da partic�*/
    /*
      TPZGeoElSide fat(Element(0),side),neigh;//elemento pai e seu vizinho
      if(!fat.Element()){
        PZError <<  "TPZRefPattern::NSideSubElements null father\n";
        exit(-1);//radicalizou
      }
      neigh = fat.Neighbour();
      //isso  um crime... pq conta aqui en no conta para os outros lados ??? int count = 1;//o pai est�contado
      int count = 0;
      while(neigh.Element() && neigh.Element()!=fat.Element()){
        neigh = neigh.Neighbour();
        count++;
      }
      if(!neigh.Element()){
        PZError <<  "TPZRefPattern::NSideSubElements null neighbour\n";
        exit(-1);///terrorismo, extremismo
      }
      fFatherSides.fNSubSideFather[side] = count; */
      fFatherSides.fNSubSideFather[side] = 1;
      continue;
    }
    /**arestas, faces e interior: side > nnod*/
    /**tomo todos os elemento distintos da partic� do lado*/
    int sidepos = side-nnod;
    int pos = fFatherSides.fInitSide[sidepos];
    int pos2 = fFatherSides.fInitSide[sidepos+1];
    int size = pos2-pos;
    //    TPZVec<int> subs(size,0);/**tamanho m�imo*/
    //    for(p=pos;p<pos2;p++) subs[p-pos] = fFatherSides.fPartitionSubSide[p].Element()->Id();/**todos positivos > 0*/
    //    for(int i=0;i<size;i++) for(int j=i+1;j<size;j++) if(subs[j]==subs[i]) subs[j] = 0;/**anulando os repetidos*/
    //    int count = 0;
    //    for(int k=0;k<size;k++) if(subs[k]) count++;
    //    fFatherSides.fNSubSideFather[side] = count;
    fFatherSides.fNSubSideFather[side] = size;
  }
}

int TPZRefPattern::NSideSubElements(int side){
  if(side<0 || side>Element(0)->NSides()){
    PZError << "TPZRefPattern::NSideSubElement null side, side = " << side << endl;
    return -1;/**danou-se*/
  }
//  cout << "NSideSubElements " <<  fFatherSides.fNSubSideFather << endl;
  return (fFatherSides.fNSubSideFather[side]);
}


void TPZRefPattern::MeshPrint(){
  ofstream out("meshrefpatt.out");
  cout << "\nTPZRefPattern::Print imprime a malha do padrao de refinamento, arquivo de saida: meshrefpatt.out\n";
  fInternalMesh.Print(out);
  out.flush();
  out.close();
}

/*
TPZGeoEl *TPZRefPattern::CreateGeoEl(int ntype, int mat,TPZVec<int> &nodes,TPZGeoMesh *gmesh, int el){
  int index = -1;
  el = (el == 0) ? ntype : 0;
  switch(ntype) {//tipo de elemento
    case 1:
      return gmesh->CreateGeoElement(EPoint,nodes,mat,index,el);
    case 2://unidimensional ; elg1d =
      return gmesh->CreateGeoElement(EOned,nodes,mat,index,el);
      //return new TPZGeoEl1d(nodes,mat,*gmesh);
      //return;
    case 3://tri�gulo ; elgt2d =
      return gmesh->CreateGeoElement(ETriangle,nodes,mat,index,el);
      //return new TPZGeoElT2d(nodes,mat,*gmesh);
      //return;
    case 4://quadril�ero ; elgq2d
      return gmesh->CreateGeoElement(EQuadrilateral,nodes,mat,index,el);
      //return;
    case 7://tetraedro ; elgt3d =
      return gmesh->CreateGeoElement(ETetraedro,nodes,mat,index,el);
      //return new TPZGeoElT3d(nodes,mat,*gmesh);
      //return;
    case 5://pir�ide ; elgpi3d =
      return gmesh->CreateGeoElement(EPiramide,nodes,mat,index,el);
      //return new TPZGeoElPi3d(nodes,mat,*gmesh);
      //return;
    case 6://prisma ; elgpi3d =
      return gmesh->CreateGeoElement(EPrisma,nodes,mat,index,el);
      //return new TPZGeoElPr3d(nodes,mat,*gmesh);
      //return;
    case 8://cubo ; elgc3d =
      return gmesh->CreateGeoElement(ECube,nodes,mat,index,el);
      //return new TPZGeoElC3d(nodes,mat,*gmesh);
      //return;
    default:
        PZError << "\nTPZRefPattern::CreateGeoEl -> Elemento nao conhecido "
                << ntype << endl << "Good Bye::Program Aborted" << endl;
        exit(-1);
  }
  PZError <<  "\nTPZRefPattern::CreateGeoEl ntype error, ntype = " << ntype << endl;
  PZError << "\nAborted program\n";
  exit(-1);//acabou a festa
  return 0;
}
*/

int TPZRefPattern::SizeOfSubsSides(int ison){/**ison �o nmero do sub-elemento*/
  int nsubs = NSubElements();
  if(ison==nsubs) ison--;
  if(ison < 0 || ison > nsubs-1){
    PZError <<  "TPZRefPattern::SizeOfSubsSides filho nao existe, filho = " << ison << endl;
  }
  int count = 0,isub;
  for(isub=0;isub<nsubs;isub++){
    count += Element(isub+1)->NSides();
    if(isub == ison) return count;
  }
  return 0;
}

int TPZRefPattern::IsFatherNeighbour(TPZGeoElSide fathside,TPZGeoEl *son){
  /**se elementos filho e pai tem um lado em comum eles compartilham a vizinhan�*/
  TPZGeoElSide neighbour = fathside.Neighbour();
  while(neighbour.Element() && neighbour.Element()->Id() != fathside.Element()->Id()){
    if(neighbour.Element()->Id() == son->Id()) return 1;/**elementos pai e filho s� vizinhos*/
    neighbour = neighbour.Neighbour();/**percorre-se a vizinhan� do lado do pai*/
  }
  return 0;//**se n� �vizinho ent� nenhum sub-elemento compartilha esse lado*/
}

void TPZRefPattern::DefinitionOfSizePartition(){
  TPZGeoEl *fat = Element(0);/**elemento pai da divis�*/
  int nsidefat = fat->NSides();
  int nnodes = fat->NNodes();
  int nsides = nsidefat-nnodes;
  fFatherSides.fInitSide.Resize(nsides+1);/**nmero de lados do pai + final*/
  int maxsize = 0,sidefat,sf;
//  int nsubs = NSubElements();
  int size = fTransforms.fFatherSide.NElements();
  fFatherSides.fInitSide[0] = 0;
  for(sf=nnodes;sf<nsidefat;sf++){/**os cantos do pai n� s� particionados*/
    int sd = 0;
    int nsidestot = 0;
    while(sd < size){
      sidefat = fTransforms.fFatherSide[sd];/**percorre fFatherSide: lado do pai contendo lado de filho*/
      if(sidefat == sf) nsidestot++;/**conta todos os lados repetidos igual a sf*/
      sd++;
    }
    maxsize += nsidestot;/**nmero total de lados que particionam os lados do pai (exceto cantos do pai)*/
    fFatherSides.fInitSide[sf-nnodes + 1] = maxsize;/**comeco do pr�imo lado do pai*/
  }
  fFatherSides.fPartitionSubSide.Resize(maxsize);
  /**PARA TESTES*/
//  ofstream out("dimofpartition.out");
//  out << "Valores de fFatherSides.fInitSide[sd]\n\n";
//  for(int sd=0;sd<nsides;sd++){
//    out << "sd : fInitSide[sd] = " << sd << " : " << fFatherSides.fInitSide[sd] << endl;
//  }
//  out << "Tamanho de fPartitionSubSide =  " << maxsize;
//  cout << "\nTPZRefPattern::DefinitionOfSizePartition arquivo da particao: dimofpartition.out\n";
}

TPZGeoEl *TPZRefPattern::Element(int iel){
  int nel = NSubElements()+1;/**filhos mais o pai*/
  if(iel<0 || iel>nel){
    PZError <<  "TPZRefPattern::Element elemento nao existe, elemento de id = " << iel << endl;
  }
  return ( fInternalMesh.ElementVec()[iel]  );
}

int TPZRefPattern::SidePartition(TPZVec<TPZGeoElSide> &gelvec, int side){
  int nsides = Element(0)->NSides();/**nmero de lados do pai*/
  int nnodes = Element(0)->NNodes();
  if(side<nnodes || side>nsides){
    PZError <<  "TPZRefaPattern::SidePartition side error: side = " << side << endl;
    gelvec.Resize(0);
    return 0;
  }
  side -= Element(0)->NNodes();/**n� inclui cantos*/
  int firstpos = fFatherSides.fInitSide[side];/**posic� inicial da partic� do lado*/
  int lastpos = fFatherSides.fInitSide[side+1];/**posic� final da partic� do lado*/
  int size = lastpos-firstpos;
  gelvec.Resize(size);/**tamanho: nmero de elementos da partic� do lado*/
  int pos;
  for(pos = firstpos;pos<lastpos;pos++){
    int pos0 = pos - firstpos;
    gelvec[pos0] = TPZGeoElSide(fFatherSides.fPartitionSubSide[pos], &fInternalMesh);
  }
  return size;/**nmero de elementos da partic� do lado*/;
}

/**verifica as transformac�s do lado do sub-elemento para o lado do pai*/
void TPZRefPattern::TransformationTest(){
  int isub,sd,ip;
  //x1 no filho deformado, x2 no pai deformado
  TPZManVector<REAL> x1(3),pf(3),x2(3),xpf(3,0.);
  REAL weight;
  TPZGeoEl *father = Element(0);/**pai*/
  int dimfatside,fatside,nsides;
  int dimfat = father->Dimension();
  TPZGeoEl *subel;
  int nsubs = NSubElements();
  for(isub=0;isub<nsubs;isub++){
    subel  = Element(isub+1);
    nsides = subel->NSides();
    for(sd=0;sd<nsides;sd++){
      if( sd<subel->NNodes() && IsFatherNeighbour(TPZGeoElSide(father,sd),subel) ) continue;
      int dims = subel->SideDimension(sd);
      int dimsub = subel->Dimension();
      /**regra de integrac� para o espaco param�rico do lado do sub-elemento*/
      TPZIntPoints *rule = subel->CreateSideIntegrationRule(sd,5);
      TPZVec<int> order(dims,5);
      TPZVec<REAL> point(dims,0.),point2(dimsub);
      rule->SetOrder(order);
      for(ip=0;ip<rule->NPoints();ip++){
        /**ponto no espaco param�rico do lado do filho*/
        rule->Point(ip,point,weight);
        TPZTransform sidet(dimsub);/**transformac� unit�ia*/
        if(dims < dimsub){
          sidet = subel->SideToSideTransform(sd,nsides-1);/**transf. no elemento metre*/
       //   TPZTransform told(sidet);
      //    sidet =  subel->SideToElemShapeT(sd);
      //    if(IsNotEqual(sidet,told))
       //     PZError <<  "TPZRefPattern::TransformationTest as transformacoes nao sao iguais -> 1\n\n";
        }
        sidet.Apply(point,point2);//**transformac� para o interior do mestre do sub-elemento*
        subel->X(point2,x1);/**ponto no lado do filho deformado*/
        /**transformac�: espaco param�rico do filho/lado  -> espaco param�rico do pai/lado*/
        fatside = father->WhichSide(x1);/**no elemento mestre do pai, father �o deformado*/;
        dimfatside = father->SideDimension(fatside);
        TPZTransform trans = Transform(sd,isub);/**transforma�o calculada pelo TPZRefPattern*/
        /**------------teste das transforma�es-----------*/
        TPZTransform sdtosd(dims);
        TPZGeoElSide(subel,sd).SideTransform3(TPZGeoElSide(father,fatside),sdtosd);
        if(IsNotEqual(trans,sdtosd)){
          PZError <<  "TPZRefPattern::TransformationTest as transformacoes nao sao iguais -> 2\n\n";
        }
        /**-----------fim teste das transforma�es--------*/
        TPZVec<REAL> pf(dimfatside);
        trans.Apply(point,pf);/**ponto pf no espaco param�rico do lado do pai*/
        TPZTransform sidetf(dimfatside);/**unit�ia do lado do pai*/
        if(dimfatside < dimfat){
          /**para o interior do sub-elemento*/
          sidetf = father->SideToSideTransform(fatside,father->NSides()-1);
          //sidetf =  father->SideToElemShapeT(fatside);
        }
        sidetf.Apply(pf,xpf);/**do espaco param�rico do lado do pai para o interior do pai*/
        father->X(xpf,x2);//ponto no lado do pai deformado
        if( sqrt( (x1[0]-x2[0])*(x1[0]-x2[0]) + (x1[1]-x2[1])*(x1[1]-x2[1]) + (x1[2]-x2[2])*(x1[2]-x2[2]) ) > 1.e-10 ){
          PZError << "\nTransformacao errada\n";
          PZError << "son    = " << (subel->Id()) << endl;
          PZError << "father = " << (father->Id()) << endl;
          PZError << "side   = " << sd << endl << endl;
          int ok;
          cin >> ok;
        } else {
/*           cout << "Transformacao OK!\n"; */
/*           cout << "Filho/lado : " << subel->Id() << "/" << sd << endl; */
/*           cout << "Pai : " << father->Id() << endl << endl; */
        }//fim if sqrt..
      }//fim rule
    }//fim for sd
  }//fim for isub
}

int TPZRefPattern::IsNotEqual(TPZTransform &Told, TPZTransform &Tnew){
  int nrows = Told.Mult().Rows();
  int ncols = Told.Mult().Cols();
  if(Tnew.Mult().Rows()!=nrows || Tnew.Mult().Cols()!=ncols) return 1;
  if(Tnew.Sum().Rows()!=Told.Sum().Rows() || Tnew.Sum().Cols()!=Told.Sum().Cols()) return 1;
  int c,r;
   for(r=0;r<nrows;r++){
     for(c=0;c<ncols;c++){
      if( fabs(Tnew.Mult()(r,c)-Told.Mult()(r,c)) > 1.e-12 ) return 1;
    }
    if( fabs(Tnew.Sum()(r,0)-Told.Sum()(r,0)) > 1.e-12 ) return 1;
  }
  return 0;
}


void TPZRefPattern::CreateNewNodes (TPZGeoEl * gel, TPZVec<int> &newnodeindexes){
  int side;
  int nnodes = gel->NCornerNodes();
  int totalnodes = fInternalMesh.NNodes();
  newnodeindexes.Resize(totalnodes);

  if (gel->HasSubElement()){
    cout << "CreateNewNodes called for an element which is already divided. \n";
    cout.flush();
    return;
// Este trecho nao teria funcionado mesmo. Nada garante que esta ordem seria
// respeitada pelo padrao de refinamento
//    for (side=gel->NCornerNodes();side<gel->NSides();side++){
//      gel->MidSideNodeIndex(side,index);
//      newnodeindexes[side-sum] = index;
//    }
//    return;
  }

  int nsides = gel->NSides();
  //Nao estou mais iterando em i... melhorou??
  for (side = nnodes;side<nsides;side++){
    CreateMidSideNodes(gel,side,newnodeindexes);
  }
}

void TPZRefPattern::CreateMidSideNodes (TPZGeoEl * gel, int side, TPZVec<int> &newnodeindexes){

  int i,j,k,index;
  TPZGeoMesh *gmesh = gel->Mesh();
  //SideNodes retorna um vetor com os indices dos nos internos da malha refpatern
  //com ele eu sei quantos nos internos ou, na linguagem antiga , quantos MidSideNodes tem
  TPZManVector<int> sidenodes;
  SideNodes(side,sidenodes);
  TPZGeoElSide gelside(gel,side);
  TPZGeoElSide neighbour(gelside.Neighbour());
  TPZManVector<int> sideindices(0);
  while(neighbour.Element() && neighbour != gelside) {
    //if(!neighbour.HasSubElement()) {
    if(neighbour.HasSubElement() && neighbour.Element()->NSideSubElements2(neighbour.Side()) > 1) {
      neighbour.Element()->MidSideNodeIndices(neighbour.Side(),sideindices);
      break;
    }
    neighbour = neighbour.Neighbour();
  }
  for (j=0;j<sidenodes.NElements();j++){
    index = sidenodes[j];
    //coordenadas do novo no na malha ref pattern
    TPZVec<REAL> refnodecoord(3,0.);
    TPZManVector<REAL,3> neighbourcoord(3,0.);
    for (k=0;k<3;k++) refnodecoord[k] = fInternalMesh.NodeVec()[index].Coord(k);
    //passando para as coordenadas do elemento da malha real...
    TPZManVector<REAL,3> newnodecoord(Element(0)->Dimension(),0.);
    //coordenada no espaco do elemento mestre do elemento de
    //referencia da malha refpattern
    Element(0)->ComputeXInverse(refnodecoord,newnodecoord);
    //coordenada espacial do no na malha real
    gel->X(newnodecoord,refnodecoord);
    newnodeindexes[index] = -1;
    REAL mindif = -1.;
    int mindifindex = -1;
    //verificar se um vizinho ja criou o no
    for(i=0; i< sideindices.NElements(); i++) {
      for(k=0; k<3; k++) neighbourcoord[k] = gmesh->NodeVec()[sideindices[i]].Coord(k);
      REAL dif = 0.;
      for (k=0;k<3;k++) {
        dif += (refnodecoord[k] - neighbourcoord[k]) * (refnodecoord[k] - neighbourcoord[k]);
      }
      if(mindifindex < 0. || mindif > dif)
      {
    	  mindif = dif;
    	  mindifindex = i;
      }
    }
    if (mindif < 1e-6) {
      newnodeindexes[index] = sideindices[mindifindex];
    }
    if (mindif >= 1.e-6 && sideindices.NElements() != 0)
    {
#ifdef LOG4CXX
    	{
    		std::stringstream sout;
    		sout << "Incompatible refinement patterns detected\n";
    		sout << "Closes node at distance " << mindif << std::endl;
    		gel->Print(sout);
    		LOGPZ_ERROR(logger,sout.str())
    	}
#endif
    	DebugStop();
    }
    if (newnodeindexes[index] == -1) {
      //Caso o no nao exista nos vizinhos sera necessario cria-lo...
      int newindex = gmesh->NodeVec().AllocateNewElement();
      gmesh->NodeVec()[newindex].Initialize(refnodecoord,*gmesh);
      newnodeindexes[index] = newindex;
    }
  }
}
/** Returns the refinement pattern identifier */
string TPZRefPattern::GetName(){
  return fName;
}


/*!
    \fn TPZRefPattern::operator==(const TPZRefPattern &compare)
 */
int TPZRefPattern::operator==(const TPZAutoPointer<TPZRefPattern> compare) const
{
  int nnodes = fInternalMesh.NNodes();
  if(fInternalMesh.NNodes() != compare->fInternalMesh.NNodes() || fInternalMesh.NElements() != compare->fInternalMesh.NElements())
  {
    return 0;
  }
  TPZGeoEl *father = fInternalMesh.ElementVec()[0];
  TPZGeoEl *compfather = compare->fInternalMesh.ElementVec()[0];
  if(father->Type() != compfather->Type())
  {
    return 0;
  }
  int dim = father->Dimension();
//  int nsides = father->NSides();
//  TPZTransform t = father->ComputeParamTrans(compfather,nsides-1,nsides-1);
  std::map<int,int> nodemap;
  int in;
  for(in = 0; in<nnodes; in++)
  {
    TPZManVector<REAL,3> coord(3,0.), coordcompare(3,0.), elparam(dim,0.), compareparam(dim,0.);
    int i;
    for(i=0; i<3; i++) coord[i] = fInternalMesh.NodeVec()[in].Coord(i);
    father->ComputeXInverse(coord,elparam);
//    t.Apply(elparam,compareparam);
//    compfather->X(compareparam,coordcompare);
    int jn;
    TPZManVector<REAL> diff(nnodes,0.);
    for(jn=0; jn<nnodes; jn++)
    {
      int j;
      for(j=0; j<3; j++) coordcompare[j] = compare->fInternalMesh.NodeVec()[jn].Coord(j);
      compfather->ComputeXInverse(coordcompare,compareparam);
      for(j=0 ; j<dim; j++) diff[jn] += (elparam[j]-compareparam[j])*(elparam[j]-compareparam[j]);
      diff[jn] = sqrt(diff[jn]);
      if(diff[jn] < 1.e-8)
      {
        nodemap[in] = jn;
        break;
      }
    }
    if(jn == nnodes)
    {
      return 0;
    }
  }
  int nelem = fInternalMesh.NElements();
  int iel;
  std::map<int,int> elementmap;
  for(iel = 0; iel<nelem; iel++)
  {
    std::set<int> nodeset;
    TPZGeoEl *igel = fInternalMesh.ElementVec()[iel];
    int in, nnode = igel->NNodes();
    for(in=0; in<nnode; in++) nodeset.insert(nodemap[igel->NodeIndex(in)]);
    int jel;
    for(jel=0; jel < nelem; jel++)
    {
      if(elementmap.find(jel) != elementmap.end()) continue;
      std::set<int> compnodeset;
      TPZGeoEl *jgel = compare->fInternalMesh.ElementVec()[jel];
      int jn, jnnode = jgel->NNodes();
      if(jnnode != nnode) continue;
      for(jn=0; jn<jnnode; jn++) compnodeset.insert(jgel->NodeIndex(jn));
      if(nodeset == compnodeset)
      {
        elementmap[jel] = iel;
        break;
      }
    }

    if(jel == nelem)
    {

/*      cout << "node map\n";
      for(in=0; in<nnodes; in++) cout << in << " -> " << nodemap[in] << " | ";
      cout << endl;
      int iel;
      cout << "The mapped element node indices are\n";
      for(iel = 0; iel<nelem; iel++)
      {
        TPZGeoEl *igel = fInternalMesh.ElementVec()[iel];
        int in, nnode = igel->NNodes();
        for(in=0; in<nnode; in++) cout << nodemap[igel->NodeIndex(in)] << ' ';
        cout << std::endl;
      }
      cout << "The compared element node indices are\n";
      for(iel = 0; iel<nelem; iel++)
      {
        TPZGeoEl *igel = compare->fInternalMesh.ElementVec()[iel];
        int in, nnode = igel->NNodes();
        for(in=0; in<nnode; in++) cout << igel->NodeIndex(in) << ' ';
        cout << std::endl;
      }*/

      return 0;
    }
  }
  return 1;
}


    /**
    * Generate a string which may represent the refinement pattern
    */
std::string TPZRefPattern::GenericName()
{
  TPZGeoEl * gel = fInternalMesh.ElementVec()[0];
  if(!gel) return "noname";
  std::stringstream result;
  result << gel->TypeName();
  int nsides = gel->NSides();
  int nnodes = gel->NNodes();
  result << ":";
  int is;
  for(is=nnodes; is<nsides; is++)
  {
    result << this->NSideNodes(is) << ":";
  }
  return result.str();
}

    /**
    *  Automatically generate all permuted partitioned
    */
void TPZRefPattern::GeneratePermuted(TPZGeoEl *gel)
{
  if (!gel){
    PZError << "Error at " << __PRETTY_FUNCTION__ << " at line " << __LINE__ << " gel is NULL\n";
    return;
  }
  MElementType geltype = gel->Type();
  if(fPermutations.count(geltype)) return;
  TPZGeoMesh *gelmesh = gel->Mesh();
  TPZGeoMesh gmesh;
  gmesh.NodeVec().Resize(gel->NNodes());
  int in,nnodes;
  nnodes = gel->NNodes();
  for(in=0; in<nnodes; in++)
  {
    gmesh.NodeVec()[in].Initialize(gelmesh->NodeVec()[gel->NodeIndex(in)],gmesh);
  }
  TPZGeoEl *gelp;
  TPZIntPoints *integ = gel->CreateSideIntegrationRule(gel->NSides()-1,3);
  TPZManVector<int,8> nodes(nnodes),nodesperm(nnodes);
  for(in=0; in<nnodes; in++)
  {
    nodes[in]=in;
  }
  int matid = gel->MaterialId();
  TPZPermutation permute(nnodes);
  TPZTransform trans(gel->Dimension());
  TPZRefPatternPermute refpermute;

  refpermute.fPermute = permute;
  refpermute.fTransform = trans;
  fPermutations[gel->Type()].push_back(refpermute);
  permute++;
  while(!permute.IsFirst())
  {
    permute.Permute(nodes,nodesperm);
    int index;
    gelp = gmesh.CreateGeoElement(gel->Type(),nodesperm,matid,index,0);
    int dim = gel->Dimension();
    TPZManVector<REAL,3> point(dim,0.);
    REAL w;
    int npoint = integ->NPoints();
    int ip;
    bool valid = true;
    for(ip=0; ip<npoint; ip++)
    {
      integ->Point(ip,point,w);
      TPZFNMatrix<9> jac(dim,dim),jacinv(dim,dim),axes(3,3);
      REAL detjac,detjac2;
      gelp->Jacobian(point,jac,axes,detjac,jacinv);
      gel->Jacobian(point,jac,axes,detjac2,jacinv);
      if(fabs(fabs(detjac)-fabs(detjac2)) > 1.e-10)
      {
        valid = false;
        break;;
      }
    }
    if(valid)
    {
//       cout << " element type " << gel->Type() << " nodesperm " << nodesperm << endl;
      TPZRefPatternPermute candidate;
      candidate.fPermute = permute;
      candidate.fTransform = gel->ComputeParamTrans(gelp,gel->NSides()-1,gel->NSides()-1);
      fPermutations[gel->Type()].push_back(candidate);
    }
    permute++;
  }

  delete integ;
}

    /**
     *  Generate all permuted partitions and insert them in the mesh
     */
void TPZRefPattern::InsertPermuted(/*TPZGeoMesh &gmesh*/)
{
  if(!fInternalMesh.ElementVec().NElements() || !fInternalMesh.ElementVec()[0]) return;

  TPZGeoEl *gel = fInternalMesh.ElementVec()[0];
  GeneratePermuted(gel);
  MElementType geltype = gel->Type();
  std::list<TPZRefPatternPermute> &permlist = fPermutations[geltype];
  std::list<TPZRefPatternPermute>::iterator it;
  fPermutedRefPatterns.resize(permlist.size());
  int counter;
  for(it=permlist.begin(),counter=0; it != permlist.end(); it++,counter++)
  {
    TPZAutoPointer<TPZRefPattern> refp(new TPZRefPattern(*this,(*it).fPermute));
    TPZAutoPointer<TPZRefPattern> found = this->fOwnerMesh->FindRefPattern(refp);
    if(found)
    {
      fPermutedRefPatterns[counter] = found->Id();
    }
    else
    {
      //refp->Print();
      this->fOwnerMesh->InsertRefPattern(refp);
      fPermutedRefPatterns[counter] = refp->Id();
      refp->ShortPrint(std::cout);
      std::cout << std::endl;
      refp->InsertPermuted();
    }
  }
  GenerateSideRefPatterns(/*gmesh*/);
}

void TPZRefPattern::PermuteMesh(const TPZPermutation &permute){
  int in;
  TPZGeoEl *father = this->fInternalMesh.ElementVec()[0];
  int nn = father->NNodes();
  TPZVec<int> nodes(nn), nodeperm(nn);
  for(in=0; in<nn; in++){
    nodes[in] = father->NodeIndex(in);
  }
  permute.Permute(nodes,nodeperm);
  for(in=0; in<nn; in++){
    father->SetNodeIndex(in, nodeperm[in]);
  }
  fInternalMesh.ResetConnectivities();
  fInternalMesh.BuildConnectivity();
}

    /**
    * Generate the refinement patterns associated with the sides of the father element
    */
void TPZRefPattern::GenerateSideRefPatterns(/*TPZGeoMesh &gmesh*/)
{
  if(fSideRefPattern.NElements()) return;
  if(!fInternalMesh.ElementVec().NElements()) return;
  TPZGeoEl *gel = fInternalMesh.ElementVec()[0];
  int nsides = gel->NSides();
  fSideRefPattern.Resize(nsides,0);
  fSideRefPattern[nsides-1] = this->Id();
  int is;
  for(is=0; is<nsides-1; is++)
  {
    if(gel->SideDimension(is) == 0) continue;
    if(NSideSubElements(is) == 1) continue;
    TPZAutoPointer<TPZRefPattern> sideref(new TPZRefPattern(this->fOwnerMesh));
    BuildSideMesh(is, sideref->fInternalMesh);
    sideref->fNSubEl = sideref->fInternalMesh.NElements()-1;
    sideref->ComputeTransforms();/**calcula as transforma�es entre filhos e pai*/
    sideref->ComputePartition();/**efetua a parti�o do elemento pai de acordo com os lados dos */
    sideref->fName = sideref->GenericName();
    TPZAutoPointer<TPZRefPattern> found = this->fOwnerMesh->FindRefPattern(sideref);
    if(!found.operator ->())
    {
      sideref->GenerateSideRefPatterns(/*gmesh*/);
      this->fOwnerMesh->InsertRefPattern(sideref);
      sideref->InsertPermuted(/*gmesh*/);
      fSideRefPattern[is] = sideref->Id();
    }
    else
    {
      fSideRefPattern[is] = found->Id();
    }
  }
}

  /**
   *  build a geometric mesh associated with the side of the refinement pattern
   */
void TPZRefPattern::BuildSideMesh(int side, TPZGeoMesh &SideInternalMesh)
{
  if(!fInternalMesh.ElementVec().NElements()) return;
  TPZGeoEl *gel = fInternalMesh.ElementVec()[0];
  TPZStack<int> allsides;
  std::map<int,int> allsidenodes;
  int count =0;
  gel->LowerDimensionSides(side,allsides);
  allsides.Push(side);
  int s;
  for(s=0; s<allsides.NElements(); s++)
  {
    TPZStack<int> sidenodes;
    SideNodes(allsides[s],sidenodes);
    int t;
    for(t=0; t<sidenodes.NElements(); t++)
    {
      if(!allsidenodes.count(sidenodes[t])) allsidenodes[sidenodes[t]] = count++;
    }
  }
  SideInternalMesh.NodeVec().Resize(allsidenodes.size());
  std::map<int,int>::iterator it;
  for(it=allsidenodes.begin(); it!= allsidenodes.end(); it++)
  {
    int nodeorig = (*it).first;
    int nodedest = (*it).second;
    SideInternalMesh.NodeVec()[nodedest].Initialize(fInternalMesh.NodeVec()[nodeorig],SideInternalMesh);
  }
  TPZStack<int> nodeindices;
  nodeindices.Resize(gel->NSideNodes(side));
  int in;
  for(in=0; in<nodeindices.NElements(); in++)
  {
    nodeindices[in] = allsidenodes[gel->SideNodeIndex(side,in)];
  }
  int matid = gel->MaterialId();
  int index;
  TPZGeoEl *father = SideInternalMesh.CreateGeoElement(gel->Type(side),nodeindices,matid,index,-1);
  int sidedim = father->Dimension();
  TPZStack<TPZGeoElSide> gelvec;
  SidePartition(gelvec, side);
  int nsub = gelvec.NElements();
  int subel;
  for(subel=0; subel<nsub; subel++)
  {
    if(gelvec[subel].Dimension() != sidedim) continue;
    nodeindices.Resize(gelvec[subel].NSideNodes());
    for(in=0; in<nodeindices.NElements(); in++)
    {
      nodeindices[in] = allsidenodes[gelvec[subel].SideNodeIndex(in)];
    }
    MElementType type = gelvec[subel].Element()->Type(gelvec[subel].Side());
    TPZGeoEl *subel = SideInternalMesh.CreateGeoElement(type,nodeindices,matid,index);
    subel->SetFather(father);
  }
  SideInternalMesh.BuildConnectivity();
//  gmesh.Print(std::cout);
}

    /**
     * Find the side refinement pattern corresponding to the parameter transformation
     */
TPZAutoPointer<TPZRefPattern> TPZRefPattern::SideRefPattern(int side, TPZTransform &trans)
{
  if(side >= fSideRefPattern.NElements()) return NULL;
  TPZAutoPointer<TPZRefPattern> sideref = this->SideRefPattern(side);
  TPZAutoPointer<TPZRefPattern> zero;
  if(!sideref) return zero;
  return sideref->FindRefPattern(trans);
}

    /**
     * Find the refinement pattern corresponding to the give transformation
     */
 TPZAutoPointer<TPZRefPattern> TPZRefPattern::FindRefPattern(TPZTransform &trans)
 {
   REAL tol = 1.e-6;
   if(!fInternalMesh.ElementVec().NElements() || ! fInternalMesh.ElementVec()[0]) return 0;
   MElementType type = fInternalMesh.ElementVec()[0]->Type();
   int count;
   std::list<TPZRefPatternPermute> &permlist = fPermutations[type];
   std::list<TPZRefPatternPermute>::iterator it;
   for(it = permlist.begin(), count = 0; it != permlist.end(); it++,count++)
   {
     TPZRefPatternPermute &tmp = (*it);
     if(!tmp.fTransform.Compare(trans,tol))
     {
       const int side = this->fInternalMesh.ElementVec()[0]->NSides() - 1;
       const int id = fPermutedRefPatterns[count];
       return this->FindRefPattern(id, side);
     }
   }
   return 0;
 }

/**
 * build a list of all refinement patterns compatible with the refinements of the neighbouring elements
 */
void TPZRefPattern::GetCompatibleRefinementPatterns(TPZGeoEl *gel, std::list<TPZAutoPointer<TPZRefPattern> > &refs)
{
  if(!gel) return;
  refs.clear();
  if(gel->HasSubElement())
  {
    refs.push_back(gel->GetRefPattern());
    return;
  }
  // first we build the refinement patterns associated with the neighbours of the current element
  int is,nsides,nnodes;
  nsides = gel->NSides();
  nnodes = gel->NCornerNodes();
  TPZManVector<TPZAutoPointer<TPZRefPattern> ,27> SideRefPatterns(nsides,0);
  TPZManVector<int, 27> refsides(nsides,0);
  for(is=nnodes; is<nsides; is++)
  {
    TPZGeoElSide gelside(gel,is);
    TPZGeoElSide neigh = gelside.Neighbour();
    while(neigh != gelside)
    {
      if(neigh.Element()->HasSubElement() && neigh.NSubElements2() > 1)
      {
        refsides[is] = 1;
        TPZAutoPointer<TPZRefPattern> refp = neigh.Element()->GetRefPattern();
        if(refp)
        {
//          TPZTransform trans = gelside.NeighbourSideTransform(neigh);
          TPZTransform trans = neigh.NeighbourSideTransform(gelside);
          SideRefPatterns[is] = refp->SideRefPattern(neigh.Side(),trans);
          break;
        }
      }
      neigh=neigh.Neighbour();
    }
  }
  /*
  for(is = nnodes; is<nsides; is++)
  {
    if(gel->SideDimension(is) == 2)
    {
      if(SideRefPatterns[is])
      {
        cout << gel->TypeName() << " for side " << is << " local side ref ";
        TPZStack<int> smallsides;
        gel->LowerDimensionSides(is,smallsides);
        int ils;
        for(ils=0; ils<smallsides.NElements(); ils++)
        {
          if(refsides[smallsides[ils]]) cout << ils << ' ';
        }
        cout << endl << "Side ref pattern ";

        SideRefPatterns[is]->ShortPrint(cout); cout << endl;
      }
    }
  }
  */
  // having the refinement patterns associated with the sides, look for compatible refinement patterns
  std::map<int, TPZAutoPointer<TPZRefPattern> > reflist = gel->Mesh()->RefPatternList(gel->Type());
  std::map<int, TPZAutoPointer<TPZRefPattern> >::iterator it;
  for(it=reflist.begin(); it != reflist.end(); it++)
  {
    // compare the side refinement patterns
    for(is=nnodes; is<nsides-1; is++)
    {
      TPZAutoPointer<TPZRefPattern> candidate = it->second->SideRefPattern(is);
      if(SideRefPatterns[is] && SideRefPatterns[is] != candidate)
      {
        break;
      }
    }
    // if all refinement patterns are equal
    if(is == nsides-1) refs.push_back(it->second);
  }

}

void TPZRefPattern::ShortPrint(std::ostream &out)
{
      TPZGeoEl *elemento = Element(0);
      int nsides = elemento->NSides();
      TPZVec<int> indices;
      //TPZVec<int> selected(nsides,0);
      out << elemento->TypeName();
      out << " Id " << fId << " Sides " ;
      for (int p=0 ; p<nsides; p++){
        if (elemento->SideDimension(p)==1 && NSideNodes(p))
        {
             out << p << " ";
        }
       }
}

TPZAutoPointer<TPZRefPattern> TPZRefPattern::SideRefPattern(int side){
  const int id = this->fSideRefPattern[side];
  return this->FindRefPattern(id, side);
}

TPZAutoPointer<TPZRefPattern>  TPZRefPattern::FindRefPattern(int id, int side){
  TPZGeoEl * gel = this->fInternalMesh.ElementVec()[0];
  const std::map<int, TPZAutoPointer<TPZRefPattern> > & mymap = this->fOwnerMesh->RefPatternList(gel->Type(side));
  std::map<int, TPZAutoPointer<TPZRefPattern> >::const_iterator it = mymap.find(id);
  if (it != mymap.end()) return it->second;
  else return NULL;
}

void TPZRefPattern::Read(TPZStream &buf){
  this->fFatherSides.Read(buf);
  buf.Read(&this->fFileRefPatt, 1);
  buf.Read(&this->fId, 1);
  this->fInternalMesh.Read(buf, NULL);
  buf.Read(&this->fName, 1);
  buf.Read(&this->fNSubEl, 1);
  //fPermutations is a static attribute so it is not transmitted
  TPZSaveable::ReadObjects(buf, this->fPermutedRefPatterns);
  TPZSaveable::ReadObjects(buf, this->fSideRefPattern);
}

void TPZRefPattern::Write(TPZStream &buf){
  this->fFatherSides.Write(buf);
  buf.Write(&this->fFileRefPatt, 1);
  buf.Write(&this->fId, 1);
  this->fInternalMesh.Write(buf, 0);
  buf.Write(&this->fName, 1);
  buf.Write(&this->fNSubEl, 1);
  //fPermutations is a static attribute so it is not transmitted
  TPZSaveable::WriteObjects(buf, this->fPermutedRefPatterns);
  TPZSaveable::WriteObjects(buf, this->fSideRefPattern);
}

static TPZAutoPointer<TPZRefPattern> GetBestRefPattern(TPZVec<int> &sides, std::list<TPZAutoPointer<TPZRefPattern> > &patlist)
{
  std::list<TPZAutoPointer<TPZRefPattern> >::iterator it;
  for(it = patlist.begin(); it != patlist.end(); it++)
  {
    if(! (*it)) continue;
    TPZGeoEl *gel = (*it)->Element(0);
    int ncorners = gel->NCornerNodes();
    int nsides = gel->NSides();
    int is;
    for(is = ncorners; is<nsides; is++)
    {
      if(sides[is] != (*it)->NSideNodes(is)) break;
    }
    if(is == nsides) return (*it);
  }
  return 0;
}


void TPZRefPattern::RefineDirectional(TPZGeoEl *gel,std::set<int> &matids)
{
  if(gel->HasSubElement()) return;
  int matid = gel->MaterialId();
  if(matids.count(matid)) return;
  TPZManVector<int,27> sidestorefine(gel->NSides(),0);
  TPZManVector<int,27> cornerstorefine(gel->NSides(),0);
  // look for corners which are on the boundary
  int in;
  int numrefribs = 0;
  for(in=0; in<gel->NCornerNodes(); in++)
  {
    TPZGeoElSide gels(gel,in);
    TPZGeoElSide neigh(gels.Neighbour());
    while(gels != neigh)
    {
      if(matids.count(neigh.Element()->MaterialId()))
      {
        cornerstorefine[in] = 1;
        break;
      }
      neigh = neigh.Neighbour();
    }
  }
  // look for ribs which touch the boundary but which do no lay on the boundary
  int is;
  for(is=gel->NCornerNodes(); is<gel->NSides(); is++)
  {
    // we are only interested in ribs
    if(gel->SideDimension(is) != 1) continue;

    // the side is a candidate if it contains a corner which is neighbour of the boundary condition
    if(cornerstorefine[gel->SideNodeLocIndex(is,0)] || cornerstorefine[gel->SideNodeLocIndex(is,1)])
    {
      sidestorefine[is] = 1;
      numrefribs++;
      TPZGeoElSide gels(gel,is);
      TPZGeoElSide neigh(gels.Neighbour());
      while(neigh != gels)
      {
        // if this condition is true the rib lies on the boundary
        if(matids.count(neigh.Element()->MaterialId()))
        {
          sidestorefine[is] = 0;
          numrefribs--;
          break;
        }
        neigh = neigh.Neighbour();
      }
    }
  }
  if(!numrefribs)
  {
    return;
  }
//  TPZGeoMesh *gmesh = gel->Mesh();
  std::list<TPZAutoPointer<TPZRefPattern> > patlist;
  TPZRefPattern::GetCompatibleRefinementPatterns(gel, patlist);
  TPZAutoPointer<TPZRefPattern> patt = GetBestRefPattern(sidestorefine,patlist);
  static int count = 1;
  if(patt)
  {
    gel->SetRefPattern(patt);
    TPZManVector<TPZGeoEl *> subel;
    gel->Divide(subel);
    //std::cout << "-";
  }
  else
  {
    if(count++ == 1) std::cout << "couldnt find a suitable refinement pattern\n";
    std::cout << "|";
    std::ofstream arquivo ("NotListedPatterns.txt",std::ios::app);
    std::list<TPZAutoPointer<TPZRefPattern> >::iterator it;
    arquivo << "Compatible refinement patterns\n";
    for(it=patlist.begin(); it!=patlist.end(); it++)
    {
      (*it)->ShortPrint(arquivo); arquivo << (void*) (it->operator->()); arquivo << endl;
    }
    arquivo << std::endl;
    arquivo << "Element Type :" << gel->Type() << std::endl;
    arquivo << "Sides selected for refinement :" << std::endl;
    int i;
    for (i=0 ; i<gel->NSides() ; i++){
      if(cornerstorefine[i] == 1)
      {
        arquivo << " " << i << " ";
      }
      if (sidestorefine[i] == 1) {
        arquivo << " " << i << " " ;
      }
    }
    gel->Print(arquivo);
    int in;
    arquivo << std::endl;
    arquivo << "Neighbouring information \n";
    for(in=0; in<gel->NSides(); in++)
    {
      arquivo << "Side : " << in << " ";
      TPZGeoElSide gels(gel,in);
      arquivo << "Dim " << gels.Dimension() << " ";
      TPZGeoElSide neigh(gels.Neighbour());
      while(gels != neigh)
      {
        if(matids.count(neigh.Element()->MaterialId()))
        {
          arquivo << neigh.Element()->Id() << "-l-" << neigh.Side() << " ";
          if (neigh.Side() == 9 && gel->Type() == ETetraedro) {
            arquivo << "Teje pego meliante..." << std::endl;
            neigh.Element()->Print(arquivo);
          }
        }
        neigh = neigh.Neighbour();
      }
      arquivo << std::endl;
    }
    arquivo << std::endl;

    arquivo << "Element information : " << gel->Index() << std::endl;
    arquivo << "Vizinhos dos lados marcados para refinamento:" << std::endl;
    for (i=0 ; i<gel->NSides() ; i++){
      if(cornerstorefine[i] == 1 || sidestorefine[i] == 1)
      {
        TPZGeoElSide gelside (gel,i);
        TPZGeoElSide neigh = gelside.Neighbour();
        while (neigh != gelside)
        {
          arquivo << "*********** my side = " << i << " neighside " << neigh.Side() << std::endl;
          neigh.Element()->Print(arquivo);
          neigh = neigh.Neighbour();
        }
      }
    }
    arquivo << std::endl << std::endl << std::endl << std::endl;
    // Here we will provide the necessary information to develop a new ref. patt.
  }
  count++;
  if(!(count%20))
  {
    std::cout << count << std::endl;
  }

  return;
}

