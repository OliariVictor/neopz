/* Generated by Together */

#ifndef TPZMGANALYSIS_H
#define TPZMGANALYSIS_H

#include "pzanalysis.h"

class TPZTransfer;
class TPZInterpolatedElement;
class TPZTransform;
class TPZStepSolver;

template<class T, class V>

class TPZAvlMap;
class TPZOneDRef;
class TPZGeoEl;


/**
 * Class TPZMGAnalysis derived from TPZAnalysis
 * implements multigrid analysis
 * @ingroup Analysis
 */
class TPZMGAnalysis : public TPZAnalysis {
 public:
  /**
   * Refinement Pattern store struct
   */
  struct TPZRefPattern {
    int fId[3]; 	//Subelements connectivities ids
    int fp[2];		//subelements p-order refinement
    int fh[2];		//subelements h-order refinement
    REAL fhError;	//pure h-refinement error
    REAL fError;        //minimal error
  };
  
  /**
   * Destructor
   */
  virtual ~TPZMGAnalysis();
  
  /**
   * Creates an object multigrid analysis
   * giving a computational mesh
   */
  TPZMGAnalysis (TPZCompMesh *);
  
  /**
   * Append a mesh to the meshes vector
   */
  void AppendMesh (TPZCompMesh * mesh);
  
  /**
   * Pop the last mesh of the meshes vector
   */
  TPZCompMesh *PopMesh ();
  
  /**
   * Uses fSolver object to apply a solution
   * algorithm
   */
  virtual void Solve ();
  
  /**
   * Loads the last two solutions and
   * call the error between these two aproximations
   */
  void ComputeError (TPZVec<REAL> &error);
  
  /**
   * Validation routines
   */
  static int main ();
  
  /**
   * Proceeds the uniformly h-p refinement of mesh\
   */
  static TPZCompMesh *UniformlyRefineMesh (TPZCompMesh *mesh);
  
  /**
   * Evaluates the error between aproximation
   * of coarse and fine meshes
   * @param fine - refined mesh
   * @param coarse - some father mesh of fine
   * @param ervec	- will return the calculated element error
   * @param f - ??
   * @param loc - ??
   * @param val - ??
   * @param trueerv -calculates the true error between a giving a solution
   */
  static  void MeshError (  TPZCompMesh *fine,TPZCompMesh *coarse,	
			    TPZVec<REAL> &ervec,
			    void (*f) (TPZVec<REAL> &loc,
				       TPZVec<REAL> &val,
				       TPZFMatrix &deriv),
			    TPZVec<REAL> &truervec);
  
  /**
   * Return the computational the optimal h-p refined mesh
   * @param fine - uniformly refined mesh
   * @param coarse - some father mesh of fine
   * @param totalerror	- will return the calculated mesh error
   * @param totaltrueerror - if some exact solution is available
   * @effect - efectivity of the error estimator
   */
  TPZCompMesh *RefinementPattern (  TPZCompMesh *fine,TPZCompMesh *coarse,
				    REAL &totalerror,REAL &totaltruerror,
				    TPZVec<REAL> &effect);
  
 private:    
  /**
   * Contains the computational meshes of one cycle
   */
  TPZStack < TPZCompMesh * > fMeshes;
  
  /**
   * Contains the meshes solutions
   */	
  TPZStack <TPZFMatrix *> fSolutions;
  
  /**
   * Contains the solution method applied to the mesh
   */
  TPZStack <TPZMatrixSolver *> fSolvers;
  
  /**
   * Contains the preconditioner of the solution method
   * if the solution method is a krylov method, the preconditioner
   * can be used as a coarse grid iteration
   */
  TPZStack <TPZMatrixSolver *> fPrecondition;

  /**
   * Sort the vector val, storing the permutation vector in perm
   */
  static void Sort (TPZVec<REAL> &val, TPZVec<int> &perm);
  
  static void HeapSort (TPZVec<REAL> &sol, TPZVec<int> &perm);

  /**
   * Create an refined computational mesh based on model
   * and in  the geometric elements to be refined with porders
   * @param model: model computational mesh
   * @param gel: geometric elements vector to be refined
   * @param porders: p order to the elements from gel
   */
  static TPZCompMesh *CreateCompMesh (	TPZCompMesh *model,
					TPZVec<TPZGeoEl *> &gel,
					TPZVec<int> &porders);
  
  /**
   * Call the methods to analyse the error of each element
   * @param f: object to ond dimensional h-p refinement analysis
   * @param cint: element to be analysed
   * @param subs: will return the subelements
   * @param porders: will return the calculated porders
   */
  static void AnalyseElement (	TPZOneDRef &f, TPZInterpolatedElement *cint,
				TPZStack<TPZGeoEl *> &subs, TPZStack<int> &porders);
  
  /**
   * Computes the p-orders of all sub-elements acording to the proposed refinement patterns along the edges
   * @param refpat (input): a vector specifying the proposed refinement patterns along the edges
   * @param cornerids (input): ids of the corners of the element
   * @param porders (output) : order of refinement of the elements ordered by the corner ids
   * @param originalp (input) : order of interpolation of the element which will be refined
   * This method will be extended in the future to indicate which refinement pattern would be most appropriate
   */
  static void DeduceRefPattern (TPZVec<TPZRefPattern> &refpat, TPZVec<int> &cornerids, TPZVec<int> &porders, int originalp);
  
  /**
   * Calculates an element error based on two aproximations
   * @param fine: refined mesh;
   * @param coarse: some father mesh of fine;
   * @param tr: tranformation between fine and coarse;
   * @param f: ??
   * @param loc: ??
   * @param val: ??
   * @param deriv: ??
   * @param truerror: will return the error between aproximation and a give solution
   */
  static  REAL ElementError (TPZInterpolatedElement *fine,
			     TPZInterpolatedElement *coarse,
			     TPZTransform &tr,
			     void (*f) (TPZVec<REAL> &loc,
					TPZVec<REAL> &val,
					TPZFMatrix &deriv),
			     REAL &truerror);
  
  //   TPZStepSolver *fIterative;
  //   TPZMatrixSolver *fPrecond;
};
#endif //TPZMGANALYSIS_H
