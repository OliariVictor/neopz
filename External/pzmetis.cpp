/**
 * @file
 * @brief Contains the implementation of the TPZMetis methods. 
 */
// Generated by Together

#include "pzmetis.h"


#ifdef USING_METIS
#include <math.h>
extern "C" {
#include "metis.h"
};
#endif

#include "pzlog.h"

#ifdef LOG4CXX
static LoggerPtr logger(Logger::getLogger("pz.metis"));
#endif


#include <iostream>
using namespace std;

TPZMetis::TPZMetis(int NElements, int NNodes) : TPZRenumbering(NElements,NNodes)
{
}


void TPZMetis::Print(std::ostream &out,char * title) {

 int nel = fElementGraphIndex.NElements()-1;
 int el;
 out << title;
 out << "\nTPZMetis::Print fNElements = " << fNElements << " fNNodes = " << fNNodes << endl;
 for (el=0;el<nel;el++) {
  int firstindex = fElementGraphIndex[el];
  int lastindex = fElementGraphIndex[el+1];
  int index;
  out << "Element number " << el << " : ";
  for (index=firstindex;index<lastindex;index++) {
   out << fElementGraph[index] << " ";
  }
  out << endl;
 }
 TPZVec<int> nodegraph(0),nodegraphindex(0);
 ConvertGraph(fElementGraph,fElementGraphIndex,nodegraph,nodegraphindex);
 int numelnodegraph = nodegraphindex[fNNodes];
 if (numelnodegraph == nodegraph.NElements() ) {
  nodegraph.Resize(numelnodegraph+1);
 }
 int nod;
 for (nod = numelnodegraph; nod>0; nod--) nodegraph[nod] = nodegraph[nod-1];
 for (el=0;el<fNNodes;el++) {
  int firstindex = nodegraphindex[el];
  int lastindex = nodegraphindex[el+1];
  int index;
  out << "Node number " << el << " : ";
  for (index=firstindex;index<lastindex;index++) {
   out << nodegraph[index+1] << " ";
  }
  out << endl;
 }
}

void TPZMetis::Print(std::ostream &out) {

 // 	int nel = fElementGraphIndex.NElements()-1;
 int el;
 out << fNNodes << std::endl;
 /*   for(el=0;el<nel;el++) {
    	int firstindex = fElementGraphIndex[el];
    	int lastindex = fElementGraphIndex[el+1];
       int index;
       for(index=firstindex;index<lastindex;index++) {
       	if(fElementGraph[index] == index) continue;//o atual n�o deve aparecer
       	out << (fElementGraph[index]+1) << " ";
       }
       out << endl;
    } */
 TPZVec<int> nodegraph(0),nodegraphindex(0);
 ConvertGraph(fElementGraph,fElementGraphIndex,nodegraph,nodegraphindex);
 int numelnodegraph = nodegraphindex[fNNodes];
 if (numelnodegraph == nodegraph.NElements() ) {
  nodegraph.Resize(numelnodegraph+1);
 }
 int nod;
 for (nod = numelnodegraph; nod>0; nod--) nodegraph[nod] = nodegraph[nod-1];
 for (el=0;el<fNNodes;el++) {
  int firstindex = nodegraphindex[el];
  int lastindex = nodegraphindex[el+1];//come�o do pr�ximo
  int index;
  for (index=firstindex;index<lastindex;index++) {
   out << (nodegraph[index+1]+1) << " ";
  }
  out << endl;
 }
}

void TPZMetis::Resequence(TPZVec<int> &perm, TPZVec<int> &inverseperm){
 TPZVec<int> nodegraph(0),nodegraphindex(0);
 ConvertGraph(fElementGraph,fElementGraphIndex,nodegraph,nodegraphindex);
 int numelnodegraph = nodegraphindex[fNNodes];
 if (numelnodegraph == nodegraph.NElements() ) {
  nodegraph.Resize(numelnodegraph+1);
 }
 int nod;
 for (nod = numelnodegraph; nod>0; nod--) nodegraph[nod] = nodegraph[nod-1];
 perm.Resize(fNNodes);
 inverseperm.Resize(fNNodes);
for (nod=0;nod<fNNodes;nod++) {perm[nod] = inverseperm[nod] = nod;}
#ifdef USING_METIS
 int numflag = 0;
 int options = 0;
 METIS_NodeND(&fNNodes,&nodegraphindex[0],&nodegraph[1],&numflag,&options,&perm[0],&inverseperm[0]);
#endif
}

void TPZMetis::Subdivide(int nParts,
          TPZVec < int > & Domains)
{
	TPZManVector<int> Adjacency,AdjacencyWeight,AdjacencyIndex;
	ConvertToElementoToElementGraph(fElementGraph,fElementGraphIndex,Adjacency,AdjacencyWeight,AdjacencyIndex);

#ifdef LOG4CXX
	{
		std::stringstream sout;
		TPZRenumbering::Print(Adjacency,AdjacencyIndex,"Element to element graph",sout);
		LOGPZ_DEBUG(logger,sout.str())
	}
#endif
  int nVertices = AdjacencyIndex.NElements() -1;
  TPZVec<int> Options(5);
  Options.Resize(5);
  Options[0]=0;
//  int CommVolume = 0;
  TPZVec<int> partIndex(nVertices);
  partIndex.Resize(nVertices);
	Domains.Resize(nVertices);
//	TPZVec<int> Partition(nVertices);

//  int lStyle = 0;
//  int lWeigth = 0;
#ifdef USING_METIS
    int flag1 = 0;
    int flag2 = 0;
	int nEdgesCutted = 0;
    int nbalance = 1;
#ifdef METIS_5
	METIS_PartGraphRecursive(&nVertices, &AdjacencyIndex[0], &Adjacency[0], NULL, &AdjacencyWeight[0], &flag1,
														&flag2, &nParts, NULL, NULL, Options, &nEdgesCutted, &Domains[0]);
#else
	METIS_PartGraphRecursive(&nVertices, &AdjacencyIndex[0], &Adjacency[0], NULL, &AdjacencyWeight[0], &flag1,
                             &flag2, &nParts, Options, &nEdgesCutted, &Domains[0]);
#endif
#else
    DebugStop();
#endif

#ifdef USING_METIS2
	/*
  METIS_WPartGraphVKway(
	 &nVertices,                        // number of vertices
	 &XAdj[0],                          // adjacency structure
	 &Adjacency[0],
	 NULL, NULL, &lWeigth,              // weighting
	 &lStyle,                           // Zero for C Style (starting in 0)
	 &nParts,                           // number of parts
	 &PartitionFractions[0],            // fractioning of partitions
	 &Options[0],                       // options
	 &CommVolume,                       // total communication volume
	 &partIndex[0]                      // the final partition
  );
  */
#endif
}


