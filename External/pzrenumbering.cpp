// -*- c++ -*-
// Generated by Together

#include "pzrenumbering.h"
#include "pzvec.h"
#include "pzerror.h"
#include "pzstack.h"

void TPZRenumbering::NodeToElGraph(TPZVec<int> &elgraph, TPZVec<int> &elgraphindex, TPZVec<int> &nodtoelgraph, TPZVec<int> &nodtoelgraphindex){
  /*        cout << "fNNodes +1: " << (fNNodes+1) << endl;
	cout << "fNElements " << fNElements << endl;	
	cout << "elgraph.NElements()" <<elgraph.NElements() <<endl;
	cout << "elgraphindex.NElements()" <<elgraphindex.NElements() <<endl;
  */
	TPZVec<int> nelcon(fNNodes+1,0);
  	int nod,last = elgraphindex[fNElements];
  	for(nod = 0; nod<last; nod++) {
    		nelcon[elgraph[nod]]++;
  	}
	nodtoelgraphindex = nelcon;
/* 	cout << "Numero de elementos nodtoelgraph = " << nodtoelgraphindex.NElements() << endl; */
/* 	cout << "fNNodes = " << fNNodes << endl; */
/* 	for(nod=0;nod<fNNodes;nod++) cout << "nodtoelgraphindex[i] = " << nod << " " << nodtoelgraphindex[nod] <<endl; */
/* 	cout.flush(); */
  	for(nod=fNNodes; nod>0; nod--) nodtoelgraphindex[nod] = nodtoelgraphindex[nod-1];
  	nodtoelgraphindex[0] = 0;
  	for(nod=1;nod<=fNNodes;nod++) nodtoelgraphindex[nod] += nodtoelgraphindex[nod-1];
  
	//nodtoelgraph(nodtoelgraphindex[fNNodes],-1);
	nodtoelgraph.Resize(nodtoelgraphindex[fNNodes]);
	nodtoelgraph.Fill (-1);
	
	int el;
  	for(el=0; el<fNElements; el++) {
    		int firstnode = elgraphindex[el];
    		int lastnode = elgraphindex[el+1];
    		for(nod=firstnode;nod<lastnode;nod++) {
      			int gnod = elgraph[nod];
      			int firstel= nodtoelgraphindex[gnod];
      			int lastel = nodtoelgraphindex[gnod+1];
      			while(firstel<lastel && nodtoelgraph[firstel] != -1) firstel++;
      			if(firstel == lastel) {
				PZError << "TPZCompMesh::ComputeConnecttoElGraph wrong data structure\n";
				continue;
      			} else {
			  //  cout << "node " << gnod << " connected to element " << el << endl;
				nodtoelgraph[firstel] = el;
      			}
    		}
  	}       
	//	Print(nodtoelgraph,nodtoelgraphindex,"Node to Element Graph");
}


void TPZRenumbering::ConvertGraph(TPZVec<int> &elgraph, TPZVec<int> &elgraphindex, TPZVec<int> &nodegraph, TPZVec<int> &nodegraphindex){

	int nod,el;
	TPZVec<int> nodtoelgraphindex;
	TPZVec<int> nodtoelgraph;
	
	NodeToElGraph(elgraph,elgraphindex,nodtoelgraph,nodtoelgraphindex);

	//	Print(elgraph,elgraphindex,"Grapho de elementos",cout);
//	cout << "nodegraphindex.NElements() = " << nodegraphindex.NElements() << endl;
//	cout << "nodegraph.NElements() = " << nodegraph.NElements() << endl;
//	cout.flush();
	//	Print(nodtoelgraph,nodtoelgraphindex,"Grapho de nos",cout);

	nodegraphindex.Resize(fNNodes+1);
  	nodegraphindex.Fill(0);
//	cout << "Passou por aqui0\n";
	int nodegraphincrement = 100;
  	nodegraph.Resize(nodegraphincrement);       
  	int nodegraphsize = nodegraph.NElements();
  	int nextfreeindex = 0;
  	for(nod=0; nod<fNNodes; nod++) {
    		int firstel = nodtoelgraphindex[nod];
    		int lastel = nodtoelgraphindex[nod+1];
    		int firstnode = nodegraphindex[nod];
    		for(el=firstel; el<lastel; el++) {
      			int gel = nodtoelgraph[el];
      			int firstelnode = elgraphindex[gel];
      			int lastelnode = elgraphindex[gel+1];
      			int elnode;
      			for(elnode=firstelnode; elnode<lastelnode; elnode++) {
				int gelnode = elgraph[elnode];
				int gn = firstnode;
				if(gelnode == nod) continue;
				while(gn < nextfreeindex && nodegraph[gn] != gelnode) gn++;
				if(gn == nextfreeindex) {
	  				if(nextfreeindex == nodegraphsize) {
	    					nodegraph.Resize(nodegraphsize+nodegraphincrement);
	    					nodegraphsize += nodegraphincrement;
	  				}
	  				nodegraph[gn] = gelnode;
	  				nextfreeindex++;
				}
      			}
    		}
    		nodegraphindex[nod+1] = nextfreeindex;
  	}
	//	Print(nodegraph,nodegraphindex,"Node to Node graph");
}


TPZRenumbering::TPZRenumbering(int NElements, int NNodes){
  fNElements = NElements;
  fNNodes = NNodes;
}

int TPZRenumbering::ColorNodes(TPZVec<int> &nodegraph, TPZVec<int> &nodegraphindex, TPZVec<int> &family, TPZVec<int> &colors) {

  TPZStack<int> usedcolors;
  TPZStack<int> ncolorsbyfamily;
  if(nodegraph.NElements()-1 != family.NElements()) {
    cout << "TPZRenumbering::ColorNodes inconsistent input parameters\n";
  }
  int nnodes = nodegraphindex.NElements()-1;
  colors.Resize(nnodes);
  colors.Fill(-1);
  int curfam = 0;
  int nodeshandled = 0;
  int ncolors = 0;
  while(nodeshandled < nnodes) {
    int nod;
    curfam = 0;
    usedcolors.Resize(0);
    for(nod = 0; nod < nnodes; nod++) {
      int firstnod = nodegraphindex[nod];
      int lastnod = nodegraphindex[nod+1];
      usedcolors.Fill(-1);
      int ind, nodcon;
      for(ind= firstnod; ind<lastnod; ind++) {
	nodcon = nodegraph[ind];
	if(family[nodcon] != curfam) continue;
	if(colors[nodcon] != -1) usedcolors[colors[nodcon]] = 1;
      }
      int ic;
      for(ic=0; ic<usedcolors.NElements(); ic++) if(usedcolors[ic] != 1) break;
      if(ic == usedcolors.NElements()) usedcolors.Push(1);
      colors[nod] = ic;
      nodeshandled++;
    }
    ncolorsbyfamily.Push(usedcolors.NElements());
    ncolors += usedcolors.NElements();
    curfam++;
  }
  return ncolors;
}

void TPZRenumbering::Print(TPZVec<int> &grapho, TPZVec<int> &graphoindex, const char *name, ostream& out){

	int i,j;
	out << "Grapho: " << name << endl;
	for (i=0;i<graphoindex.NElements()-1;i++){
		out << "Grapho item: " << i << "\t";
		for(j=graphoindex[i];j<graphoindex[i+1];j++){
		  if(j >= grapho.NElements()) {
		    cout << "graphoindex errado grapho.NElements = " << grapho.NElements() << " i = " << i << "graphoindex[i] = " << graphoindex[i] << " " << graphoindex[i+1] << endl;
		    break;
		  } else {
			out << grapho[j] <<"\t";
		  }
		}
		cout << endl;
	}
}
	

