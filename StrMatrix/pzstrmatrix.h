//$Id: pzstrmatrix.h,v 1.8 2010-02-18 20:32:46 phil Exp $

/* Generated by Together */

#ifndef TPZSTRUCTMATRIX_H
#define TPZSTRUCTMATRIX_H

#include <set>
#include <map>
#include <semaphore.h>

#include "pzvec.h"
#include "tpzautopointer.h"
#include "pzelmat.h"

class TPZCompMesh;
class TPZMatrix;
class TPZFMatrix;

#ifdef WIN32
	class TExecuteProdIndex;
#endif

/**
 * Is responsible for a interface among Matrix and Finite Element classes.
 * @ingroup structural
 */
class TPZStructMatrix {

public:    

  TPZStructMatrix(TPZCompMesh *);
  
  TPZStructMatrix(const TPZStructMatrix &copy)
  {
    fMesh = copy.fMesh;
    fMinEq = copy.fMinEq;
    fMaxEq = copy.fMaxEq;
	  fMaterialIds = copy.fMaterialIds;
  }

  virtual ~TPZStructMatrix();

  virtual TPZMatrix * Create();

  virtual TPZMatrix * CreateAssemble(TPZFMatrix &rhs);

  virtual TPZStructMatrix * Clone();

  /**
  * Assemble the global system of equations into the matrix which has already been created
  */
  virtual void Assemble(TPZMatrix & mat, TPZFMatrix & rhs);

	/**
	 * Assemble the global right hand side
	 */
	virtual void Assemble(TPZFMatrix & rhs);
	
	/**
	 * Assemble the global right hand side
	 */
	virtual void pthread_Assemble(TPZFMatrix & rhs);
	
	/**
	 * Assemble the global system of equations into the matrix which has already been created
	 */
	virtual void pthread_Assemble(TPZMatrix & mat, TPZFMatrix & rhs);
	
  /// Determine that the assembly refers to a range of equations
  void SetEquationRange(int mineq, int maxeq)
  {
    fMinEq = mineq;
    fMaxEq = maxeq;
  }
  
  /// Verify if a range has been specified
  bool HasRange()
  {
    return (fMinEq != -1 && fMaxEq != -1);
  }

  /// filter out the equations which are out of the range
  static void FilterEquations(TPZVec<int> &origindex, TPZVec<int> &destindex, int mineq, int upeq);

	
	/// Set the set of material ids which will be considered when assembling the system
	void SetMaterialIds(const std::set<int> &materialids);
	
	/// Establish whether the element should be computed
	bool ShouldCompute(int matid)
	{
		return fMaterialIds.size()==0 || fMaterialIds.find(matid) != fMaterialIds.end();
	}
	/// access the material ids
	std::set<int> MaterialIds()
	{
		return fMaterialIds;
	}
	 
private:
  /** 
   * Assemble the global system of equation into mat and rhs.
   * A set with material ids may be provided in order to integrate
   * a few materials only (param MaterialIds). If MaterialIds == NULL
   * all elements will be computed.
	 */
#ifdef WIN32
	static void Assemble(TPZMatrix & mat, TPZFMatrix & rhs,
											 TPZCompMesh &mesh,
											 int mineq = -1,int maxeq = -1,
											 std::set<int> *MaterialIds = NULL,
											 TExecuteProdIndex * myThread = NULL);
#else
	static void Assemble(TPZMatrix & mat, TPZFMatrix & rhs,
											 TPZCompMesh &mesh,
											 int mineq = -1,int maxeq = -1,
											 std::set<int> *MaterialIds = NULL);
	static void pthread_Assemble(TPZMatrix & mat, TPZFMatrix & rhs,
						 TPZCompMesh &mesh,
						 int mineq = -1,int maxeq = -1,
						 std::set<int> *MaterialIds = NULL);
#endif

  /** 
   * Assemble the global system of equation into rhs.
   * A set with material ids may be provided in order to integrate
   * a few materials only (param MaterialIds). If MaterialIds == NULL
   * all elements will be computed.
   */
  static void Assemble(TPZFMatrix & rhs, 
                       TPZCompMesh &mesh, 
                       int mineq = -1, int maxeq = -1, 
                       std::set<int> *MaterialIds = NULL);

	/** 
	 * Assemble the global system of equation into rhs.
	 * A set with material ids may be provided in order to integrate
	 * a few materials only (param MaterialIds). If MaterialIds == NULL
	 * all elements will be computed.
	 */
	static void pthread_Assemble(TPZFMatrix & rhs, 
						 TPZCompMesh &mesh, 
						 int mineq = -1, int maxeq = -1, 
						 std::set<int> *MaterialIds = NULL);
	
protected:
	
struct ThreadData
{
	// Initialize the mutex semaphores and others
	ThreadData(TPZCompMesh &mesh,TPZMatrix &mat, TPZFMatrix &rhs, int mineq, int maxeq, std::set<int> *MaterialIds);
	// Destroy the mutex semaphores and others
	~ThreadData();
	// current structmatrix object
	TPZCompMesh *fMesh;
	// mutexes (to choose which element is next)
	pthread_mutex_t fAccessElement;
	// semaphore (to wake up assembly thread)
	sem_t *fAssembly;
	// global matrix
	TPZMatrix *fGlobMatrix;
	// global rhs
	TPZFMatrix *fGlobRhs;
	// minimum equation to be assembled
	int fMinEq;
	// maximum equation to be assembled
	int fMaxEq;
	/// material identifiers which need to be computed
	std::set<int> fMaterialIds;
	// list of computed element matrices (autopointers?)
	std::map<int, std::pair< TPZAutoPointer<TPZElementMatrix>, TPZAutoPointer<TPZElementMatrix> > > fSubmitted;
	// elements which are being processed
	std::set<int> fProcessed;
	// current element
	int fNextElement;
	// look for an element index which needs to be computed and put it on the stack
	int NextElement();
	// put the computed element matrices in the map
	void ComputedElementMatrix(int iel, TPZAutoPointer<TPZElementMatrix> &ek, TPZAutoPointer<TPZElementMatrix> &ef);
	// The function which will compute the matrices
	static void *ThreadWork(void *threaddata);
	// The function which will compute the assembly
	static void *ThreadAssembly(void *threaddata);
	
};
	
	friend class ThreadData;
protected:

  /**
   * @supplierCardinality 1 
   */
  TPZCompMesh * fMesh;
  
  /** Equation range for assembly of the global matrix
   */
  int fMinEq, fMaxEq;
	// set of material ids to be considered
	std::set<int> fMaterialIds;
};
#endif //TPZSTRUCTMATRIX_H
