// -*- c++ -*-

//$Id: pzstrmatrix.cpp,v 1.17 2007-04-19 21:53:49 tiago Exp $

/* Generated by Together */

#include "pzstrmatrix.h"
#include "pzvec.h"
#include "pzfmatrix.h"
#include "pzmanvector.h"
#include "pzadmchunk.h"
#include "pzcmesh.h"
#include "pzgmesh.h"
#include "pzelmat.h"
#include "pzcompel.h"
#include "pzintel.h"

#include "pzgnode.h"
#include "TPZTimer.h"
//#include "pzmat2dlin.h"

using namespace std;

#include "pzlog.h"

#ifdef LOG4CXX
static LoggerPtr logger(Logger::getLogger("pz.strmatrix.tpzstructmatrix"));
#endif


TPZStructMatrix::~TPZStructMatrix() {}

TPZMatrix *TPZStructMatrix::CreateAssemble(TPZFMatrix &rhs) {
  cout << "TPZStructMatrix::CreateAssemble should never be called\n";
  return 0;
}

TPZMatrix *TPZStructMatrix::CreateAssemble(TPZFMatrix &rhs, std::set<int> &MaterialIds) {
  TPZMatrix * mat = this->Create();
  if (!mat){
    cout << __PRETTY_FUNCTION__ << " should never be called\n";
    return NULL;
  }
  this->Assemble(*mat,rhs,MaterialIds);  
  return mat;
}

TPZMatrix *TPZStructMatrix::Create() {
  cout << "TPZStructMatrix::Create should never be called\n";
  return 0;
}

TPZStructMatrix *TPZStructMatrix::Clone() {
  cout << "TPZStructMatrix::Clone should never be called\n";
  return 0;
}

//ofstream out("MATRIZES.out");
void TPZStructMatrix::Assemble(TPZMatrix & stiffness, TPZFMatrix & rhs, TPZCompMesh &mesh){
//  out << "Assembly process initiated\n";
  int iel;
  //int numel = 0;
  int nelem = mesh.NElements();
  TPZElementMatrix ek(&mesh, TPZElementMatrix::EK),ef(&mesh, TPZElementMatrix::EF);
  TPZManVector<int> destinationindex(0);
  TPZManVector<int> sourceindex(0);

  TPZTimer calcstiff("Computing the stiffness matrices");
  TPZTimer assemble("Assembling the stiffness matrices");
  TPZAdmChunkVector<TPZCompEl *> &elementvec = mesh.ElementVec();

  for(iel=0; iel < nelem; iel++) {
    TPZCompEl *el = elementvec[iel];
    if(!el) continue;

    //	  int dim = el->NumNodes();
//#ifndef _AUTODIFF
    calcstiff.start();
    el->CalcStiff(ek,ef);
    calcstiff.stop();
//#else
//    TPZInterpolatedElement * pIntel = NULL;
//    pIntel = dynamic_cast<TPZInterpolatedElement *>(el);
//    if(pIntel)
//    {
//       pIntel->CalcEnergy(ek,ef);
//    }else
//    {
//       el->CalcStiff(ek,ef);
//    }
//#endif
//     if( nelem < 34 || (nelem > 33 && iel < 33) ){
//       out << "Element id : " << el->Reference()->Id() << endl;
//       el->Print(out);
//       ek.fMat.Print("MATRIZ EK",out);
//       ef.fMat.Print("VETOR  EF",out);
//       out.flush();
//     }
    //    if(!(numel%20)) cout << endl << numel;
    //    cout << '*';
    //    cout.flush();
    //    numel++;
    assemble.start();

    if(!el->HasDependency()) {
      //ek.fMat->Print("stiff has no constraint",test);
      //ef.fMat->Print("rhs has no constraint",test);
      //test.flush();
      destinationindex.Resize(ek.fMat.Rows());
      int destindex = 0;
      int numnod = ek.NConnects();
      for(int in=0; in<numnod; in++) {
         int npindex = ek.ConnectIndex(in);
         TPZConnect &np = mesh.ConnectVec()[npindex];
         int blocknumber = np.SequenceNumber();
         int firsteq = mesh.Block().Position(blocknumber);
         int ndf = mesh.Block().Size(blocknumber);
	 //	 if (numnod == 27){
	 //   cout << "First equation " << firsteq <<"\t ndf " << ndf << endl;
	 //	 }
         for(int idf=0; idf<ndf; idf++) {
           destinationindex[destindex++] = firsteq+idf;
         }
      }
      stiffness.AddKel(ek.fMat,destinationindex);
      rhs.AddFel(ef.fMat,destinationindex);
    } else {
      // the element has dependent nodes
      ek.ApplyConstraints();
      ef.ApplyConstraints();
      //ek.fMat->Print("stif no constraint",test);
      //ek.fConstrMat->Print("stif constrained",test);
      //ef.fMat->Print("rhs no constraint",test);
      //ef.fConstrMat->Print("rhs constrained",test);
      //test.flush();
      //test << "sum of columns\n";
      int destindex = 0;
      int fullmatindex = 0;
      destinationindex.Resize(ek.fConstrMat.Rows());
      sourceindex.Resize(ek.fConstrMat.Rows());
      int numnod = ek.fConstrConnect.NElements();
      for(int in=0; in<numnod; in++) {
         int npindex = ek.fConstrConnect[in];
         TPZConnect &np = mesh.ConnectVec()[npindex];
         int blocknumber = np.SequenceNumber();
         int firsteq = mesh.Block().Position(blocknumber);
         int ndf = mesh.Block().Size(blocknumber);
         if(np.HasDependency()) {
           fullmatindex += ndf;
           continue;
         }
         for(int idf=0; idf<ndf; idf++) {
           sourceindex[destindex] = fullmatindex++;
           destinationindex[destindex++] = firsteq+idf;
         }
      }
      sourceindex.Resize(destindex);
      destinationindex.Resize(destindex);
      stiffness.AddKel(ek.fConstrMat,sourceindex,destinationindex);
      rhs.AddFel(ef.fConstrMat,sourceindex,destinationindex);
/*
if(ek.fConstrMat->Decompose_LU() != -1) {
    el->ApplyConstraints(ek,ef);
    ek.Print(*this,check);
    check.flush();
}
*/
    }
    assemble.stop();
  }//fim for iel
#ifdef LOG4CXX
  {
    std::stringstream sout;
    sout << calcstiff.processName() << " " << calcstiff << std::endl;
    sout << assemble.processName() << " " << assemble;
    LOGPZ_DEBUG(logger,sout.str().c_str());
  }
#endif
//
//  int neq = rhs.Rows();
/*  if(nelem < 34 && neq < 100){
    stiffness.Print("TPZStructMatrix::Assemble GLOBAL MATRIX (after Assemble)",out);
    rhs.Print("TPZStructMatrix::Assemble GLOBAL LOAD (after Assemble)",out);
  }*/
}


void TPZStructMatrix::Assemble(TPZMatrix & stiffness, TPZFMatrix & rhs){
  if (fMesh){
    TPZStructMatrix::Assemble(stiffness, rhs, *fMesh);
  }
}

TPZStructMatrix::TPZStructMatrix(TPZCompMesh *mesh){
    fMesh = mesh;
}

void TPZStructMatrix::Assemble(TPZFMatrix & rhs, TPZCompMesh &mesh){
//  out << "Assembly process initiated\n";
  int iel;
  //int numel = 0;
  int nelem = mesh.NElements();
  TPZElementMatrix ef(&mesh, TPZElementMatrix::EF);

  TPZTimer calcresidual("Computing the residual vector");
  TPZTimer assemble("Assembling the residual vector");
  TPZAdmChunkVector<TPZCompEl *> &elementvec = mesh.ElementVec();

  for(iel=0; iel < nelem; iel++) {
    TPZCompEl *el = elementvec[iel];
    if(!el) continue;

    //	  int dim = el->NumNodes();
//#ifndef _AUTODIFF
    calcresidual.start();
    el->CalcResidual(ef);
    calcresidual.stop();
//#else
//    TPZInterpolatedElement * pIntel = NULL;
//    pIntel = dynamic_cast<TPZInterpolatedElement *>(el);
//    if(pIntel)
//    {
//       pIntel->CalcEnergy(ek,ef);
//    }else
//    {
//       el->CalcStiff(ek,ef);
//    }
//#endif
//     if( nelem < 34 || (nelem > 33 && iel < 33) ){
//       out << "Element id : " << el->Reference()->Id() << endl;
//       el->Print(out);
//       ek.fMat.Print("MATRIZ EK",out);
//       ef.fMat.Print("VETOR  EF",out);
//       out.flush();
//     }
    //    if(!(numel%20)) cout << endl << numel;
    //    cout << '*';
    //    cout.flush();
    //    numel++;
    assemble.start();

    if(!el->HasDependency()) {
      //ek.fMat->Print("stiff has no constraint",test);
      //ef.fMat->Print("rhs has no constraint",test);
      //test.flush();
      ef.ComputeDestinationIndices();
      rhs.AddFel(ef.fMat, ef.fDestinationIndex);
    } else {
      // the element has dependent nodes
      ef.ApplyConstraints();
      ef.ComputeDestinationIndices();
      rhs.AddFel(ef.fConstrMat,ef.fSourceIndex,ef.fDestinationIndex);
/*
if(ek.fConstrMat->Decompose_LU() != -1) {
    el->ApplyConstraints(ek,ef);
    ek.Print(*this,check);
    check.flush();
}
*/
    }
    assemble.stop();
  }//fim for iel
#ifdef LOG4CXX
  {
    std::stringstream sout;
    sout << calcstiff.processName() << " " << calcstiff << std::endl;
    sout << assemble.processName() << " " << assemble;
    LOGPZ_DEBUG(logger,sout.str().c_str());
  }
#endif
//
//  int neq = rhs.Rows();
/*  if(nelem < 34 && neq < 100){
    stiffness.Print("TPZStructMatrix::Assemble GLOBAL MATRIX (after Assemble)",out);
    rhs.Print("TPZStructMatrix::Assemble GLOBAL LOAD (after Assemble)",out);
  }*/
}

void TPZStructMatrix::Assemble(TPZMatrix & stiffness, TPZFMatrix & rhs, std::set<int> &MaterialIds){

  int iel;
  int nelem = fMesh->NElements();
  TPZElementMatrix ek(fMesh,TPZElementMatrix::EK),ef(fMesh,TPZElementMatrix::EF);

  TPZTimer calcstiff("Computing the stiffness matrices");
  TPZTimer assemble("Assembling the stiffness matrices");
  TPZAdmChunkVector<TPZCompEl *> &elementvec = fMesh->ElementVec();

  for(iel=0; iel < nelem; iel++) {
    TPZCompEl *el = elementvec[iel];
    if(!el) continue;

    TPZAutoPointer<TPZMaterial> mat = el->Material();
    if (!mat) continue;
    int matid = mat->Id();
    if (MaterialIds.find(matid) == MaterialIds.end()) continue;

    calcstiff.start();
    el->CalcStiff(ek,ef);
    ek.ComputeDestinationIndices();
    ef.ComputeDestinationIndices();
    calcstiff.stop();

    assemble.start();

    if(!el->HasDependency()) {
      stiffness.AddKel(ek.fMat,ek.fDestinationIndex);
      rhs.AddFel(ef.fMat,ef.fDestinationIndex);
    } else {
      // the element has dependent nodes
      ek.ApplyConstraints();
      ef.ApplyConstraints();
      stiffness.AddKel(ek.fConstrMat,ek.fSourceIndex,ek.fDestinationIndex);
      rhs.AddFel(ef.fConstrMat,ef.fSourceIndex,ef.fDestinationIndex);
    }
    assemble.stop();
  }//fim for iel
#ifdef LOG4CXX
  {
    std::stringstream sout;
    sout << calcstiff.processName() << " " << calcstiff << std::endl;
    sout << assemble.processName() << " " << assemble;
    LOGPZ_DEBUG(logger,sout.str().c_str());
  }
#endif
}

