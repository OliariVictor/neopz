// -*- c++ -*-

//$Id: pzstrmatrix.cpp,v 1.19 2007-05-01 03:55:35 phil Exp $

/* Generated by Together */

#include "pzstrmatrix.h"
#include "pzvec.h"
#include "pzfmatrix.h"
#include "pzmanvector.h"
#include "pzadmchunk.h"
#include "pzcmesh.h"
#include "pzgmesh.h"
#include "pzelmat.h"
#include "pzcompel.h"
#include "pzintel.h"

#include "pzgnode.h"
#include "TPZTimer.h"
//#include "pzmat2dlin.h"

using namespace std;

#include "pzlog.h"

#ifdef LOG4CXX
static LoggerPtr logger(Logger::getLogger("pz.strmatrix.tpzstructmatrix"));
#endif


TPZStructMatrix::~TPZStructMatrix() {}

TPZMatrix *TPZStructMatrix::CreateAssemble(TPZFMatrix &rhs) {
  cout << "TPZStructMatrix::CreateAssemble should never be called\n";
  return 0;
}

TPZMatrix *TPZStructMatrix::CreateAssemble(TPZFMatrix &rhs, std::set<int> &MaterialIds) {
  TPZMatrix * mat = this->Create();
  if (!mat){
    cout << __PRETTY_FUNCTION__ << " should never be called\n";
    return NULL;
  }
  this->Assemble(*mat,rhs,MaterialIds);  
  return mat;
}

TPZMatrix *TPZStructMatrix::Create() {
  cout << "TPZStructMatrix::Create should never be called\n";
  return 0;
}

TPZStructMatrix *TPZStructMatrix::Clone() {
  cout << "TPZStructMatrix::Clone should never be called\n";
  return 0;
}

//ofstream out("MATRIZES.out");
void TPZStructMatrix::Assemble(TPZMatrix & stiffness, TPZFMatrix & rhs, TPZCompMesh &mesh,
                              int mineq, int maxeq){
//  out << "Assembly process initiated\n";
  int iel;
  //int numel = 0;
  int nelem = mesh.NElements();
  TPZElementMatrix ek(&mesh, TPZElementMatrix::EK),ef(&mesh, TPZElementMatrix::EF);
//  TPZManVector<int> destinationindex(0);
//  TPZManVector<int> sourceindex(0);

  TPZTimer calcstiff("Computing the stiffness matrices");
  TPZTimer assemble("Assembling the stiffness matrices");
  TPZAdmChunkVector<TPZCompEl *> &elementvec = mesh.ElementVec();

  for(iel=0; iel < nelem; iel++) {
    TPZCompEl *el = elementvec[iel];
    if(!el) continue;

    //	  int dim = el->NumNodes();
//#ifndef _AUTODIFF
    calcstiff.start();
    el->CalcStiff(ek,ef);
    calcstiff.stop();
//#else
//    TPZInterpolatedElement * pIntel = NULL;
//    pIntel = dynamic_cast<TPZInterpolatedElement *>(el);
//    if(pIntel)
//    {
//       pIntel->CalcEnergy(ek,ef);
//    }else
//    {
//       el->CalcStiff(ek,ef);
//    }
//#endif
//     if( nelem < 34 || (nelem > 33 && iel < 33) ){
//       out << "Element id : " << el->Reference()->Id() << endl;
//       el->Print(out);
//       ek.fMat.Print("MATRIZ EK",out);
//       ef.fMat.Print("VETOR  EF",out);
//       out.flush();
//     }
    //    if(!(numel%20)) cout << endl << numel;
    //    cout << '*';
    //    cout.flush();
    //    numel++;
    assemble.start();

    if(!el->HasDependency()) {
      //ek.fMat->Print("stiff has no constraint",test);
      //ef.fMat->Print("rhs has no constraint",test);
      //test.flush();
      ek.ComputeDestinationIndices();
      if(mineq != -1 && maxeq != -1)
      {
        FilterEquations(ek.fSourceIndex,ek.fDestinationIndex,mineq,maxeq);
      }
      stiffness.AddKel(ek.fMat,ek.fSourceIndex,ek.fDestinationIndex);
      rhs.AddFel(ef.fMat,ek.fSourceIndex,ek.fDestinationIndex);
    } else {
      // the element has dependent nodes
      ek.ApplyConstraints();
      ef.ApplyConstraints();
      //ek.fMat->Print("stif no constraint",test);
      //ek.fConstrMat->Print("stif constrained",test);
      //ef.fMat->Print("rhs no constraint",test);
      //ef.fConstrMat->Print("rhs constrained",test);
      //test.flush();
      //test << "sum of columns\n";
      ek.ComputeDestinationIndices();
      if(mineq != -1 & maxeq != -1)
      {
        FilterEquations(ek.fSourceIndex,ek.fDestinationIndex,mineq,maxeq);
      }
      stiffness.AddKel(ek.fConstrMat,ek.fSourceIndex,ek.fDestinationIndex);
      rhs.AddFel(ef.fConstrMat,ek.fSourceIndex,ek.fDestinationIndex);
/*
if(ek.fConstrMat->Decompose_LU() != -1) {
    el->ApplyConstraints(ek,ef);
    ek.Print(*this,check);
    check.flush();
}
*/
    }
    assemble.stop();
  }//fim for iel
#ifdef LOG4CXX
  {
    std::stringstream sout;
    sout << calcstiff.processName() << " " << calcstiff << std::endl;
    sout << assemble.processName() << " " << assemble;
    LOGPZ_DEBUG(logger,sout.str().c_str());
  }
#endif
//
//  int neq = rhs.Rows();
/*  if(nelem < 34 && neq < 100){
    stiffness.Print("TPZStructMatrix::Assemble GLOBAL MATRIX (after Assemble)",out);
    rhs.Print("TPZStructMatrix::Assemble GLOBAL LOAD (after Assemble)",out);
  }*/
}


void TPZStructMatrix::Assemble(TPZMatrix & stiffness, TPZFMatrix & rhs){
  if (fMesh){
    TPZStructMatrix::Assemble(stiffness, rhs, *fMesh,fMinEq,fMaxEq);
  }
}

TPZStructMatrix::TPZStructMatrix(TPZCompMesh *mesh) : fMinEq(-1), fMaxEq(-1) {
    fMesh = mesh;
}

void TPZStructMatrix::Assemble(TPZFMatrix & rhs, TPZCompMesh &mesh, int mineq, int maxeq){
//  out << "Assembly process initiated\n";
  int iel;
  //int numel = 0;
  int nelem = mesh.NElements();
  TPZElementMatrix ef(&mesh, TPZElementMatrix::EF);

  TPZTimer calcresidual("Computing the residual vector");
  TPZTimer assemble("Assembling the residual vector");
  TPZAdmChunkVector<TPZCompEl *> &elementvec = mesh.ElementVec();

  for(iel=0; iel < nelem; iel++) {
    TPZCompEl *el = elementvec[iel];
    if(!el) continue;

    //	  int dim = el->NumNodes();
//#ifndef _AUTODIFF
    calcresidual.start();
    el->CalcResidual(ef);
    calcresidual.stop();
//#else
//    TPZInterpolatedElement * pIntel = NULL;
//    pIntel = dynamic_cast<TPZInterpolatedElement *>(el);
//    if(pIntel)
//    {
//       pIntel->CalcEnergy(ek,ef);
//    }else
//    {
//       el->CalcStiff(ek,ef);
//    }
//#endif
//     if( nelem < 34 || (nelem > 33 && iel < 33) ){
//       out << "Element id : " << el->Reference()->Id() << endl;
//       el->Print(out);
//       ek.fMat.Print("MATRIZ EK",out);
//       ef.fMat.Print("VETOR  EF",out);
//       out.flush();
//     }
    //    if(!(numel%20)) cout << endl << numel;
    //    cout << '*';
    //    cout.flush();
    //    numel++;
    assemble.start();

    if(!el->HasDependency()) {
      //ek.fMat->Print("stiff has no constraint",test);
      //ef.fMat->Print("rhs has no constraint",test);
      //test.flush();
      ef.ComputeDestinationIndices();
      if(mineq != -1 & maxeq != -1)
      {
        FilterEquations(ef.fSourceIndex,ef.fDestinationIndex,mineq,maxeq);
      }
      rhs.AddFel(ef.fMat, ef.fSourceIndex, ef.fDestinationIndex);
    } else {
      // the element has dependent nodes
      ef.ApplyConstraints();
      ef.ComputeDestinationIndices();
      if(mineq != -1 & maxeq != -1)
      {
        FilterEquations(ef.fSourceIndex,ef.fDestinationIndex,mineq,maxeq);
      }
      rhs.AddFel(ef.fConstrMat,ef.fSourceIndex,ef.fDestinationIndex);
/*
if(ek.fConstrMat->Decompose_LU() != -1) {
    el->ApplyConstraints(ek,ef);
    ek.Print(*this,check);
    check.flush();
}
*/
    }
    assemble.stop();
  }//fim for iel
#ifdef LOG4CXX
  {
    std::stringstream sout;
    sout << calcresidual.processName() << " " << calcresidual << std::endl;
    sout << assemble.processName() << " " << assemble;
    LOGPZ_DEBUG(logger,sout.str().c_str());
  }
#endif
//
//  int neq = rhs.Rows();
/*  if(nelem < 34 && neq < 100){
    stiffness.Print("TPZStructMatrix::Assemble GLOBAL MATRIX (after Assemble)",out);
    rhs.Print("TPZStructMatrix::Assemble GLOBAL LOAD (after Assemble)",out);
  }*/
}

void TPZStructMatrix::Assemble(TPZMatrix & stiffness, TPZFMatrix & rhs, std::set<int> &MaterialIds){

  int iel;
  int nelem = fMesh->NElements();
  TPZElementMatrix ek(fMesh,TPZElementMatrix::EK),ef(fMesh,TPZElementMatrix::EF);

  TPZTimer calcstiff("Computing the stiffness matrices");
  TPZTimer assemble("Assembling the stiffness matrices");
  TPZAdmChunkVector<TPZCompEl *> &elementvec = fMesh->ElementVec();

  for(iel=0; iel < nelem; iel++) {
    TPZCompEl *el = elementvec[iel];
    if(!el) continue;

    TPZAutoPointer<TPZMaterial> mat = el->Material();
    if (!mat) continue;
    int matid = mat->Id();
    if (MaterialIds.find(matid) == MaterialIds.end()) continue;

    calcstiff.start();
    el->CalcStiff(ek,ef);
    ek.ComputeDestinationIndices();
    if(this->HasRange())
    {
      FilterEquations(ek.fSourceIndex,ek.fDestinationIndex,fMinEq,fMaxEq);
    }
    calcstiff.stop();

    assemble.start();

    if(!el->HasDependency()) {
      stiffness.AddKel(ek.fMat,ek.fSourceIndex,ek.fDestinationIndex);
      rhs.AddFel(ef.fMat,ek.fSourceIndex, ek.fDestinationIndex);
    } else {
      // the element has dependent nodes
      ek.ApplyConstraints();
      ef.ApplyConstraints();
      stiffness.AddKel(ek.fConstrMat,ek.fSourceIndex,ek.fDestinationIndex);
      rhs.AddFel(ef.fConstrMat,ek.fSourceIndex,ek.fDestinationIndex);
    }
    assemble.stop();
  }//fim for iel
#ifdef LOG4CXX
  {
    std::stringstream sout;
    sout << calcstiff.processName() << " " << calcstiff << std::endl;
    sout << assemble.processName() << " " << assemble;
    LOGPZ_DEBUG(logger,sout.str().c_str());
  }
#endif
}

  
  /// filter out the equations which are out of the range
void TPZStructMatrix::FilterEquations(TPZVec<int> &origindex, TPZVec<int> &destindex, int mineq, int upeq)
{
  if(mineq == -1 || upeq == -1) return;
  int count = 0;
  int nel = origindex.NElements();
  int i;
  for(i=0; i<nel; i++)
  {
    if(destindex[i] >= mineq && destindex[i] < upeq)
    {
      origindex[count] = origindex[i];
      destindex[count++] = destindex[i]-mineq;
    }
  }
  origindex.Resize(count);
  destindex.Resize(count);
  
}
