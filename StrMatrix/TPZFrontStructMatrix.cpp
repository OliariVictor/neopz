// -*- c++ -*-
/* Generated by Together */



#include "pzstrmatrix.h"
#include "pzfstrmatrix.h"
#include "TPZFrontStructMatrix.h"

#include "pzgmesh.h"
#include "pzcmesh.h"
#include "pzsubcmesh.h"
#include "pzconnect.h"
#include "pzadmchunk.h"

#include "pzsmfrontalanal.h"

#include "pzelgq2d.h"
#include "pzelcq2d.h"
#include "pzmat2dlin.h"

#include "pzanalysis.h"
#include "pzsolve.h"
#include "pzstepsolver.h"
#include "TPZFrontMatrix.h"

#include "pzdxmesh.h"
#include <fstream>
using namespace std;

#include "pzelmat.h"


void UniformRefine(int num, TPZGeoMesh &m);
template <class front>
void TPZFrontStructMatrix<front>::GetNumElConnected(TPZVec <int> &numelconnected){
	int ic;
	
	cout << "Numero de Equacoes -> " << fMesh->NEquations() << endl;
	cout.flush();
	
	fMesh->ComputeNodElCon();
///////////////////////////////////////////////////////////////
/////////////// É AQUI???/////////////////////////////////////
	/* case the mesh is a submesh  connects are summed
		 on external nodes in order to the frontal method
		 don't decompose these equations
		 Cesar - 02/11.01 */
	if (fMesh->FatherMesh()){
		int i;
		TPZVec<int> extcon;
		((TPZSubCompMesh*)fMesh)->GetExternalConnectIndex(extcon);
		for (i=0; i<extcon.NElements(); i++){
			int connindex = extcon[i];
			fMesh->ConnectVec()[connindex].IncrementElConnected();
		}
	}
/////////////////////////////////////////////////////////////////
	
	for(ic=0; ic<fMesh->ConnectVec().NElements(); ic++) {
		TPZConnect &cn = fMesh->ConnectVec()[ic];
		if(cn.HasDependency()) continue;
		int seqn = cn.SequenceNumber();
		if(seqn < 0) continue;
		int firsteq = fMesh->Block().Position(seqn);
		int lasteq = firsteq+fMesh->Block().Size(seqn);
		int ind;
		for(ind=firsteq;ind<lasteq;ind++) numelconnected[ind] = fMesh->ConnectVec()[ic].NElConnected();
	}
/*cout << "GetNumElConnected::numelconnected : ";
int i;
for(i=0; i<numelconnected.NElements(); i++) cout << numelconnected[i] << ' ';
cout << endl;
cout.flush();*/
}

template<class front>
TPZFrontStructMatrix<front>::TPZFrontStructMatrix(TPZCompMesh *mesh): TPZStructMatrix(mesh) { 


  //TPZFrontMatrix<TPZFileEqnStorage, TPZFrontNonSym> *mat = new TPZFrontMatrix<TPZFileEqnStorage, TPZFrontNonSym>(fMesh->NEquations());
	//TPZFrontMatrix<TPZStackEqnStorage, TPZFrontNonSym> *mat = new TPZFrontMatrix<TPZStackEqnStorage, TPZFrontNonSym>(cmesh.NEquations());
	//TPZFrontMatrix<TPZStackEqnStorage> *mat = new TPZFrontMatrix<TPZStackEqnStorage>(cmesh.NEquations());

/*  TPZVec<int> numelconnected(fMesh->NEquations(),0);
  TPZFrontMatrix<TPZStackEqnStorage, TPZFrontNonSym> *mat = new TPZFrontMatrix<TPZStackEqnStorage, TPZFrontNonSym>(fMesh->NEquations());
  GetNumElConnected(numelconnected);
  mat->SetNumElConnected(numelconnected);*/
}


template<class front>
TPZFrontStructMatrix<front>::~TPZFrontStructMatrix(){}



template<class front>  
TPZMatrix * TPZFrontStructMatrix<front>::Create(){

    /* TPZVec <int> numelconnected(fMesh->NEquations(),0);  
    // TPZFrontMatrix<TPZStackEqnStorage, TPZFrontNonSym> *mat = new TPZFrontMatrix<TPZStackEqnStorage, TPZFrontNonSym>(fMesh->NEquations());

     GetNumElConnected(numelconnected);
     //mat->SetNumElConnected(numelconnected);
     return mat;  
     */
  return 0;
}
  
template<class front>     
TPZStructMatrix * TPZFrontStructMatrix<front>::Clone(){
     
     return new TPZFrontStructMatrix<front>(fMesh);
}
template<class front>
void TPZFrontStructMatrix<front>::OrderElement()//TPZVec<int> &elorder)
{
	int numelconnected = 0;
	int nconnect = fMesh->ConnectVec().NElements();
	int ic;
	//firstelconnect contains the first element index in the elconnect vector
	TPZVec<int> firstelconnect(nconnect+1);
	firstelconnect[0] = 0;
	for(ic=0; ic<nconnect; ic++) {
		numelconnected += fMesh->ConnectVec()[ic].NElConnected();
		firstelconnect[ic+1] = firstelconnect[ic]+fMesh->ConnectVec()[ic].NElConnected();
	}
//cout << "numelconnected " << numelconnected << endl;
//cout << "firstelconnect ";
//  for(ic=0; ic<nconnect; ic++) cout << firstelconnect[ic] << ' ';
  	TPZVec<int> elconnect(numelconnected,-1);
  	int el;
  	TPZCompEl *cel;
  	for(el=0; el<fMesh->ElementVec().NElements(); el++) {
  		cel = fMesh->ElementVec()[el];
  		if(!cel) continue;
  		TPZStack<int> connectlist;
  		cel->BuildConnectList(connectlist);
  		int nc = connectlist.NElements();
  		int ic;
  		for(ic=0; ic<nc; ic++) {
  			int cindex = connectlist[ic];
  			elconnect[firstelconnect[cindex]] = el;
  			firstelconnect[cindex]++;
  		}
  	}
//  for(ic=0; ic<numelconnected; ic++) cout << elconnect[ic] << endl;
  	firstelconnect[0] = 0;
  	for(ic=0; ic<nconnect; ic++) {
  		firstelconnect[ic+1] = firstelconnect[ic]+fMesh->ConnectVec()[ic].NElConnected();
  	}
  //cout << "elconnect\n";
//  int no;
//  for(no=0; no< fMesh->ConnectVec().NElements(); no++) {
  	//cout << "no numero " << no << ' ' << " seq num " << fMesh->ConnectVec()[no].SequenceNumber() << ' ';
//       for(ic=firstelconnect[no]; ic<firstelconnect[no+1];ic++) cout << elconnect[ic] << ' ';
  	//cout << endl;
//  }
  	fElementOrder.Resize(fMesh->ElementVec().NElements(),-1);
  	fElementOrder.Fill(-1);
  	TPZVec<int> nodeorder(fMesh->ConnectVec().NElements(),-1);
  	firstelconnect[0] = 0;
  	for(ic=0; ic<nconnect; ic++) {
  		int seqnum = fMesh->ConnectVec()[ic].SequenceNumber();
  		if(seqnum >= 0) nodeorder[seqnum] = ic;
  	}
//  cout << "nodeorder ";
/*  for(ic=0; ic<fMesh->ConnectVec().NElements(); ic++) cout << nodeorder[ic] << ' ';
  cout << endl;
  cout.flush();*/
  	int seq;
  	int elsequence = 0;
  	TPZVec<int> elorderinv(fMesh->ElementVec().NElements(),-1);
  	for(seq=0; seq<nconnect; seq++) {
  		ic = nodeorder[seq];
  		if(ic == -1) continue;
  		int firstind = firstelconnect[ic];
  		int lastind = firstelconnect[ic+1];
  		int ind;
  		for(ind=firstind; ind<lastind; ind++) {
  			el = elconnect[ind];
			if(el == -1) {
				continue;
			}
  			if(elorderinv[el]==-1) elorderinv[el] = elsequence++;
  		}
  	}
//  cout << "elorderinv ";
//  for(seq=0;seq<fMesh->ElementVec().NElements();seq++) cout << elorderinv[seq] << ' ';
//  cout << endl;
  	elsequence = 0;
  	for(seq=0;seq<fMesh->ElementVec().NElements();seq++) {
  		if(elorderinv[seq] == -1) continue;
  		fElementOrder[elorderinv[seq]] = seq;
  	}
//  cout << "elorder" << endl;
//  for(ic=0; ic<fMesh->ElementVec().NElements(); ic++) cout << elorder[ic] << endl;

}

template<class front>
TPZMatrix * TPZFrontStructMatrix<front>::CreateAssemble(TPZFMatrix &rhs){

     TPZVec <int> numelconnected(fMesh->NEquations(),0);
     //TPZFrontMatrix<TPZStackEqnStorage, front> *mat = new TPZFrontMatrix<TPZStackEqnStorage, front>(fMesh->NEquations());
     
     TPZFrontMatrix<TPZFileEqnStorage, front> *mat = new TPZFrontMatrix<TPZFileEqnStorage, front>(fMesh->NEquations());
     GetNumElConnected(numelconnected);
     mat->SetNumElConnected(numelconnected);
     
     OrderElement();

     Assemble(*mat,rhs);

	 if(fMesh->FatherMesh()) {
		 TPZSubCompMesh *csmesh = dynamic_cast<TPZSubCompMesh *> (fMesh);
		 if(csmesh) {
			TPZSubMeshFrontalAnalysis *an = dynamic_cast<TPZSubMeshFrontalAnalysis *> (csmesh->GetAnalysis());
			an->SetFront(mat->GetFront());
		 }

		 mat->FinishWriting();
		 mat->ReOpen();
	 }
     return mat;
}

template<class front>
void TPZFrontStructMatrix<front>::AssembleNew(TPZMatrix & stiffness, TPZFMatrix & rhs){

  int iel;            
  int numel = 0, nelem = fMesh->NElements();
  TPZElementMatrix ek,ef;
  TPZManVector<int> destinationindex(0);
  TPZManVector<int> sourceindex(0);

  TPZAdmChunkVector<TPZCompEl *> &elementvec = fMesh->ElementVec();
  
  
  /**Rearange elements order*/
  TPZVec<int> elorder(fMesh->NEquations(),0);

  OrderElement();
  

  for(iel=0; iel < nelem; iel++) {
  
    if(fElementOrder[iel] < 0) continue;
    TPZCompEl *el = elementvec[fElementOrder[iel]];
    if(!el) continue;
    //		int dim = el->NumNodes();
    
    //Builds elements stiffness matrix
    el->CalcStiff(ek,ef);
      //ek.fMat->Print(out);
    //ef.fMat->Print();
    if(!(numel%20)) cout << endl << numel;
//    if(!(numel%20)) cout << endl; 
    cout << '*';
    cout.flush();
    numel++;

    if(!el->HasDependency()) {
      //ek.fMat->Print("stiff has no constraint",test);
      //ef.fMat->Print("rhs has no constraint",test);
      //test.flush();
      destinationindex.Resize(ek.fMat.Rows());
      int destindex = 0;
      int numnod = ek.NConnects();
      for(int in=0; in<numnod; in++) {
         int npindex = ek.ConnectIndex(in);
         TPZConnect &np = fMesh->ConnectVec()[npindex];
         int blocknumber = np.SequenceNumber();
         int firsteq = fMesh->Block().Position(blocknumber);
         int ndf = fMesh->Block().Size(blocknumber);
         for(int idf=0; idf<ndf; idf++) {
           destinationindex[destindex++] = firsteq+idf;
         }
      }
      //ek.Print(*fMesh,cout);     
      stiffness.AddKel(ek.fMat,destinationindex);
      rhs.AddFel(ef.fMat,destinationindex);                 //  ??????????? Erro
    }
    else {
      // the element has dependent nodes
      el->ApplyConstraints(ek,ef);
      //ek.fMat->Print("stif no constraint",test);
      //ek.fConstrMat->Print("stif constrained",test);
      //ef.fMat->Print("rhs no constraint",test);
      //ef.fConstrMat->Print("rhs constrained",test);
      //test.flush();
      //test << "sum of columns\n";
      int destindex = 0;
      int fullmatindex = 0;
      destinationindex.Resize(ek.fConstrMat.Rows());
      sourceindex.Resize(ek.fConstrMat.Rows());
      int numnod = ek.fConstrConnect.NElements();
      for(int in=0; in<numnod; in++) {
         int npindex = ek.fConstrConnect[in];
         TPZConnect &np = fMesh->ConnectVec()[npindex];
         int blocknumber = np.SequenceNumber();
         int firsteq = fMesh->Block().Position(blocknumber);
         int ndf = fMesh->Block().Size(blocknumber);
         if(np.HasDependency()) {
           fullmatindex += ndf;
           continue;
         }
         for(int idf=0; idf<ndf; idf++) {
           sourceindex[destindex] = fullmatindex++;
           destinationindex[destindex++] = firsteq+idf;
         }
      }
      sourceindex.Resize(destindex);
      destinationindex.Resize(destindex);
      //ek.Print(*fMesh,cout);     
      stiffness.AddKel(ek.fConstrMat,sourceindex,destinationindex);
      rhs.AddFel(ef.fConstrMat,sourceindex,destinationindex);
/*
if(ek.fConstrMat->Decompose_LU() != -1) {
    el->ApplyConstraints(ek,ef);
    ek.Print(*this,check);
    check.flush();
}
*/
    }
    
  }//fim for iel
  cout << endl;
}


template<class front>
void TPZFrontStructMatrix<front>::Assemble(TPZMatrix & stiffness, TPZFMatrix & rhs){

  int iel;
  int numel = 0, nelem = fMesh->NElements();
  TPZElementMatrix ek,ef;

  TPZAdmChunkVector<TPZCompEl *> &elementvec = fMesh->ElementVec();
  
  
  /**Rearange elements order*/
  TPZVec<int> elorder(fMesh->NEquations(),0);

//  OrderElement();



  

  for(iel=0; iel < nelem; iel++) {
  
     if(fElementOrder[iel] < 0) continue;
     TPZCompEl *el = elementvec[fElementOrder[iel]];
     if(!el) continue;
     //		int dim = el->NumNodes();
    
     //Builds elements stiffness matrix
     el->CalcStiff(ek,ef);
     AssembleElement(el, ek, ef, stiffness, rhs); 
     
     if(!(numel%20)) cout << endl << numel;
     cout << '*';
     cout.flush();
     numel++;
      
  }//fim for iel

}



//Verificar declaracao dos parametros !!!!!
template<class front>
void TPZFrontStructMatrix<front>::AssembleElement(TPZCompEl * el, TPZElementMatrix & ek, TPZElementMatrix & ef, TPZMatrix & stiffness, TPZFMatrix & rhs){
     
     TPZManVector<int> destinationindex(0);
     TPZManVector<int> sourceindex(0);

     if(!el->HasDependency()) {
          //ek.fMat->Print("stiff has no constraint",test);
          //ef.fMat->Print("rhs has no constraint",test);
          //test.flush();
          destinationindex.Resize(ek.fMat.Rows());
          int destindex = 0;
          int numnod = ek.NConnects();
          for(int in=0; in<numnod; in++) {
               int npindex = ek.ConnectIndex(in);
               TPZConnect &np = fMesh->ConnectVec()[npindex];
               int blocknumber = np.SequenceNumber();
               int firsteq = fMesh->Block().Position(blocknumber);
               int ndf = fMesh->Block().Size(blocknumber);
               for(int idf=0; idf<ndf; idf++) {
                    destinationindex[destindex++] = firsteq+idf;
               }
          }
          //ek.Print(*fMesh,cout);
          stiffness.AddKel(ek.fMat,destinationindex);
          rhs.AddFel(ef.fMat,destinationindex);                 //  ??????????? Erro
     }
     else
     {
          // the element has dependent nodes
          el->ApplyConstraints(ek,ef);
          //ek.fMat->Print("stif no constraint",test);
          //ek.fConstrMat->Print("stif constrained",test);
          //ef.fMat->Print("rhs no constraint",test);
          //ef.fConstrMat->Print("rhs constrained",test);
          //test.flush();
          //test << "sum of columns\n";
          int destindex = 0;
          int fullmatindex = 0;
          destinationindex.Resize(ek.fConstrMat.Rows());
          sourceindex.Resize(ek.fConstrMat.Rows());
          int numnod = ek.fConstrConnect.NElements();
          for(int in=0; in<numnod; in++) {
               int npindex = ek.fConstrConnect[in];
               TPZConnect &np = fMesh->ConnectVec()[npindex];
               int blocknumber = np.SequenceNumber();
               int firsteq = fMesh->Block().Position(blocknumber);
               int ndf = fMesh->Block().Size(blocknumber);
               if(np.HasDependency()) {
                    fullmatindex += ndf;
                    continue;
               }

               for(int idf=0; idf<ndf; idf++) {
                    sourceindex[destindex] = fullmatindex++;
                    destinationindex[destindex++] = firsteq+idf;
               }
          }

          sourceindex.Resize(destindex);
          destinationindex.Resize(destindex);
          //ek.Print(*fMesh,cout);     
          stiffness.AddKel(ek.fConstrMat,sourceindex,destinationindex);
          rhs.AddFel(ef.fConstrMat,sourceindex,destinationindex);
     }
}

template<class front>
int TPZFrontStructMatrix<front>::main() {
     int refine = 5;
     int order = 2;
     
	TPZGeoMesh gmesh;
	TPZCompMesh cmesh(&gmesh);
	double coordstore[4][3] = {{0.,0.,0.},{1.,0.,0.},{1.,1.,0.},
	  {0.,1.,0.}};

	int i,j;
	TPZVec<REAL> coord(3,0.); 
	for(i=0; i<4; i++) {
		// initializar as coordenadas do no em um vetor
		for (j=0; j<3; j++) coord[j] = coordstore[i][j];

		// identificar um espaço no vetor onde podemos armazenar
		// este vetor

		// initializar os dados do nó
		gmesh.NodeVec ()[i].Initialize (i,coord,gmesh);
	}
	int el;
	TPZGeoEl *gel;
	for(el=0; el<1; el++) {
	  
	  // initializar os indices dos nós
	  TPZVec<int> indices(4);
	  for(i=0; i<4; i++) indices[i] = i;
	  // O proprio construtor vai inserir o elemento na malha
	  gel = new TPZGeoElQ2d(el,indices,1,gmesh);
	}
	gmesh.BuildConnectivity ();

	TPZVec<TPZGeoEl *> subel;
	//gel->Divide(subel);

	
	
	cout << "Refinement ";
	cin >> refine;
	cout << endl;
	UniformRefine(refine,gmesh);
	


	TPZMat2dLin *meumat = new TPZMat2dLin(1);
	TPZFMatrix xk(1,1,1.),xc(1,2,0.),xf(1,1,1.);
	meumat->SetMaterial (xk,xc,xf);
	cmesh.InsertMaterialObject(meumat);

	TPZFMatrix val1(1,1,0.),val2(1,1,0.);
	TPZMaterial *bnd = meumat->CreateBC (-4,0,val1,val2);
	cmesh.InsertMaterialObject(bnd);

	
	
	cout << "Interpolation order ";
	cin >> order;
	cout << endl;
	
	TPZCompEl::gOrder = order;

	cmesh.AutoBuild();
//	cmesh.AdjustBoundaryElements();
	cmesh.InitializeBlock();

	ofstream output("outputNon.dat");	
//	ofstream output2("outputNon.dat");
	cmesh.Print(output);
	TPZAnalysis an(&cmesh,output);
//	TPZAnalysis an2(&cmesh,output);

	TPZVec<int> numelconnected(cmesh.NEquations(),0);
	int ic;
	cout << "Número de Equações -> " << cmesh.NEquations() << endl;
	cout.flush();
	
	ofstream out("cmeshBlock_out.txt");
//	cmesh.Print(out);
//	cmesh.Block().Print("Block",out);
	for(ic=0; ic<cmesh.ConnectVec().NElements(); ic++) {
		TPZConnect &cn = cmesh.ConnectVec()[ic];
		if(cn.HasDependency()) continue;
		int seqn = cn.SequenceNumber();
		if(seqn < 0) continue;
		int firsteq = cmesh.Block().Position(seqn);
		int lasteq = firsteq+cmesh.Block().Size(seqn);
		int ind;
		int temp = cmesh.ConnectVec()[ic].NElConnected();
		for(ind=firsteq;ind<lasteq;ind++) {
		     numelconnected[ind] = temp;//cmesh.ConnectVec()[ic].NElConnected();
		}
	}
//	cout << "nequations " << numelconnected.NElements();
//	for(ic=0;ic<numelconnected.NElements(); ic++) cout << numelconnected[ic] <<' ';
//	cout << endl;
//	cout.flush();

//	TPZFrontMatrix<TPZFileEqnStorage, TPZFrontNonSym> *mat = new TPZFrontMatrix<TPZFileEqnStorage, TPZFrontNonSym>(cmesh.NEquations());
	//TPZFrontMatrix<TPZStackEqnStorage, TPZFrontNonSym> *mat = new TPZFrontMatrix<TPZStackEqnStorage, TPZFrontNonSym>(cmesh.NEquations());
	//TPZFrontMatrix<TPZStackEqnStorage> *mat = new TPZFrontMatrix<TPZStackEqnStorage>(cmesh.NEquations());
  
     TPZFrontStructMatrix<TPZFrontSym> mat(&cmesh);
     
//   TPZFStructMatrix mat2(&cmesh);
//  mat->SetNumElConnected(numelconnected);
	//mat = CreateAssemble();
		
	
	an.SetStructuralMatrix(mat);      
//	an2.SetStructuralMatrix(mat2);
	
	TPZStepSolver sol;
	sol.SetDirect(ECholesky);
//	TPZStepSolver sol2;
//	sol2.SetDirect(ECholesky);
//	sol.SetDirect(ELU);
	
	
	an.SetSolver(sol);
//     an2.SetSolver(sol2);
//	mat->SetNumElConnected(numelconnected);
//	mat->SetFileName("longhin.bin");
//	an.Solver().SetDirect(ELU);
//	mat->FinishWriting();
//  mat->SetFileName('r',"longhin.bin");
//	cout << "******************************************************************************************************AQUI 1" << endl;
	an.Run(output);
	an.Print("solution of frontal solver", output);
//	cout << "******************************************************************************************************AQUI 2" << endl;
//	an2.Run(output2);
//	an2.Print("solution of frontal solver", output2);
/*	
	TPZVec<char *> scalnames(1);
	scalnames[0] = "state";

	TPZVec<char *> vecnames(0);

	TPZDXGraphMesh graph(&cmesh,2,meumat,vecnames,scalnames);
	ofstream *dxout = new ofstream("poisson.dx");
	graph.SetOutFile(*dxout);
	graph.SetResolution(0);

	//an.DefineGraphMesh(2, scalnames, vecnames, plotfile);
	//an.Print("FEM SOLUTION ",output);
	//an.PostProcess(1);
	int istep = 0,numstep=1;

	graph.DrawMesh(numstep+1);
	graph.DrawSolution(0,0);
  
	TPZAnalysis an2(&cmesh,output);
	TPZFMatrix *full = new TPZFMatrix(cmesh.NEquations(),cmesh.NEquations(),0.);
	an2.SetMatrix(full);
	an2.Solver().SetDirect(ELU);
	an2.Run(output);
	an2.Print("solution of full matrix", output);

//	full->Print("full decomposed matrix");
*/
	output.flush();
	cout.flush();
	return 0;

}

class TPZFrontSym;
class TPZFrontNonSym;

template class TPZFrontStructMatrix<TPZFrontSym>;
template class TPZFrontStructMatrix<TPZFrontNonSym>;


void UniformRefine(int num, TPZGeoMesh &m){
  
  int ref;
  for(ref=0; ref< num; ref++) {
        cout << "Refinement " << ref << endl;
        cout.flush();
    int nelem = m.ElementVec().NElements();
    TPZVec<TPZGeoEl*> subel;
    int iel;
    cout << "Element ";
    for(iel=0; iel<nelem; iel++) {
                if(iel%500==0){
                        cout << iel << " ";
                        cout.flush();
                }
                if(iel%5000==0 && iel){
                        cout << endl;
                        cout.flush();
                }
      TPZGeoEl *gel = m.ElementVec()[iel];
      if(!gel) continue;
      gel->Divide(subel);
    }
        cout << endl;
  }                        
}
