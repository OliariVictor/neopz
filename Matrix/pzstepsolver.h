/* Generated by Together */

#ifndef TPZSTEPSOLVER_H
#define TPZSTEPSOLVER_H
#include "pzsolve.h"
class TPZFMatrix;

/**
   Defines step solvers class
   @ingroup solvers
*/
class TPZStepSolver : public TPZMatrixSolver {
public:  
  TPZStepSolver(TPZMatrix *refmat=0);

  TPZStepSolver(const TPZStepSolver & copy);

    virtual ~TPZStepSolver();

    void SetSOR(const int numiterations,const REAL overrelax,const REAL tol,const int FromCurrent);

    void SetSSOR(const int numiterations,const REAL overrelax,const REAL tol,const int FromCurrent);

    void SetJacobi(const int numiterations,const REAL tol,const int FromCurrent);

    void SetCG(const int numiterations,const TPZMatrixSolver &pre,const REAL tol,const int FromCurrent);

    void SetGMRES(const int numiterations,const int numvectors, const TPZMatrixSolver &pre,const REAL tol,const int FromCurrent);

    void SetDirect (const DecomposeType decomp);

  void SetMultiply();

    virtual TPZSolver *Clone() const { return new TPZStepSolver(*this);}

  void SetTolerance(REAL tol) { fTol = tol; }

    void ResetSolver();

  /**
  This method will reset the matrix associated with the solver
  This is useful when the matrix needs to be recomputed in a non linear problem
  */
  virtual void ResetMatrix();
  /**
     Sets a matrix to the current object
     @param RefMat Sets reference matrix to RefMat     
  */
virtual  void SetMatrix(TPZMatrix *Refmat)
{
  TPZMatrixSolver::SetMatrix(Refmat);
}

  /**
  This method gives a preconditioner to share a matrix with the referring solver object
  */
  virtual void SetMatrix(TPZMatrixSolver *solver);
  
    void Solve(const TPZFMatrix &F, TPZFMatrix &result, TPZFMatrix *residual = 0);

private:  
    MSolver fSolver;
    DecomposeType fDecompose;
    int fNumIterations;
  int fNumVectors;
    REAL fTol;
    REAL fOverRelax;

    /**
     * @supplierCardinality 1 
     */
    TPZSolver *fPrecond;
    int fFromCurrent;
};
#endif //TPZSTEPSOLVER_H
