/* Generated by Together */

#include "pzseqsolver.h"

TPZSequenceSolver::TPZSequenceSolver(TPZMatrix *refmat) : TPZMatrixSolver(refmat), fSolvers() {
}
TPZSequenceSolver::TPZSequenceSolver(const TPZSequenceSolver & copy)
    : TPZMatrixSolver(copy) {
    int nums = copy.fSolvers.NElements();
    int s;
    for(s=0; s<nums; s++) AppendSolver(*copy.fSolvers[s]);
}
class TPZSolver;
class TPZMatrixSolver;

TPZSolver * TPZSequenceSolver::Clone() const {
    return new TPZSequenceSolver(*this);
}
void TPZSequenceSolver::AppendSolver(TPZMatrixSolver & solve){
    fSolvers.Push((TPZMatrixSolver *) solve.Clone());
}
void TPZSequenceSolver::ResetSolver() {
    int nums = fSolvers.NElements();
    int s;
    for(s=0; s<nums; s++) delete fSolvers.Pop();
}
void TPZSequenceSolver::Solve(const TPZFMatrix &F, TPZFMatrix &result, TPZFMatrix *residual){
  if(!Matrix()) {
    cout << "TPZSequenceSolver::Solve called without a matrix pointer\n";
    exit(-1);
  }
  TPZMatrix *mat = Matrix();
  if(result.Rows() != mat->Rows() || result.Cols() != F.Cols()) {
    result.Redim(mat->Rows(),F.Cols());
  }

  fScratch = F;
  TPZFMatrix delu(result.Rows(),result.Cols(),0.);
  TPZFMatrix resloc(F.Rows(),F.Cols(),0.);
  result.Zero();
  if(fScratch.Rows() != result.Rows() || fScratch.Cols() != result.Cols()) {
	  fScratch.Redim(result.Rows(),result.Cols());
  }
    int nums = fSolvers.NElements();
    int s;
    for(s=0; s<nums; s++) {
        fSolvers[s]->Solve(fScratch,delu,&resloc);
        result += delu;
        mat->Residual(result,F,fScratch);
    }
    if(residual) *residual = fScratch;
}
